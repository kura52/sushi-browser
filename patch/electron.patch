diff --git a/atom/app/atom_main.cc b/atom/app/atom_main.cc
index a739c0926..115472ebd 100644
--- a/atom/app/atom_main.cc
+++ b/atom/app/atom_main.cc
@@ -68,12 +68,15 @@ void FixStdioStreams() {
   //
   // For details see https://github.com/libuv/libuv/issues/2062
   struct stat st;
+  FILE *fp;
   if (fstat(STDIN_FILENO, &st) < 0 && errno == EBADF)
-    freopen("/dev/null", "r", stdin);
+    fp = freopen("/dev/null", "r", stdin);
   if (fstat(STDOUT_FILENO, &st) < 0 && errno == EBADF)
-    freopen("/dev/null", "w", stdout);
+    fp = freopen("/dev/null", "w", stdout);
   if (fstat(STDERR_FILENO, &st) < 0 && errno == EBADF)
-    freopen("/dev/null", "w", stderr);
+    fp = freopen("/dev/null", "w", stderr);
+
+  if(fp == NULL){}
 }
 #endif
 
diff --git a/atom/browser/api/atom_api_browser_view.cc b/atom/browser/api/atom_api_browser_view.cc
index 6c9578c61..80ba7a687 100644
--- a/atom/browser/api/atom_api_browser_view.cc
+++ b/atom/browser/api/atom_api_browser_view.cc
@@ -4,6 +4,7 @@
 
 #include "atom/browser/api/atom_api_browser_view.h"
 
+#include "atom/browser/web_contents_preferences.h"
 #include "atom/browser/api/atom_api_web_contents.h"
 #include "atom/browser/browser.h"
 #include "atom/browser/native_browser_view.h"
@@ -61,8 +62,23 @@ void BrowserView::Init(v8::Isolate* isolate,
   mate::Dictionary web_preferences = mate::Dictionary::CreateEmpty(isolate);
   options.Get(options::kWebPreferences, &web_preferences);
   web_preferences.Set("isBrowserView", true);
-  mate::Handle<class WebContents> web_contents =
-      WebContents::Create(isolate, web_preferences);
+
+  mate::Handle<class WebContents> web_contents;
+    if (options.Get("webContents", &web_contents) && !web_contents.IsEmpty()) {
+    // Set webPreferences from options if using an existing webContents.
+    // These preferences will be used when the webContent launches new
+    // render processes.
+    auto* existing_preferences =
+        WebContentsPreferences::From(web_contents->web_contents());
+    base::DictionaryValue web_preferences_dict;
+    if (mate::ConvertFromV8(isolate, web_preferences.GetHandle(),
+                            &web_preferences_dict)) {
+      existing_preferences->Clear();
+      existing_preferences->Merge(web_preferences_dict);
+    }
+  } else {
+    web_contents = WebContents::Create(isolate, web_preferences);
+  }
 
   web_contents_.Reset(isolate, web_contents.ToV8());
   api_web_contents_ = web_contents.get();
diff --git a/atom/browser/api/atom_api_browser_window.cc b/atom/browser/api/atom_api_browser_window.cc
index 04712a7f1..375d4706e 100644
--- a/atom/browser/api/atom_api_browser_window.cc
+++ b/atom/browser/api/atom_api_browser_window.cc
@@ -309,6 +309,27 @@ void BrowserWindow::SetBrowserView(v8::Local<v8::Value> value) {
 #endif
 }
 
+void BrowserWindow::InsertBrowserView(v8::Local<v8::Value> value, int position) {
+  TopLevelWindow::InsertBrowserView(value, position);
+#if defined(OS_MACOSX)
+  UpdateDraggableRegions(nullptr, draggable_regions_);
+#endif
+}
+
+void BrowserWindow::EraseBrowserView(int position) {
+  TopLevelWindow::EraseBrowserView(position);
+#if defined(OS_MACOSX)
+  UpdateDraggableRegions(nullptr, draggable_regions_);
+#endif
+}
+
+void BrowserWindow::ReorderBrowserView(int position, int index) {
+  TopLevelWindow::ReorderBrowserView(position, index);
+#if defined(OS_MACOSX)
+  UpdateDraggableRegions(nullptr, draggable_regions_);
+#endif
+}
+
 void BrowserWindow::SetVibrancy(v8::Isolate* isolate,
                                 v8::Local<v8::Value> value) {
   std::string type = mate::V8ToString(value);
diff --git a/atom/browser/api/atom_api_browser_window.h b/atom/browser/api/atom_api_browser_window.h
index 074fcab7c..93d1f788e 100644
--- a/atom/browser/api/atom_api_browser_window.h
+++ b/atom/browser/api/atom_api_browser_window.h
@@ -72,6 +72,9 @@ class BrowserWindow : public TopLevelWindow,
   void Blur() override;
   void SetBackgroundColor(const std::string& color_name) override;
   void SetBrowserView(v8::Local<v8::Value> value) override;
+  void InsertBrowserView(v8::Local<v8::Value> value, int position) override;
+  void EraseBrowserView(int position) override;
+  void ReorderBrowserView(int position, int index) override;
   void SetVibrancy(v8::Isolate* isolate, v8::Local<v8::Value> value) override;
 
   // BrowserWindow APIs.
diff --git a/atom/browser/api/atom_api_top_level_window.cc b/atom/browser/api/atom_api_top_level_window.cc
index 0dda932e2..48bbcc3a8 100644
--- a/atom/browser/api/atom_api_top_level_window.cc
+++ b/atom/browser/api/atom_api_top_level_window.cc
@@ -160,6 +160,12 @@ void TopLevelWindow::OnWindowClosed() {
   RemoveFromParentChildWindows();
   ResetBrowserView();
 
+  if(!additional_browser_views_.empty()){
+    for (auto & item : additional_browser_views_) {
+      EraseBrowserView(item.first);
+    }
+  }
+
   // Destroy the native class when window is closed.
   base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, GetDestroyClosure());
 }
@@ -690,6 +696,34 @@ void TopLevelWindow::SetBrowserView(v8::Local<v8::Value> value) {
   }
 }
 
+void TopLevelWindow::InsertBrowserView(v8::Local<v8::Value> value, int position) {
+
+  mate::Handle<BrowserView> browser_view;
+  if (mate::ConvertFromV8(isolate(), value, &browser_view)) {
+    EraseBrowserView(position);
+    window_->InsertBrowserView(browser_view->view(), position);
+    browser_view->web_contents()->SetOwnerWindow(window_.get());
+    additional_browser_views_[position].Reset(isolate(), value);
+  }
+}
+
+void TopLevelWindow::EraseBrowserView(int position) {
+  if (additional_browser_views_.find(position) == additional_browser_views_.end()) {
+    return;
+  }
+
+  ResetAdditionalBrowserView(position);
+  window_->EraseBrowserView(position);
+}
+
+void TopLevelWindow::ReorderBrowserView(int position, int index) {
+  if (additional_browser_views_.find(position) == additional_browser_views_.end()) {
+    return;
+  }
+
+  window_->ReorderBrowserView(position, index);
+}
+
 v8::Local<v8::Value> TopLevelWindow::GetNativeWindowHandle() {
   // TODO(MarshallOfSound): Replace once
   // https://chromium-review.googlesource.com/c/chromium/src/+/1253094/ has
@@ -852,6 +886,14 @@ v8::Local<v8::Value> TopLevelWindow::GetBrowserView() const {
   return v8::Local<v8::Value>::New(isolate(), browser_view_);
 }
 
+v8::Local<v8::Value> TopLevelWindow::GetAddtionalBrowserView(int position) const {
+  if (additional_browser_views_.find(position) == additional_browser_views_.end()) {
+    return v8::Null(isolate());
+  }
+
+  return v8::Local<v8::Value>::New(isolate(), additional_browser_views_.at(position));
+}
+
 bool TopLevelWindow::IsModal() const {
   return window_->is_modal();
 }
@@ -954,6 +996,20 @@ void TopLevelWindow::ResetBrowserView() {
   browser_view_.Reset();
 }
 
+void TopLevelWindow::ResetAdditionalBrowserView(int position) {
+  if (additional_browser_views_.empty())
+    return;
+
+  mate::Handle<BrowserView> browser_view;
+  if (mate::ConvertFromV8(isolate(), GetAddtionalBrowserView(position), &browser_view) &&
+      !browser_view.IsEmpty()) {
+    browser_view->web_contents()->SetOwnerWindow(nullptr);
+  }
+
+  additional_browser_views_[position].Reset();
+  additional_browser_views_.erase(position);
+}
+
 void TopLevelWindow::RemoveFromParentChildWindows() {
   if (parent_window_.IsEmpty())
     return;
@@ -1063,6 +1119,9 @@ void TopLevelWindow::BuildPrototype(v8::Isolate* isolate,
       .SetMethod("setParentWindow", &TopLevelWindow::SetParentWindow)
 #endif
       .SetMethod("setBrowserView", &TopLevelWindow::SetBrowserView)
+      .SetMethod("insertBrowserView", &TopLevelWindow::InsertBrowserView)
+      .SetMethod("eraseBrowserView", &TopLevelWindow::EraseBrowserView)
+      .SetMethod("reorderBrowserView", &TopLevelWindow::ReorderBrowserView)
       .SetMethod("getNativeWindowHandle",
                  &TopLevelWindow::GetNativeWindowHandle)
       .SetMethod("setProgressBar", &TopLevelWindow::SetProgressBar)
@@ -1100,6 +1159,7 @@ void TopLevelWindow::BuildPrototype(v8::Isolate* isolate,
       .SetMethod("getParentWindow", &TopLevelWindow::GetParentWindow)
       .SetMethod("getChildWindows", &TopLevelWindow::GetChildWindows)
       .SetMethod("getBrowserView", &TopLevelWindow::GetBrowserView)
+      .SetMethod("getAddtionalBrowserView", &TopLevelWindow::GetAddtionalBrowserView)
       .SetMethod("isModal", &TopLevelWindow::IsModal)
       .SetMethod("setThumbarButtons", &TopLevelWindow::SetThumbarButtons)
 #if defined(TOOLKIT_VIEWS)
diff --git a/atom/browser/api/atom_api_top_level_window.h b/atom/browser/api/atom_api_top_level_window.h
index 809efaa59..d2bbcea5c 100644
--- a/atom/browser/api/atom_api_top_level_window.h
+++ b/atom/browser/api/atom_api_top_level_window.h
@@ -165,6 +165,9 @@ class TopLevelWindow : public mate::TrackableObject<TopLevelWindow>,
   void SetMenu(v8::Isolate* isolate, v8::Local<v8::Value> menu);
   void SetParentWindow(v8::Local<v8::Value> value, mate::Arguments* args);
   virtual void SetBrowserView(v8::Local<v8::Value> value);
+  virtual void InsertBrowserView(v8::Local<v8::Value> value, int position);
+  virtual void EraseBrowserView(int position);
+  virtual void ReorderBrowserView(int position, int index);
   v8::Local<v8::Value> GetNativeWindowHandle();
   void SetProgressBar(double progress, mate::Arguments* args);
   void SetOverlayIcon(const gfx::Image& overlay,
@@ -196,6 +199,7 @@ class TopLevelWindow : public mate::TrackableObject<TopLevelWindow>,
   v8::Local<v8::Value> GetParentWindow() const;
   std::vector<v8::Local<v8::Object>> GetChildWindows() const;
   v8::Local<v8::Value> GetBrowserView() const;
+  v8::Local<v8::Value> GetAddtionalBrowserView(int position) const;
   bool IsModal() const;
 
   // Extra APIs added in JS.
@@ -220,6 +224,7 @@ class TopLevelWindow : public mate::TrackableObject<TopLevelWindow>,
 
   // Remove BrowserView.
   void ResetBrowserView();
+  void ResetAdditionalBrowserView(int position);
 
   // Remove this window from parent window's |child_windows_|.
   void RemoveFromParentChildWindows();
@@ -239,6 +244,7 @@ class TopLevelWindow : public mate::TrackableObject<TopLevelWindow>,
 
   v8::Global<v8::Value> content_view_;
   v8::Global<v8::Value> browser_view_;
+  std::map<int, v8::Global<v8::Value>> additional_browser_views_;
   v8::Global<v8::Value> menu_;
   v8::Global<v8::Value> parent_window_;
   KeyWeakMap<int> child_windows_;
diff --git a/atom/browser/api/atom_api_web_contents.cc b/atom/browser/api/atom_api_web_contents.cc
index 24d8c0569..8ca41ebd4 100644
--- a/atom/browser/api/atom_api_web_contents.cc
+++ b/atom/browser/api/atom_api_web_contents.cc
@@ -1191,7 +1191,7 @@ void WebContents::LoadURL(const GURL& url, const mate::Dictionary& options) {
   }
 
   params.transition_type = ui::PAGE_TRANSITION_TYPED;
-  params.should_clear_history_list = true;
+  params.should_clear_history_list = false;
   params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
   web_contents()->GetController().LoadURLWithParams(params);
 
@@ -1245,21 +1245,77 @@ void WebContents::Stop() {
   web_contents()->Stop();
 }
 
+void WebContents::Reload() {
+  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().Reload(content::ReloadType::NORMAL, true);
+}
+
+void WebContents::ReloadIgnoringCache() {
+  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().Reload(content::ReloadType::BYPASSING_CACHE, true);
+}
+
+bool WebContents::CanGoBack() {
+  return web_contents()->GetController().CanGoBack();
+}
+
+bool WebContents::CanGoForward() {
+  return web_contents()->GetController().CanGoForward();
+}
+
 void WebContents::GoBack() {
   atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
   web_contents()->GetController().GoBack();
 }
 
+int WebContents::GetCurrentEntryIndex() {
+  return web_contents()->GetController().GetCurrentEntryIndex();
+}
+
+int WebContents::GetEntryCount() {
+  return web_contents()->GetController().GetEntryCount();
+}
+
+const GURL& WebContents::GetURLAtIndex(int index) const {
+  content::NavigationEntry* entry = web_contents()->GetController().GetEntryAtIndex(index);
+  if (entry)
+    return entry->GetURL();
+  else
+    return GURL::EmptyGURL();
+}
+
+const base::string16 WebContents::GetTitleAtIndex(int index) const {
+  content::NavigationEntry* entry = web_contents()->GetController().GetEntryAtIndex(index);
+  if (entry)
+    return entry->GetTitle();
+  else
+    return base::string16();
+}
+
+
+int WebContents::GetPendingEntryIndex() {
+  return web_contents()->GetController().GetPendingEntryIndex();
+}
+
 void WebContents::GoForward() {
   atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
   web_contents()->GetController().GoForward();
 }
 
+bool WebContents::CanGoToOffset(int offset) {
+  return web_contents()->GetController().CanGoToOffset(offset);
+}
+
 void WebContents::GoToOffset(int offset) {
   atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
   web_contents()->GetController().GoToOffset(offset);
 }
 
+void WebContents::GoToIndex(int index) {
+  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoToIndex(index);
+}
+
 const std::string WebContents::GetWebRTCIPHandlingPolicy() const {
   return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;
 }
@@ -2063,9 +2119,20 @@ void WebContents::BuildPrototype(v8::Isolate* isolate,
       .SetMethod("isLoadingMainFrame", &WebContents::IsLoadingMainFrame)
       .SetMethod("isWaitingForResponse", &WebContents::IsWaitingForResponse)
       .SetMethod("_stop", &WebContents::Stop)
+      .SetMethod("reload", &WebContents::Reload)
+      .SetMethod("reloadIgnoringCache", &WebContents::ReloadIgnoringCache)
+      .SetMethod("canGoBack", &WebContents::CanGoBack)
+      .SetMethod("canGoForward", &WebContents::CanGoForward)
+      .SetMethod("getEntryCount", &WebContents::GetEntryCount)
+      .SetMethod("getURLAtIndex", &WebContents::GetURLAtIndex)
+      .SetMethod("getTitleAtIndex", &WebContents::GetTitleAtIndex)
+      .SetMethod("getCurrentEntryIndex", &WebContents::GetCurrentEntryIndex)
+      .SetMethod("getPendingEntryIndex", &WebContents::GetPendingEntryIndex)
       .SetMethod("_goBack", &WebContents::GoBack)
       .SetMethod("_goForward", &WebContents::GoForward)
+      .SetMethod("canGoToOffset", &WebContents::CanGoToOffset)
       .SetMethod("_goToOffset", &WebContents::GoToOffset)
+      .SetMethod("goToIndex", &WebContents::GoToIndex)
       .SetMethod("isCrashed", &WebContents::IsCrashed)
       .SetMethod("setUserAgent", &WebContents::SetUserAgent)
       .SetMethod("getUserAgent", &WebContents::GetUserAgent)
diff --git a/atom/browser/api/atom_api_web_contents.h b/atom/browser/api/atom_api_web_contents.h
index c1535e9e8..5b4168445 100644
--- a/atom/browser/api/atom_api_web_contents.h
+++ b/atom/browser/api/atom_api_web_contents.h
@@ -135,10 +135,20 @@ class WebContents : public mate::TrackableObject<WebContents>,
   bool IsLoadingMainFrame() const;
   bool IsWaitingForResponse() const;
   void Stop();
+  void Reload();
   void ReloadIgnoringCache();
+  bool CanGoBack();
+  bool CanGoForward();
   void GoBack();
   void GoForward();
+  int GetEntryCount();
+  const GURL& GetURLAtIndex(int index) const;
+  const base::string16 GetTitleAtIndex(int index) const;
+  int GetCurrentEntryIndex();
+  int GetPendingEntryIndex();
+  bool CanGoToOffset(int offset);
   void GoToOffset(int offset);
+  void GoToIndex(int index);
   const std::string GetWebRTCIPHandlingPolicy() const;
   void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);
   bool IsCrashed() const;
diff --git a/atom/browser/api/event_subscriber.cc b/atom/browser/api/event_subscriber.cc
new file mode 100644
index 000000000..07193bdb8
--- /dev/null
+++ b/atom/browser/api/event_subscriber.cc
@@ -0,0 +1,124 @@
+// Copyright (c) 2017 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "atom/browser/api/event_subscriber.h"
+
+#include <string>
+#include <utility>
+
+#include "atom/common/native_mate_converters/callback.h"
+
+namespace {
+
+// A FunctionTemplate lifetime is bound to the v8 context, so it can be safely
+// stored as a global here since there's only one for the main process.
+v8::Global<v8::FunctionTemplate> g_cached_template;
+
+struct JSHandlerData {
+  JSHandlerData(v8::Isolate* isolate,
+                mate::internal::EventSubscriberBase* subscriber)
+      : handle_(isolate, v8::External::New(isolate, this)),
+        subscriber_(subscriber) {
+    handle_.SetWeak(this, GC, v8::WeakCallbackType::kFinalizer);
+  }
+
+  static void GC(const v8::WeakCallbackInfo<JSHandlerData>& data) {
+    delete data.GetParameter();
+  }
+
+  v8::Global<v8::External> handle_;
+  mate::internal::EventSubscriberBase* subscriber_;
+};
+
+void InvokeCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Locker locker(info.GetIsolate());
+  v8::HandleScope handle_scope(info.GetIsolate());
+  v8::Local<v8::Context> context = info.GetIsolate()->GetCurrentContext();
+  v8::Context::Scope context_scope(context);
+  mate::Arguments args(info);
+  v8::Local<v8::Value> handler, event;
+  args.GetNext(&handler);
+  args.GetNext(&event);
+  DCHECK(handler->IsExternal());
+  DCHECK(event->IsString());
+  JSHandlerData* handler_data = static_cast<JSHandlerData*>(
+      v8::Local<v8::External>::Cast(handler)->Value());
+  handler_data->subscriber_->EventEmitted(mate::V8ToString(event), &args);
+}
+
+}  // namespace
+
+namespace mate {
+
+namespace internal {
+
+EventSubscriberBase::EventSubscriberBase(v8::Isolate* isolate,
+                                         v8::Local<v8::Object> emitter)
+    : isolate_(isolate), emitter_(isolate, emitter) {
+  if (g_cached_template.IsEmpty()) {
+    g_cached_template = v8::Global<v8::FunctionTemplate>(
+        isolate_, v8::FunctionTemplate::New(isolate_, InvokeCallback));
+  }
+}
+
+EventSubscriberBase::~EventSubscriberBase() {
+  if (!isolate_) {
+    return;
+  }
+  RemoveAllListeners();
+  emitter_.Reset();
+  DCHECK_EQ(js_handlers_.size(), 0u);
+}
+
+void EventSubscriberBase::On(const std::string& event_name) {
+  DCHECK(js_handlers_.find(event_name) == js_handlers_.end());
+  v8::Locker locker(isolate_);
+  v8::Isolate::Scope isolate_scope(isolate_);
+  v8::HandleScope handle_scope(isolate_);
+  auto fn_template = g_cached_template.Get(isolate_);
+  auto event = mate::StringToV8(isolate_, event_name);
+  auto* js_handler_data = new JSHandlerData(isolate_, this);
+  v8::Local<v8::Value> fn = internal::BindFunctionWith(
+      isolate_, isolate_->GetCurrentContext(), fn_template->GetFunction(),
+      js_handler_data->handle_.Get(isolate_), event);
+  js_handlers_.insert(
+      std::make_pair(event_name, v8::Global<v8::Value>(isolate_, fn)));
+  internal::ValueVector converted_args = {event, fn};
+  internal::CallMethodWithArgs(isolate_, emitter_.Get(isolate_), "on",
+                               &converted_args);
+}
+
+void EventSubscriberBase::Off(const std::string& event_name) {
+  v8::Locker locker(isolate_);
+  v8::Isolate::Scope isolate_scope(isolate_);
+  v8::HandleScope handle_scope(isolate_);
+  auto js_handler = js_handlers_.find(event_name);
+  DCHECK(js_handler != js_handlers_.end());
+  RemoveListener(js_handler);
+}
+
+void EventSubscriberBase::RemoveAllListeners() {
+  v8::Locker locker(isolate_);
+  v8::Isolate::Scope isolate_scope(isolate_);
+  v8::HandleScope handle_scope(isolate_);
+  while (!js_handlers_.empty()) {
+    RemoveListener(js_handlers_.begin());
+  }
+}
+
+std::map<std::string, v8::Global<v8::Value>>::iterator
+EventSubscriberBase::RemoveListener(
+    std::map<std::string, v8::Global<v8::Value>>::iterator it) {
+  internal::ValueVector args = {StringToV8(isolate_, it->first),
+                                it->second.Get(isolate_)};
+  internal::CallMethodWithArgs(
+      isolate_, v8::Local<v8::Object>::Cast(emitter_.Get(isolate_)),
+      "removeListener", &args);
+  it->second.Reset();
+  return js_handlers_.erase(it);
+}
+
+}  // namespace internal
+
+}  // namespace mate
\ No newline at end of file
diff --git a/atom/browser/api/event_subscriber.h b/atom/browser/api/event_subscriber.h
new file mode 100644
index 000000000..4afe410ce
--- /dev/null
+++ b/atom/browser/api/event_subscriber.h
@@ -0,0 +1,141 @@
+// Copyright (c) 2017 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ATOM_BROWSER_API_EVENT_SUBSCRIBER_H_
+#define ATOM_BROWSER_API_EVENT_SUBSCRIBER_H_
+
+#include <map>
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "atom/common/api/event_emitter_caller.h"
+#include "base/synchronization/lock.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/arguments.h"
+
+namespace mate {
+
+namespace internal {
+
+class EventSubscriberBase {
+ public:
+  EventSubscriberBase(v8::Isolate* isolate, v8::Local<v8::Object> emitter);
+  virtual ~EventSubscriberBase();
+  virtual void EventEmitted(const std::string& event_name,
+                            mate::Arguments* args) = 0;
+
+ protected:
+  void On(const std::string& event_name);
+  void Off(const std::string& event_name);
+  void RemoveAllListeners();
+
+ private:
+  std::map<std::string, v8::Global<v8::Value>>::iterator RemoveListener(
+      std::map<std::string, v8::Global<v8::Value>>::iterator it);
+
+  v8::Isolate* isolate_;
+  v8::Global<v8::Object> emitter_;
+  std::map<std::string, v8::Global<v8::Value>> js_handlers_;
+
+  DISALLOW_COPY_AND_ASSIGN(EventSubscriberBase);
+};
+
+}  // namespace internal
+
+template <typename HandlerType>
+class EventSubscriber : internal::EventSubscriberBase {
+ public:
+  using EventCallback = void (HandlerType::*)(mate::Arguments* args);
+  // Alias to unique_ptr with deleter.
+  using unique_ptr = std::unique_ptr<EventSubscriber<HandlerType>,
+                                     void (*)(EventSubscriber<HandlerType>*)>;
+  // EventSubscriber should only be created/deleted in the main thread since it
+  // communicates with the V8 engine. This smart pointer makes it simpler to
+  // bind the lifetime of EventSubscriber with a class whose lifetime is managed
+  // by a non-UI thread.
+  class SafePtr : public unique_ptr {
+   public:
+    SafePtr() : SafePtr(nullptr) {}
+    explicit SafePtr(EventSubscriber<HandlerType>* ptr)
+        : unique_ptr(ptr, Deleter) {}
+
+   private:
+    // Custom deleter that schedules destructor invocation to the main thread.
+    static void Deleter(EventSubscriber<HandlerType>* ptr) {
+      DCHECK(
+          !::content::BrowserThread::CurrentlyOn(::content::BrowserThread::UI));
+      DCHECK(ptr);
+      // Acquire handler lock and reset handler_ to ensure that any new events
+      // emitted will be ignored after this function returns
+      base::AutoLock auto_lock(ptr->handler_lock_);
+      ptr->handler_ = nullptr;
+      content::BrowserThread::PostTask(
+          content::BrowserThread::UI, FROM_HERE,
+          base::BindOnce(
+              [](EventSubscriber<HandlerType>* subscriber) {
+                {
+                  // It is possible that this function will execute in the UI
+                  // thread before the outer function has returned and destroyed
+                  // its auto_lock. We need to acquire the lock before deleting
+                  // or risk a crash.
+                  base::AutoLock auto_lock(subscriber->handler_lock_);
+                }
+                delete subscriber;
+              },
+              ptr));
+    }
+  };
+
+  EventSubscriber(HandlerType* handler,
+                  v8::Isolate* isolate,
+                  v8::Local<v8::Object> emitter)
+      : EventSubscriberBase(isolate, emitter), handler_(handler) {
+    DCHECK_CURRENTLY_ON(::content::BrowserThread::UI);
+  }
+
+  void On(const std::string& event, EventCallback callback) {
+    DCHECK_CURRENTLY_ON(::content::BrowserThread::UI);
+    EventSubscriberBase::On(event);
+    callbacks_.insert(std::make_pair(event, callback));
+  }
+
+  void Off(const std::string& event) {
+    DCHECK_CURRENTLY_ON(::content::BrowserThread::UI);
+    EventSubscriberBase::Off(event);
+    DCHECK(callbacks_.find(event) != callbacks_.end());
+    callbacks_.erase(callbacks_.find(event));
+  }
+
+  void RemoveAllListeners() {
+    DCHECK_CURRENTLY_ON(::content::BrowserThread::UI);
+    EventSubscriberBase::RemoveAllListeners();
+    callbacks_.clear();
+  }
+
+ private:
+  void EventEmitted(const std::string& event_name,
+                    mate::Arguments* args) override {
+    DCHECK_CURRENTLY_ON(::content::BrowserThread::UI);
+    base::AutoLock auto_lock(handler_lock_);
+    if (!handler_) {
+      // handler_ was probably destroyed by another thread and we should not
+      // access it.
+      return;
+    }
+    auto it = callbacks_.find(event_name);
+    if (it != callbacks_.end()) {
+      auto method = it->second;
+      (handler_->*method)(args);
+    }
+  }
+
+  HandlerType* handler_;
+  base::Lock handler_lock_;
+  std::map<std::string, EventCallback> callbacks_;
+};
+
+}  // namespace mate
+
+#endif  // ATOM_BROWSER_API_EVENT_SUBSCRIBER_H_
\ No newline at end of file
diff --git a/atom/browser/common_web_contents_delegate.cc b/atom/browser/common_web_contents_delegate.cc
index 4eeb009f9..fbcb6b927 100644
--- a/atom/browser/common_web_contents_delegate.cc
+++ b/atom/browser/common_web_contents_delegate.cc
@@ -272,7 +272,7 @@ content::WebContents* CommonWebContentsDelegate::OpenURLFromTab(
   load_url_params.should_replace_current_entry =
       params.should_replace_current_entry;
   load_url_params.is_renderer_initiated = params.is_renderer_initiated;
-  load_url_params.should_clear_history_list = true;
+  load_url_params.should_clear_history_list = false;
 
   source->GetController().LoadURLWithParams(load_url_params);
   return source;
diff --git a/atom/browser/native_window.h b/atom/browser/native_window.h
index 4590395bd..92188717c 100644
--- a/atom/browser/native_window.h
+++ b/atom/browser/native_window.h
@@ -150,6 +150,9 @@ class NativeWindow : public base::SupportsUserData,
   virtual void SetMenu(AtomMenuModel* menu);
   virtual void SetParentWindow(NativeWindow* parent);
   virtual void SetBrowserView(NativeBrowserView* browser_view) = 0;
+  virtual void InsertBrowserView(NativeBrowserView* browser_view, int position) = 0;
+  virtual void EraseBrowserView(int position) = 0;
+  virtual void ReorderBrowserView(int position, int index) = 0;
   virtual gfx::NativeView GetNativeView() const = 0;
   virtual gfx::NativeWindow GetNativeWindow() const = 0;
   virtual gfx::AcceleratedWidget GetAcceleratedWidget() const = 0;
@@ -281,6 +284,8 @@ class NativeWindow : public base::SupportsUserData,
   bool enable_larger_than_screen() const { return enable_larger_than_screen_; }
 
   NativeBrowserView* browser_view() const { return browser_view_; }
+  std::map<int, NativeBrowserView*> additional_browser_views() const { return additional_browser_views_; }
+  
   NativeWindow* parent() const { return parent_; }
   bool is_modal() const { return is_modal_; }
 
@@ -295,6 +300,12 @@ class NativeWindow : public base::SupportsUserData,
   void set_browser_view(NativeBrowserView* browser_view) {
     browser_view_ = browser_view;
   }
+  void insert_browser_view(NativeBrowserView* browser_view, int position) {
+    additional_browser_views_.insert(std::make_pair(position, browser_view));
+  }
+  void erase_browser_view(int position) {
+    additional_browser_views_.erase(position);
+  }
 
  private:
   std::unique_ptr<views::Widget> widget_;
@@ -335,6 +346,7 @@ class NativeWindow : public base::SupportsUserData,
 
   // The browser view layer.
   NativeBrowserView* browser_view_ = nullptr;
+  std::map<int, NativeBrowserView*> additional_browser_views_;
 
   // Observers of this window.
   base::ObserverList<NativeWindowObserver> observers_;
diff --git a/atom/browser/native_window_views.cc b/atom/browser/native_window_views.cc
index c45dbb26c..4ba61fa88 100644
--- a/atom/browser/native_window_views.cc
+++ b/atom/browser/native_window_views.cc
@@ -306,6 +306,13 @@ void NativeWindowViews::SetContentView(views::View* view) {
           browser_view()->GetInspectableWebContentsView()->GetView());
       set_browser_view(nullptr);
     }
+    if(!additional_browser_views().empty()){
+      for (auto & item : additional_browser_views()) {
+        content_view()->RemoveChildView(
+          item.second->GetInspectableWebContentsView()->GetView());
+        erase_browser_view(item.first);
+      }
+    }
   }
   set_content_view(view);
   focused_view_ = view;
@@ -967,6 +974,39 @@ void NativeWindowViews::SetBrowserView(NativeBrowserView* view) {
       view->GetInspectableWebContentsView()->GetView());
 }
 
+void NativeWindowViews::InsertBrowserView(NativeBrowserView* view, int position) {
+  if (!content_view())
+    return;
+
+  if (!view) {
+    return;
+  }
+
+  // Add as child of the main web view to avoid (0, 0) origin from overlapping
+  // with menu bar.
+  insert_browser_view(view, position);
+  content_view()->AddChildView(
+      view->GetInspectableWebContentsView()->GetView());
+}
+
+
+void NativeWindowViews::EraseBrowserView(int position) {
+  if (!content_view())
+    return;
+
+  content_view()->RemoveChildView(
+      additional_browser_views()[position]->GetInspectableWebContentsView()->GetView());
+  erase_browser_view(position);
+}
+
+void NativeWindowViews::ReorderBrowserView(int position, int index) {
+  if (!content_view())
+    return;
+
+  content_view()->ReorderChildView(
+      additional_browser_views()[position]->GetInspectableWebContentsView()->GetView(), index);
+}
+
 void NativeWindowViews::SetParentWindow(NativeWindow* parent) {
   NativeWindow::SetParentWindow(parent);
 
@@ -1183,6 +1223,27 @@ void NativeWindowViews::OnWidgetBoundsChanged(views::Widget* changed_widget,
       view->SetSize(new_view_size);
     }
 
+    if(!additional_browser_views().empty()){
+      for (auto & item : additional_browser_views()) {
+      const auto flags = static_cast<NativeBrowserViewViews*>(item.second)
+                             ->GetAutoResizeFlags();
+      int width_delta = 0;
+      int height_delta = 0;
+      if (flags & kAutoResizeWidth) {
+        width_delta = new_bounds.width() - widget_size_.width();
+      }
+      if (flags & kAutoResizeHeight) {
+        height_delta = new_bounds.height() - widget_size_.height();
+      }
+
+      auto* view = item.second->GetInspectableWebContentsView()->GetView();
+      auto new_view_size = view->size();
+      new_view_size.set_width(new_view_size.width() + width_delta);
+      new_view_size.set_height(new_view_size.height() + height_delta);
+      view->SetSize(new_view_size);
+      }
+    }
+
     NotifyWindowResize();
     widget_size_ = new_bounds.size();
   }
diff --git a/atom/browser/native_window_views.h b/atom/browser/native_window_views.h
index 57c9efc86..3f51f58e9 100644
--- a/atom/browser/native_window_views.h
+++ b/atom/browser/native_window_views.h
@@ -112,6 +112,9 @@ class NativeWindowViews : public NativeWindow,
   void SetFocusable(bool focusable) override;
   void SetMenu(AtomMenuModel* menu_model) override;
   void SetBrowserView(NativeBrowserView* browser_view) override;
+  void InsertBrowserView(NativeBrowserView* browser_view, int position) override;
+  void EraseBrowserView(int position) override;
+  void ReorderBrowserView(int position, int index) override;
   void SetParentWindow(NativeWindow* parent) override;
   gfx::NativeView GetNativeView() const override;
   gfx::NativeWindow GetNativeWindow() const override;
diff --git a/atom/browser/net/js_asker2.cc b/atom/browser/net/js_asker2.cc
new file mode 100644
index 000000000..d6e758c09
--- /dev/null
+++ b/atom/browser/net/js_asker2.cc
@@ -0,0 +1,76 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "atom/browser/net/js_asker2.h"
+
+#include <memory>
+#include <utility>
+#include <vector>
+
+#include "atom/common/native_mate_converters/callback.h"
+#include "atom/common/native_mate_converters/v8_value_converter.h"
+
+
+namespace atom {
+
+namespace internal {
+
+namespace {
+
+// The callback which is passed to |handler|.
+void HandlerCallback(const BeforeStartCallback& before_start,
+                     const ResponseCallback& callback,
+                     mate::Arguments* args) {
+  // If there is no argument passed then we failed.
+  v8::Local<v8::Value> value;
+  if (!args->GetNext(&value)) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+                                     base::BindOnce(callback, false, nullptr));
+    return;
+  }
+
+  // Give the job a chance to parse V8 value.
+  before_start.Run(args->isolate(), value);
+
+  // Pass whatever user passed to the actaul request job.
+  V8ValueConverter converter;
+  v8::Local<v8::Context> context = args->isolate()->GetCurrentContext();
+  std::unique_ptr<base::Value> options(converter.FromV8Value(value, context));
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::BindOnce(callback, true, std::move(options)));
+}
+
+}  // namespace
+
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   std::unique_ptr<base::DictionaryValue> request_details,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  v8::Locker locker(isolate);
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Context::Scope context_scope(context);
+  handler.Run(*(request_details.get()),
+              mate::ConvertToV8(isolate, base::Bind(&HandlerCallback,
+                                                    before_start, callback)));
+}
+
+bool IsErrorOptions(base::Value* value, int* error) {
+  if (value->is_dict()) {
+    base::DictionaryValue* dict = static_cast<base::DictionaryValue*>(value);
+    if (dict->GetInteger("error", error))
+      return true;
+  } else if (value->is_int()) {
+    *error = value->GetInt();
+    return true;
+  }
+  return false;
+}
+
+}  // namespace internal
+
+}  // namespace atom
\ No newline at end of file
diff --git a/atom/browser/net/js_asker2.h b/atom/browser/net/js_asker2.h
new file mode 100644
index 000000000..5cdf5a357
--- /dev/null
+++ b/atom/browser/net/js_asker2.h
@@ -0,0 +1,130 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ATOM_BROWSER_NET_JS_ASKER2_H_
+#define ATOM_BROWSER_NET_JS_ASKER2_H_
+
+
+#include <memory>
+#include <utility>
+
+#include "atom/common/native_mate_converters/net_converter.h"
+#include "base/callback.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/values.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_status_code.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "net/url_request/url_request_job.h"
+#include "v8/include/v8.h"
+
+
+namespace atom {
+
+using JavaScriptHandler =
+    base::Callback<void(const base::DictionaryValue&, v8::Local<v8::Value>)>;
+
+namespace internal {
+
+using BeforeStartCallback =
+    base::Callback<void(v8::Isolate*, v8::Local<v8::Value>)>;
+using ResponseCallback =
+    base::Callback<void(bool, std::unique_ptr<base::Value> options)>;
+
+// Ask handler for options in UI thread.
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   std::unique_ptr<base::DictionaryValue> request_details,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback);
+
+// Test whether the |options| means an error.
+bool IsErrorOptions(base::Value* value, int* error);
+
+}  // namespace internal
+
+template <typename RequestJob>
+class JsAsker2 : public RequestJob {
+ public:
+  JsAsker2(net::URLRequest* request, net::NetworkDelegate* network_delegate)
+      : RequestJob(request, network_delegate), weak_factory_(this) {}
+
+  // Called by |CustomProtocolHandler| to store handler related information.
+  void SetHandlerInfo(v8::Isolate* isolate,
+                      net::URLRequestContextGetter* request_context_getter,
+                      const JavaScriptHandler& handler) {
+    isolate_ = isolate;
+    request_context_getter_ = request_context_getter;
+    handler_ = handler;
+  }
+
+  // Subclass should do initailze work here.
+  virtual void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) {}
+  virtual void StartAsync(std::unique_ptr<base::Value> options) = 0;
+
+  net::URLRequestContextGetter* request_context_getter() const {
+    return request_context_getter_;
+  }
+
+ private:
+  // RequestJob:
+  void Start() override {
+    auto request_details = std::make_unique<base::DictionaryValue>();
+    request_start_time_ = base::TimeTicks::Now();
+    FillRequestDetails(request_details.get(), RequestJob::request());
+    content::BrowserThread::PostTask(
+        content::BrowserThread::UI, FROM_HERE,
+        base::BindOnce(
+            &internal::AskForOptions, isolate_, handler_,
+            std::move(request_details),
+            base::Bind(&JsAsker2::BeforeStartInUI, weak_factory_.GetWeakPtr()),
+            base::Bind(&JsAsker2::OnResponse, weak_factory_.GetWeakPtr())));
+  }
+
+  int GetResponseCode() const override { return net::HTTP_OK; }
+
+  // NOTE: We have to implement this method or risk a crash in blink for
+  // redirects!
+  void GetLoadTimingInfo(net::LoadTimingInfo* load_timing_info) const override {
+    load_timing_info->send_start = request_start_time_;
+    load_timing_info->send_end = request_start_time_;
+    load_timing_info->request_start = request_start_time_;
+    load_timing_info->receive_headers_end = response_start_time_;
+  }
+
+  void GetResponseInfo(net::HttpResponseInfo* info) override {
+    info->headers = new net::HttpResponseHeaders("");
+  }
+
+  // Called when the JS handler has sent the response, we need to decide whether
+  // to start, or fail the job.
+  void OnResponse(bool success, std::unique_ptr<base::Value> value) {
+    response_start_time_ = base::TimeTicks::Now();
+    int error = net::ERR_NOT_IMPLEMENTED;
+    if (success && value && !internal::IsErrorOptions(value.get(), &error)) {
+      StartAsync(std::move(value));
+    } else {
+      RequestJob::NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
+    }
+  }
+
+  v8::Isolate* isolate_;
+  net::URLRequestContextGetter* request_context_getter_;
+  JavaScriptHandler handler_;
+  base::TimeTicks request_start_time_;
+  base::TimeTicks response_start_time_;
+
+  base::WeakPtrFactory<JsAsker2> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(JsAsker2);
+};
+
+}  // namespace atom
+
+
+#endif  // ATOM_BROWSER_NET_JS_ASKER2_H_
diff --git a/atom/browser/net/url_request_stream_job.cc b/atom/browser/net/url_request_stream_job.cc
index aac305229..9fabc9f0a 100644
--- a/atom/browser/net/url_request_stream_job.cc
+++ b/atom/browser/net/url_request_stream_job.cc
@@ -17,28 +17,27 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
 #include "base/time/time.h"
-#include "native_mate/dictionary.h"
-#include "net/base/net_errors.h"
 #include "net/filter/gzip_source_stream.h"
 
 namespace atom {
 
-namespace {
+URLRequestStreamJob::URLRequestStreamJob(net::URLRequest* request,
+                                         net::NetworkDelegate* network_delegate)
+    : JsAsker2<net::URLRequestJob>(request, network_delegate),
+      weak_factory_(this) {}
+
+URLRequestStreamJob::~URLRequestStreamJob() = default;
 
-void BeforeStartInUI(base::WeakPtr<URLRequestStreamJob> job,
-                     mate::Arguments* args) {
-  v8::Local<v8::Value> value;
-  int error = net::OK;
-  bool ended = false;
-  if (!args->GetNext(&value) || !value->IsObject()) {
+void URLRequestStreamJob::BeforeStartInUI(v8::Isolate* isolate,
+                                          v8::Local<v8::Value> value) {
+  if (value->IsNull() || value->IsUndefined() || !value->IsObject()) {
     // Invalid opts.
-    content::BrowserThread::PostTask(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&URLRequestStreamJob::OnError, job, net::ERR_FAILED));
+    ended_ = true;
+    errored_ = true;
     return;
   }
 
-  mate::Dictionary opts(args->isolate(), v8::Local<v8::Object>::Cast(value));
+  mate::Dictionary opts(isolate, v8::Local<v8::Object>::Cast(value));
   int status_code;
   if (!opts.Get("statusCode", &status_code)) {
     // assume HTTP OK if statusCode is not passed.
@@ -50,12 +49,11 @@ void BeforeStartInUI(base::WeakPtr<URLRequestStreamJob> job,
   status.append(
       net::GetHttpReasonPhrase(static_cast<net::HttpStatusCode>(status_code)));
   status.append("\0\0", 2);
-  scoped_refptr<net::HttpResponseHeaders> response_headers(
-      new net::HttpResponseHeaders(status));
+  response_headers_ = new net::HttpResponseHeaders(status);
 
   if (opts.Get("headers", &value)) {
-    mate::Converter<net::HttpResponseHeaders*>::FromV8(args->isolate(), value,
-                                                       response_headers.get());
+    mate::Converter<net::HttpResponseHeaders*>::FromV8(isolate, value,
+                                                       response_headers_.get());
   }
 
   if (!opts.Get("data", &value)) {
@@ -64,142 +62,116 @@ void BeforeStartInUI(base::WeakPtr<URLRequestStreamJob> job,
   } else if (value->IsNullOrUndefined()) {
     // "data" was explicitly passed as null or undefined, assume the user wants
     // to send an empty body.
-    ended = true;
-    content::BrowserThread::PostTask(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&URLRequestStreamJob::StartAsync, job, nullptr,
-                       base::RetainedRef(response_headers), ended, error));
+    ended_ = true;
     return;
   }
 
-  mate::Dictionary data(args->isolate(), v8::Local<v8::Object>::Cast(value));
+  mate::Dictionary data(isolate, v8::Local<v8::Object>::Cast(value));
   if (!data.Get("on", &value) || !value->IsFunction() ||
       !data.Get("removeListener", &value) || !value->IsFunction()) {
     // If data is passed but it is not a stream, signal an error.
-    content::BrowserThread::PostTask(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&URLRequestStreamJob::OnError, job, net::ERR_FAILED));
+    ended_ = true;
+    errored_ = true;
     return;
   }
 
-  auto subscriber = std::make_unique<mate::StreamSubscriber>(
-      args->isolate(), data.GetHandle(), job);
-
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&URLRequestStreamJob::StartAsync, job,
-                     std::move(subscriber), base::RetainedRef(response_headers),
-                     ended, error));
+  subscriber_.reset(new mate::EventSubscriber<URLRequestStreamJob>(
+      this, isolate, data.GetHandle()));
+  subscriber_->On("data", &URLRequestStreamJob::OnData);
+  subscriber_->On("end", &URLRequestStreamJob::OnEnd);
+  subscriber_->On("error", &URLRequestStreamJob::OnError);
 }
 
-}  // namespace
-
-URLRequestStreamJob::URLRequestStreamJob(net::URLRequest* request,
-                                         net::NetworkDelegate* network_delegate)
-    : net::URLRequestJob(request, network_delegate),
-      pending_buf_(nullptr),
-      pending_buf_size_(0),
-      ended_(false),
-      response_headers_(nullptr),
-      weak_factory_(this) {}
-
-URLRequestStreamJob::~URLRequestStreamJob() {
-  if (subscriber_) {
-    content::BrowserThread::DeleteSoon(content::BrowserThread::UI, FROM_HERE,
-                                       std::move(subscriber_));
-  }
-}
-
-void URLRequestStreamJob::Start() {
-  auto request_details = std::make_unique<base::DictionaryValue>();
-  FillRequestDetails(request_details.get(), request());
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI, FROM_HERE,
-      base::BindOnce(&JsAsker::AskForOptions, base::Unretained(isolate()),
-                     handler(), std::move(request_details),
-                     base::Bind(&BeforeStartInUI, weak_factory_.GetWeakPtr())));
-}
-
-void URLRequestStreamJob::StartAsync(
-    std::unique_ptr<mate::StreamSubscriber> subscriber,
-    scoped_refptr<net::HttpResponseHeaders> response_headers,
-    bool ended,
-    int error) {
-  if (error != net::OK) {
-    NotifyStartError(
-        net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
-    return;
-  }
-
-  ended_ = ended;
-  response_headers_ = response_headers;
-  subscriber_ = std::move(subscriber);
-  request_start_time_ = base::TimeTicks::Now();
+void URLRequestStreamJob::StartAsync(std::unique_ptr<base::Value> options) {
   NotifyHeadersComplete();
 }
 
-void URLRequestStreamJob::OnData(std::vector<char>&& buffer) {  // NOLINT
-  if (write_buffer_.empty()) {
-    // Quick branch without copying.
-    write_buffer_ = std::move(buffer);
+void URLRequestStreamJob::OnData(mate::Arguments* args) {
+  v8::Local<v8::Value> node_data;
+  args->GetNext(&node_data);
+  if (node_data->IsUint8Array()) {
+    const char* data = node::Buffer::Data(node_data);
+    size_t data_size = node::Buffer::Length(node_data);
+    std::copy(data, data + data_size, std::back_inserter(buffer_));
   } else {
-    // write_buffer_ += buffer
-    size_t len = write_buffer_.size();
-    write_buffer_.resize(len + buffer.size());
-    std::copy(buffer.begin(), buffer.end(), write_buffer_.begin() + len);
+    NOTREACHED();
   }
-
-  // Copy to output.
-  if (pending_buf_) {
-    int len = BufferCopy(&write_buffer_, pending_buf_.get(), pending_buf_size_);
-    write_buffer_.erase(write_buffer_.begin(), write_buffer_.begin() + len);
-    pending_buf_ = nullptr;
-    pending_buf_size_ = 0;
-    ReadRawDataComplete(len);
+  if (pending_io_buf_) {
+    CopyMoreData(pending_io_buf_, pending_io_buf_size_);
   }
 }
 
-void URLRequestStreamJob::OnEnd() {
+void URLRequestStreamJob::OnEnd(mate::Arguments* args) {
   ended_ = true;
-  if (pending_buf_) {
-    ReadRawDataComplete(0);
+  if (pending_io_buf_) {
+    CopyMoreData(pending_io_buf_, pending_io_buf_size_);
   }
 }
 
-void URLRequestStreamJob::OnError(int error) {
-  NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
+void URLRequestStreamJob::OnError(mate::Arguments* args) {
+  errored_ = true;
+  if (pending_io_buf_) {
+    CopyMoreData(pending_io_buf_, pending_io_buf_size_);
+  }
 }
 
 int URLRequestStreamJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
-  response_start_time_ = base::TimeTicks::Now();
-
-  if (ended_)
-    return 0;
-
-  // When write_buffer_ is empty, there is no data valable yet, we have to save
-  // the dest buffer util DataAvailable.
-  if (write_buffer_.empty()) {
-    pending_buf_ = dest;
-    pending_buf_size_ = dest_size;
-    return net::ERR_IO_PENDING;
-  }
-
-  // Read from the write buffer and clear them after reading.
-  int len = BufferCopy(&write_buffer_, dest, dest_size);
-  write_buffer_.erase(write_buffer_.begin(), write_buffer_.begin() + len);
-  return len;
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI, FROM_HERE,
+      base::BindOnce(&URLRequestStreamJob::CopyMoreData,
+                     weak_factory_.GetWeakPtr(), WrapRefCounted(dest),
+                     dest_size));
+  return net::ERR_IO_PENDING;
 }
 
 void URLRequestStreamJob::DoneReading() {
-  content::BrowserThread::DeleteSoon(content::BrowserThread::UI, FROM_HERE,
-                                     std::move(subscriber_));
-  write_buffer_.clear();
+  subscriber_.reset();
+  buffer_.clear();
+  ended_ = true;
 }
 
 void URLRequestStreamJob::DoneReadingRedirectResponse() {
   DoneReading();
 }
 
+void URLRequestStreamJob::CopyMoreDataDone(scoped_refptr<net::IOBuffer> io_buf,
+                                           int status) {
+  if (status <= 0) {
+    subscriber_.reset();
+  }
+  ReadRawDataComplete(status);
+  io_buf = nullptr;
+}
+
+void URLRequestStreamJob::CopyMoreData(scoped_refptr<net::IOBuffer> io_buf,
+                                       int io_buf_size) {
+  // reset any instance references to io_buf
+  pending_io_buf_ = nullptr;
+  pending_io_buf_size_ = 0;
+
+  int read_count = 0;
+  if (buffer_.size()) {
+    size_t count = std::min((size_t)io_buf_size, buffer_.size());
+    std::copy(buffer_.begin(), buffer_.begin() + count, io_buf->data());
+    buffer_.erase(buffer_.begin(), buffer_.begin() + count);
+    read_count = count;
+  } else if (!ended_ && !errored_) {
+    // No data available yet, save references to the IOBuffer, which will be
+    // passed back to this function when OnData/OnEnd/OnError are called
+    pending_io_buf_ = io_buf;
+    pending_io_buf_size_ = io_buf_size;
+  }
+
+  if (!pending_io_buf_) {
+    // Only call CopyMoreDataDone if we have read something.
+    int status = (errored_ && !read_count) ? net::ERR_FAILED : read_count;
+    content::BrowserThread::PostTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::BindOnce(&URLRequestStreamJob::CopyMoreDataDone,
+                       weak_factory_.GetWeakPtr(), io_buf, status));
+  }
+}
+
 std::unique_ptr<net::SourceStream> URLRequestStreamJob::SetUpSourceStream() {
   std::unique_ptr<net::SourceStream> source =
       net::URLRequestJob::SetUpSourceStream();
@@ -230,25 +202,4 @@ void URLRequestStreamJob::GetResponseInfo(net::HttpResponseInfo* info) {
   info->headers = response_headers_;
 }
 
-void URLRequestStreamJob::GetLoadTimingInfo(
-    net::LoadTimingInfo* load_timing_info) const {
-  load_timing_info->send_start = request_start_time_;
-  load_timing_info->send_end = request_start_time_;
-  load_timing_info->request_start = request_start_time_;
-  load_timing_info->receive_headers_end = response_start_time_;
-}
-
-void URLRequestStreamJob::Kill() {
-  weak_factory_.InvalidateWeakPtrs();
-  net::URLRequestJob::Kill();
-}
-
-int URLRequestStreamJob::BufferCopy(std::vector<char>* source,
-                                    net::IOBuffer* target,
-                                    int target_size) {
-  int bytes_written = std::min(static_cast<int>(source->size()), target_size);
-  memcpy(target->data(), source->data(), bytes_written);
-  return bytes_written;
-}
-
-}  // namespace atom
+}  // namespace atom
\ No newline at end of file
diff --git a/atom/browser/net/url_request_stream_job.h b/atom/browser/net/url_request_stream_job.h
index e56e9f169..4c2b3cc35 100644
--- a/atom/browser/net/url_request_stream_job.h
+++ b/atom/browser/net/url_request_stream_job.h
@@ -5,69 +5,64 @@
 #ifndef ATOM_BROWSER_NET_URL_REQUEST_STREAM_JOB_H_
 #define ATOM_BROWSER_NET_URL_REQUEST_STREAM_JOB_H_
 
+#include <deque>
 #include <memory>
 #include <string>
-#include <vector>
 
-#include "atom/browser/api/stream_subscriber.h"
-#include "atom/browser/net/js_asker.h"
-#include "base/memory/scoped_refptr.h"
+#include "atom/browser/api/event_subscriber.h"
+#include "atom/browser/net/js_asker2.h"
+#include "base/memory/ref_counted_memory.h"
+#include "native_mate/persistent_dictionary.h"
 #include "net/base/io_buffer.h"
 #include "net/http/http_status_code.h"
-#include "net/url_request/url_request_job.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "v8/include/v8.h"
 
 namespace atom {
 
-class URLRequestStreamJob : public JsAsker, public net::URLRequestJob {
+class URLRequestStreamJob : public JsAsker2<net::URLRequestJob> {
  public:
   URLRequestStreamJob(net::URLRequest* request,
                       net::NetworkDelegate* network_delegate);
   ~URLRequestStreamJob() override;
 
-  void StartAsync(std::unique_ptr<mate::StreamSubscriber> subscriber,
-                  scoped_refptr<net::HttpResponseHeaders> response_headers,
-                  bool ended,
-                  int error);
+  void OnData(mate::Arguments* args);
+  void OnEnd(mate::Arguments* args);
+  void OnError(mate::Arguments* args);
 
-  void OnData(std::vector<char>&& buffer);  // NOLINT
-  void OnEnd();
-  void OnError(int error);
+  // URLRequestJob
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
 
  protected:
   // URLRequestJob
-  void Start() override;
   int ReadRawData(net::IOBuffer* buf, int buf_size) override;
   void DoneReading() override;
   void DoneReadingRedirectResponse() override;
   std::unique_ptr<net::SourceStream> SetUpSourceStream() override;
   bool GetMimeType(std::string* mime_type) const override;
   int GetResponseCode() const override;
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-  void GetLoadTimingInfo(net::LoadTimingInfo* load_timing_info) const override;
-  void Kill() override;
 
  private:
-  int BufferCopy(std::vector<char>* source,
-                 net::IOBuffer* target,
-                 int target_size);
+  // JsAsker2
+  void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) override;
+  void StartAsync(std::unique_ptr<base::Value> options) override;
+  void OnResponse(bool success, std::unique_ptr<base::Value> value);
 
-  // Saved arguments passed to ReadRawData.
-  scoped_refptr<net::IOBuffer> pending_buf_;
-  int pending_buf_size_;
+  // Callback after data is asynchronously read from the file into |buf|.
+  void CopyMoreData(scoped_refptr<net::IOBuffer> io_buf, int io_buf_size);
+  void CopyMoreDataDone(scoped_refptr<net::IOBuffer> io_buf, int read_count);
 
-  // Saved arguments passed to OnData.
-  std::vector<char> write_buffer_;
-
-  bool ended_;
-  base::TimeTicks request_start_time_;
-  base::TimeTicks response_start_time_;
+  std::deque<char> buffer_;
+  bool ended_ = false;
+  bool errored_ = false;
+  scoped_refptr<net::IOBuffer> pending_io_buf_;
+  int pending_io_buf_size_ = 0;
   scoped_refptr<net::HttpResponseHeaders> response_headers_;
-  std::unique_ptr<mate::StreamSubscriber> subscriber_;
-
+  mate::EventSubscriber<URLRequestStreamJob>::SafePtr subscriber_;
   base::WeakPtrFactory<URLRequestStreamJob> weak_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestStreamJob);
 };
 }  // namespace atom
 
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_STREAM_JOB_H_
+#endif  // ATOM_BROWSER_NET_URL_REQUEST_STREAM_JOB_H_
\ No newline at end of file
diff --git a/atom/common/native_mate_converters/callback.cc b/atom/common/native_mate_converters/callback.cc
index 27d43a0ad..250bd26a3 100644
--- a/atom/common/native_mate_converters/callback.cc
+++ b/atom/common/native_mate_converters/callback.cc
@@ -4,8 +4,6 @@
 
 #include "atom/common/native_mate_converters/callback.h"
 
-#include "native_mate/dictionary.h"
-
 using content::BrowserThread;
 
 namespace mate {
@@ -15,22 +13,6 @@ namespace internal {
 namespace {
 
 struct TranslaterHolder {
-  explicit TranslaterHolder(v8::Isolate* isolate)
-      : handle(isolate, v8::External::New(isolate, this)) {
-    handle.SetWeak(this, &GC, v8::WeakCallbackType::kFinalizer);
-  }
-  ~TranslaterHolder() {
-    if (!handle.IsEmpty()) {
-      handle.ClearWeak();
-      handle.Reset();
-    }
-  }
-
-  static void GC(const v8::WeakCallbackInfo<TranslaterHolder>& data) {
-    delete data.GetParameter();
-  }
-
-  v8::Global<v8::External> handle;
   Translater translater;
 };
 
@@ -40,27 +22,20 @@ v8::Persistent<v8::FunctionTemplate> g_call_translater;
 void CallTranslater(v8::Local<v8::External> external,
                     v8::Local<v8::Object> state,
                     mate::Arguments* args) {
-  // Whether the callback should only be called for once.
   v8::Isolate* isolate = args->isolate();
-  bool one_time = state->Has(mate::StringToSymbol(isolate, "oneTime"));
 
   // Check if the callback has already been called.
-  if (one_time) {
-    auto called_symbol = mate::StringToSymbol(isolate, "called");
-    if (state->Has(called_symbol)) {
-      args->ThrowError("callback can only be called for once");
-      return;
-    } else {
-      state->Set(called_symbol, v8::Boolean::New(isolate, true));
-    }
+  v8::Local<v8::String> called_symbol = mate::StringToSymbol(isolate, "called");
+  if (state->Has(called_symbol)) {
+    args->ThrowError("callback can only be called for once");
+    return;
+  } else {
+    state->Set(called_symbol, v8::Boolean::New(isolate, true));
   }
 
   TranslaterHolder* holder = static_cast<TranslaterHolder*>(external->Value());
   holder->translater.Run(args);
-
-  // Free immediately for one-time callback.
-  if (one_time)
-    delete holder;
+  delete holder;
 }
 
 }  // namespace
@@ -114,9 +89,9 @@ v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
   return v8_function_->NewHandle(isolate);
 }
 
-v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
-                                                  const Translater& translater,
-                                                  bool one_time) {
+v8::Local<v8::Value> CreateFunctionFromTranslater(
+    v8::Isolate* isolate,
+    const Translater& translater) {
   // The FunctionTemplate is cached.
   if (g_call_translater.IsEmpty())
     g_call_translater.Reset(isolate, mate::CreateFunctionTemplate(
@@ -124,14 +99,11 @@ v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
 
   v8::Local<v8::FunctionTemplate> call_translater =
       v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
-  auto* holder = new TranslaterHolder(isolate);
+  auto* holder = new TranslaterHolder;
   holder->translater = translater;
-  Dictionary state = mate::Dictionary::CreateEmpty(isolate);
-  if (one_time)
-    state.Set("oneTime", true);
-  return BindFunctionWith(isolate, isolate->GetCurrentContext(),
-                          call_translater->GetFunction(),
-                          holder->handle.Get(isolate), state.GetHandle());
+  return BindFunctionWith(
+      isolate, isolate->GetCurrentContext(), call_translater->GetFunction(),
+      v8::External::New(isolate, holder), v8::Object::New(isolate));
 }
 
 // func.bind(func, arg1).
@@ -152,4 +124,4 @@ v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
 
 }  // namespace internal
 
-}  // namespace mate
+}  // namespace mate
\ No newline at end of file
diff --git a/atom/common/native_mate_converters/callback.h b/atom/common/native_mate_converters/callback.h
index 5ec1c317a..4e47aa04d 100644
--- a/atom/common/native_mate_converters/callback.h
+++ b/atom/common/native_mate_converters/callback.h
@@ -109,8 +109,7 @@ struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
 // Helper to pass a C++ funtion to JavaScript.
 using Translater = base::Callback<void(Arguments* args)>;
 v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
-                                                  const Translater& translater,
-                                                  bool one_time);
+                                                  const Translater& translater);
 v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
                                       v8::Local<v8::Context> context,
                                       v8::Local<v8::Function> func,
@@ -154,10 +153,8 @@ struct Converter<base::RepeatingCallback<Sig>> {
     // We don't use CreateFunctionTemplate here because it creates a new
     // FunctionTemplate everytime, which is cached by V8 and causes leaks.
     internal::Translater translater =
-        base::Bind(&internal::NativeFunctionInvoker<Sig>::Go, val);
-    // To avoid memory leak, we ensure that the callback can only be called
-    // for once.
-    return internal::CreateFunctionFromTranslater(isolate, translater, true);
+        base::BindRepeating(&internal::NativeFunctionInvoker<Sig>::Go, val);
+    return internal::CreateFunctionFromTranslater(isolate, translater);
   }
   static bool FromV8(v8::Isolate* isolate,
                      v8::Local<v8::Value> val,
@@ -171,16 +168,6 @@ struct Converter<base::RepeatingCallback<Sig>> {
   }
 };
 
-// Convert a callback to V8 without the call number limitation, this can easily
-// cause memory leaks so use it with caution.
-template <typename Sig>
-v8::Local<v8::Value> CallbackToV8(v8::Isolate* isolate,
-                                  const base::Callback<Sig>& val) {
-  internal::Translater translater =
-      base::Bind(&internal::NativeFunctionInvoker<Sig>::Go, val);
-  return internal::CreateFunctionFromTranslater(isolate, translater, false);
-}
-
 }  // namespace mate
 
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
+#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
\ No newline at end of file
diff --git a/atom/renderer/atom_sandboxed_renderer_client.cc b/atom/renderer/atom_sandboxed_renderer_client.cc
index 940cc9b00..8fa04ecb0 100644
--- a/atom/renderer/atom_sandboxed_renderer_client.cc
+++ b/atom/renderer/atom_sandboxed_renderer_client.cc
@@ -33,15 +33,15 @@ namespace {
 const char kIpcKey[] = "ipcNative";
 const char kModuleCacheKey[] = "native-module-cache";
 
-bool IsDevTools(content::RenderFrame* render_frame) {
-  return render_frame->GetWebFrame()->GetDocument().Url().ProtocolIs(
-      "chrome-devtools");
-}
+// bool IsDevTools(content::RenderFrame* render_frame) {
+//   return render_frame->GetWebFrame()->GetDocument().Url().ProtocolIs(
+//       "chrome-devtools");
+// }
 
-bool IsDevToolsExtension(content::RenderFrame* render_frame) {
-  return render_frame->GetWebFrame()->GetDocument().Url().ProtocolIs(
-      "chrome-extension");
-}
+// bool IsDevToolsExtension(content::RenderFrame* render_frame) {
+//   return render_frame->GetWebFrame()->GetDocument().Url().ProtocolIs(
+//       "chrome-extension");
+// }
 
 v8::Local<v8::Object> GetModuleCache(v8::Isolate* isolate) {
   mate::Dictionary global(isolate, isolate->GetCurrentContext()->Global());
@@ -194,9 +194,9 @@ void AtomSandboxedRendererClient::DidCreateScriptContext(
 
   // Only allow preload for the main frame or
   // For devtools we still want to run the preload_bundle script
-  if (!render_frame->IsMainFrame() && !IsDevTools(render_frame) &&
-      !IsDevToolsExtension(render_frame))
-    return;
+  // if (!render_frame->IsMainFrame() && !IsDevTools(render_frame) &&
+  //     !IsDevToolsExtension(render_frame))
+  //   return;
 
   auto* isolate = context->GetIsolate();
   v8::HandleScope handle_scope(isolate);
@@ -225,9 +225,9 @@ void AtomSandboxedRendererClient::DidCreateScriptContext(
 void AtomSandboxedRendererClient::WillReleaseScriptContext(
     v8::Handle<v8::Context> context,
     content::RenderFrame* render_frame) {
-  // Only allow preload for the main frame
-  if (!render_frame->IsMainFrame())
-    return;
+  // // Only allow preload for the main frame
+  // if (!render_frame->IsMainFrame())
+  //   return;
 
   auto* isolate = context->GetIsolate();
   v8::HandleScope handle_scope(isolate);
diff --git a/filenames.gni b/filenames.gni
index 7f309a0e3..82a61bbe0 100644
--- a/filenames.gni
+++ b/filenames.gni
@@ -41,12 +41,35 @@ filenames = {
     "lib/browser/api/web-contents.js",
     "lib/browser/api/web-contents-view.js",
     "lib/browser/chrome-extension.js",
+    "lib/browser/chrome-extension-api.js",
     "lib/browser/guest-view-manager.js",
     "lib/browser/guest-window-manager.js",
     "lib/browser/init.js",
     "lib/browser/ipc-main-internal.js",
     "lib/browser/objects-registry.js",
     "lib/browser/rpc-server.js",
+    "lib/browser/extensions/alarms-main.js",
+    "lib/browser/extensions/lruCache.js",
+    "lib/browser/extensions/browser-action-main.js",
+    "lib/browser/extensions/browsing-data-main.js",
+    "lib/browser/extensions/commands-main.js",
+    "lib/browser/extensions/content-settings-main.js",
+    "lib/browser/extensions/context-menus-main.js",
+    "lib/browser/extensions/cookies-main.js",
+    "lib/browser/extensions/franc-min.js",
+    "lib/browser/extensions/hjson.js",
+    "lib/browser/extensions/i18n-main.js",
+    "lib/browser/extensions/idle-main.js",
+    "lib/browser/extensions/management-main.js",
+    "lib/browser/extensions/sessions-main.js",
+    "lib/browser/extensions/storage-main.js",
+    "lib/browser/extensions/tabs-main.js",
+    "lib/browser/extensions/util-main.js",
+    "lib/browser/extensions/web-navigation-main.js",
+    "lib/browser/extensions/web-request-main.js",
+    "lib/browser/extensions/window-util-main.js",
+    "lib/browser/extensions/windows-main.js",
+    "lib/browser/extensions/mime/index.js",
     "lib/common/api/clipboard.js",
     "lib/common/api/deprecate.js",
     "lib/common/api/deprecations.js",
@@ -84,10 +107,41 @@ filenames = {
     "lib/renderer/api/remote.js",
     "lib/renderer/api/screen.js",
     "lib/renderer/api/web-frame.js",
+    "lib/renderer/extensions/alarms.js",
+    "lib/renderer/extensions/app.js",
+    "lib/renderer/extensions/bookmarks.js",
+    "lib/renderer/extensions/browser-action.js",
+    "lib/renderer/extensions/browsing-data.js",
+    "lib/renderer/extensions/commands.js",
+    "lib/renderer/extensions/common-util.js",
+    "lib/renderer/extensions/content-settings.js",
+    "lib/renderer/extensions/context-menus.js",
+    "lib/renderer/extensions/cookies.js",
+    "lib/renderer/extensions/deep-equal.js",
+    "lib/renderer/extensions/downloads.js",
     "lib/renderer/extensions/event.js",
+    "lib/renderer/extensions/extension.js",
+    "lib/renderer/extensions/history.js",
     "lib/renderer/extensions/i18n.js",
+    "lib/renderer/extensions/idle.js",
+    "lib/renderer/extensions/management.js",
+    "lib/renderer/extensions/message-sender.js",
+    "lib/renderer/extensions/notifications.js",
+    "lib/renderer/extensions/permissions.js",
+    "lib/renderer/extensions/port.js",
+    "lib/renderer/extensions/privacy.js",
+    "lib/renderer/extensions/proxy.js",
+    "lib/renderer/extensions/runtime.js",
+    "lib/renderer/extensions/sessions.js",
     "lib/renderer/extensions/storage.js",
+    "lib/renderer/extensions/tab.js",
+    "lib/renderer/extensions/tabs.js",
+    "lib/renderer/extensions/top-sites.js",
+    "lib/renderer/extensions/util.js",
     "lib/renderer/extensions/web-navigation.js",
+    "lib/renderer/extensions/web-request.js",
+    "lib/renderer/extensions/window.js",
+    "lib/renderer/extensions/windows.js",
     "lib/worker/init.js",
   ]
 
@@ -194,8 +248,8 @@ filenames = {
     "atom/browser/api/event.h",
     "atom/browser/api/event_emitter.cc",
     "atom/browser/api/event_emitter.h",
-    "atom/browser/api/stream_subscriber.cc",
-    "atom/browser/api/stream_subscriber.h",
+    "atom/browser/api/event_subscriber.cc",
+    "atom/browser/api/event_subscriber.h",
     "atom/browser/api/trackable_object.cc",
     "atom/browser/api/trackable_object.h",
     "atom/browser/api/frame_subscriber.cc",
@@ -316,6 +370,8 @@ filenames = {
     "atom/browser/net/http_protocol_handler.h",
     "atom/browser/net/js_asker.cc",
     "atom/browser/net/js_asker.h",
+    "atom/browser/net/js_asker2.cc",
+    "atom/browser/net/js_asker2.h",
     "atom/browser/net/require_ct_delegate.cc",
     "atom/browser/net/require_ct_delegate.h",
     "atom/browser/net/resolve_proxy_helper.cc",
diff --git a/lib/browser/api/navigation-controller.js b/lib/browser/api/navigation-controller.js
old mode 100644
new mode 100755
index 1863961d0..c8b0d8f72
--- a/lib/browser/api/navigation-controller.js
+++ b/lib/browser/api/navigation-controller.js
@@ -22,33 +22,33 @@ const NavigationController = (function () {
     this.clearHistory()
 
     // webContents may have already navigated to a page.
-    if (this.webContents._getURL()) {
-      this.currentIndex++
-      this.history.push(this.webContents._getURL())
-    }
-    this.webContents.on('navigation-entry-commited', (event, url, inPage, replaceEntry) => {
-      if (this.inPageIndex > -1 && !inPage) {
-        // Navigated to a new page, clear in-page mark.
-        this.inPageIndex = -1
-      } else if (this.inPageIndex === -1 && inPage && !replaceEntry) {
-        // Started in-page navigations.
-        this.inPageIndex = this.currentIndex
-      }
-      if (this.pendingIndex >= 0) {
-        // Go to index.
-        this.currentIndex = this.pendingIndex
-        this.pendingIndex = -1
-        this.history[this.currentIndex] = url
-      } else if (replaceEntry) {
-        // Non-user initialized navigation.
-        this.history[this.currentIndex] = url
-      } else {
-        // Normal navigation. Clear history.
-        this.history = this.history.slice(0, this.currentIndex + 1)
-        this.currentIndex++
-        this.history.push(url)
-      }
-    })
+    // if (this.webContents._getURL()) {
+    //   this.currentIndex++
+    //   this.history.push(this.webContents._getURL())
+    // }
+    // this.webContents.on('navigation-entry-commited', (event, url, inPage, replaceEntry) => {
+    //   if (this.inPageIndex > -1 && !inPage) {
+    //     // Navigated to a new page, clear in-page mark.
+    //     this.inPageIndex = -1
+    //   } else if (this.inPageIndex === -1 && inPage && !replaceEntry) {
+    //     // Started in-page navigations.
+    //     this.inPageIndex = this.currentIndex
+    //   }
+    //   if (this.pendingIndex >= 0) {
+    //     // Go to index.
+    //     this.currentIndex = this.pendingIndex
+    //     this.pendingIndex = -1
+    //     this.history[this.currentIndex] = url
+    //   } else if (replaceEntry) {
+    //     // Non-user initialized navigation.
+    //     this.history[this.currentIndex] = url
+    //   } else {
+    //     // Normal navigation. Clear history.
+    //     this.history = this.history.slice(0, this.currentIndex + 1)
+    //     this.currentIndex++
+    //     this.history.push(url)
+    //   }
+    // })
   }
 
   NavigationController.prototype.loadURL = function (url, options) {
@@ -61,11 +61,7 @@ const NavigationController = (function () {
   }
 
   NavigationController.prototype.getURL = function () {
-    if (this.currentIndex === -1) {
-      return ''
-    } else {
-      return this.history[this.currentIndex]
-    }
+    return this.webContents._getURL()
   }
 
   NavigationController.prototype.stop = function () {
@@ -75,22 +71,20 @@ const NavigationController = (function () {
 
   NavigationController.prototype.reload = function () {
     this.pendingIndex = this.currentIndex
-    return this.webContents._loadURL(this.getURL(), {})
+    return this.webContents.reload()
   }
 
   NavigationController.prototype.reloadIgnoringCache = function () {
     this.pendingIndex = this.currentIndex
-    return this.webContents._loadURL(this.getURL(), {
-      extraHeaders: 'pragma: no-cache\n'
-    })
+    return this.webContents.reloadIgnoringCache()
   }
 
   NavigationController.prototype.canGoBack = function () {
-    return this.getActiveIndex() > 0
+    return this.webContents.canGoBack()
   }
 
   NavigationController.prototype.canGoForward = function () {
-    return this.getActiveIndex() < this.history.length - 1
+    return this.webContents.canGoForward()
   }
 
   NavigationController.prototype.canGoToIndex = function (index) {
@@ -98,7 +92,7 @@ const NavigationController = (function () {
   }
 
   NavigationController.prototype.canGoToOffset = function (offset) {
-    return this.canGoToIndex(this.currentIndex + offset)
+    return this.webContents.canGoToOffset()
   }
 
   NavigationController.prototype.clearHistory = function () {
@@ -113,11 +107,7 @@ const NavigationController = (function () {
       return
     }
     this.pendingIndex = this.getActiveIndex() - 1
-    if (this.inPageIndex > -1 && this.pendingIndex >= this.inPageIndex) {
-      return this.webContents._goBack()
-    } else {
-      return this.webContents._loadURL(this.history[this.pendingIndex], {})
-    }
+    return this.webContents._goBack()
   }
 
   NavigationController.prototype.goForward = function () {
@@ -125,11 +115,7 @@ const NavigationController = (function () {
       return
     }
     this.pendingIndex = this.getActiveIndex() + 1
-    if (this.inPageIndex > -1 && this.pendingIndex >= this.inPageIndex) {
-      return this.webContents._goForward()
-    } else {
-      return this.webContents._loadURL(this.history[this.pendingIndex], {})
-    }
+    return this.webContents._goForward()
   }
 
   NavigationController.prototype.goToIndex = function (index) {
@@ -144,25 +130,28 @@ const NavigationController = (function () {
     if (!this.canGoToOffset(offset)) {
       return
     }
-    const pendingIndex = this.currentIndex + offset
-    if (this.inPageIndex > -1 && pendingIndex >= this.inPageIndex) {
-      this.pendingIndex = pendingIndex
-      return this.webContents._goToOffset(offset)
-    } else {
-      return this.goToIndex(pendingIndex)
-    }
+
+    return this.webContents._goToOffset(offset)
+    // const pendingIndex = this.currentIndex + offset
+    // if (this.inPageIndex > -1 && pendingIndex >= this.inPageIndex) {
+    //   this.pendingIndex = pendingIndex
+    //   return this.webContents._goToOffset(offset)
+    // } else {
+    //   return this.webContents.goToIndex(pendingIndex)
+    // }
   }
 
   NavigationController.prototype.getActiveIndex = function () {
-    if (this.pendingIndex === -1) {
-      return this.currentIndex
+    const pendingIndex = this.webContents.getPendingEntryIndex()
+    if (pendingIndex === -1) {
+      return this.webContents.getCurrentEntryIndex()
     } else {
-      return this.pendingIndex
+      return pendingIndex
     }
   }
 
   NavigationController.prototype.length = function () {
-    return this.history.length
+    return this.webContents.getEntryCount()
   }
 
   return NavigationController
diff --git a/lib/browser/chrome-extension-api.js b/lib/browser/chrome-extension-api.js
new file mode 100755
index 000000000..c4fe6a2d6
--- /dev/null
+++ b/lib/browser/chrome-extension-api.js
@@ -0,0 +1,146 @@
+const {ipcMain, webContents, session, app} = require('electron')
+const {shortId} = require('./extensions/util-main')
+
+module.exports = function(manifestMap, backgroundPages, sendToBackgroundPage, sendToBackgroundPages){
+
+  ipcMain.on('update-tab',(e,tabId)=>{
+    sendToBackgroundPages('CHROME_TABS_ONUPDATED', tabId)
+  })
+
+// Dispatch web contents events to Chrome APIs
+  const hookWebContentsEvents = function (webContents) {
+    const tabId = webContents.id
+
+    if(webContents.hostWebContents) return
+
+    sendToBackgroundPages('CHROME_TABS_ONCREATED', tabId)
+
+    require('./extensions/web-navigation-main')(webContents, sendToBackgroundPage)
+
+    // webContents.on('did-fail-load', (e,errorCode,errorDescription,validatedURL,isMainFrame,frameProcessId,frameRoutingId)=>{
+    //   if(!isMainFrame)
+    //     sendToBackgroundPages('CHROME_TABS_ONUPDATED', tabId)
+    // })
+
+    for(let name of ['did-fail-load',
+      'did-finish-load',
+      'did-start-loading',
+      'did-stop-loading',
+      'did-start-navigation',
+      // 'did-navigate',
+      // 'did-navigate-in-page',
+      'page-title-updated',
+      'page-favicon-updated']){
+      webContents.on(name, (e,...args)=>{
+        sendToBackgroundPages('CHROME_TABS_ONUPDATED', tabId)
+      })
+    }
+
+    webContents.once('destroyed', () => {
+      sendToBackgroundPages('CHROME_TABS_ONREMOVED', tabId)
+    })
+  }
+
+// Handle the chrome.* API messages.
+  const nextId = {val: 0}
+
+  ipcMain.on('CHROME_RUNTIME_CONNECT', async function (event, extensionId, connectInfo, webContentsKey) {
+    const backgroundPage = backgroundPages[extensionId] && backgroundPages[extensionId].webContents
+    for(let page of new Set([backgroundPage,...webContents.getAllWebContents()])) {
+      if (!page || page.isDestroyed() || !page.getURL().startsWith(`chrome-extension://${extensionId}`)) {
+        continue
+      }
+
+      const portId = ++nextId.val
+      page.sendToAll(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, event.sender.id, portId, connectInfo, webContentsKey)
+      const success = await new Promise(r=>{
+        ipcMain.once(`CHROME_RUNTIME_ONCONNECT_RES_${extensionId}`, (e2, canConnect) => {
+          console.log(`CHROME_RUNTIME_ONCONNECT_RES_${extensionId}`)
+          if (canConnect) {
+            event.returnValue = {tabId: page.id, portId: portId}
+
+            event.sender.once('render-view-deleted', () => {
+              if (page.isDestroyed()) return
+              page.sendToAll(`CHROME_PORT_DISCONNECT_${portId}`)
+            })
+            r(true)
+          }
+          else {
+            r(false)
+          }
+        })
+      })
+      if(success) return
+    }
+    event.returnValue = null
+  })
+
+  ipcMain.on('CHROME_I18N_MANIFEST', function (event, extensionId) {
+    event.returnValue = manifestMap[extensionId]
+  })
+
+  const resultID = {val: 1}
+  ipcMain.on('CHROME_RUNTIME_SENDMESSAGE', function (event, extensionId, message, originResultID, webContentsKey) {
+    // console.log('CHROME_RUNTIME_SENDMESSAGE', event.sender.getURL(), extensionId, message, originResultID, Date.now())
+    const backgroundPage = backgroundPages[extensionId] && backgroundPages[extensionId].webContents
+    for(let page of new Set([backgroundPage,...webContents.getAllWebContents()])) {
+      if (!page || page.isDestroyed() || !page.getURL().startsWith(`chrome-extension://${extensionId}`)) {
+        continue
+      }
+      const val = resultID.val
+
+      console.log(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, val)
+      page.sendToAll(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, event.sender.id, message, val, webContentsKey)
+      const callback = (event2, result) => {
+        // console.log(`CHROME_RUNTIME_ONMESSAGE_RESULT_${val}`,event.sender.isDestroyed(),event.sender.getURL(), Date.now(),result)
+        if(!event.sender.isDestroyed()) event.sender.sendToAll(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`, result)
+        console.log(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`)
+      }
+      ipcMain.on(`CHROME_RUNTIME_ONMESSAGE_RESULT_${val}`, callback)
+      setTimeout(() => ipcMain.removeListener(`CHROME_RUNTIME_ONMESSAGE_RESULT_${val}`, callback), 1000 * 120)
+      resultID.val++
+    }
+  })
+
+
+  ipcMain.on('send-args-renderer', (e, key, rendererId, args) => {
+    console.log('send-args-renderer', key, rendererId, args)
+    webContents.fromId(rendererId).send(`send-args-renderer_${key}`, args)
+  })
+
+  ipcMain.on('background-data', (e, extensionId, dataKey, type, name, data) => {
+    const key = shortId()
+    console.log(extensionId, 'get-background-data', e.sender.getURL(),key, dataKey, type, name, data)
+    const success = sendToBackgroundPage(extensionId, 'get-background-data', e.sender.id, key, dataKey, type, name, data)
+    if(!success){
+      return e.returnValue = {key: false, result: void 0, type: 'no-proxy'}
+    }
+
+    ipcMain.once(`get-background-data-reply_${key}`, (e2, result, type) => {
+      console.log(`get-background-data-reply_${key}`, result, type)
+      e.returnValue = {key, result, type}
+    })
+  })
+  const {tabMain, tabsQuery, getTabValue} = require('./extensions/tabs-main')
+  tabMain(manifestMap, resultID, nextId)
+
+  require('./extensions/windows-main')(manifestMap, sendToBackgroundPages, tabsQuery)
+  require('./extensions/storage-main')(manifestMap)
+
+  app.once('ready', function () {
+    require('./extensions/web-request-main')(session.defaultSession, sendToBackgroundPage)
+    require('./extensions/idle-main')(manifestMap)
+    require('./extensions/cookies-main')(sendToBackgroundPages)
+    require('./extensions/sessions-main')(sendToBackgroundPages)
+    require('./extensions/commands-main')(sendToBackgroundPage)
+    require('./extensions/browsing-data-main')(sendToBackgroundPage)
+  })
+
+  require('./extensions/browser-action-main')(sendToBackgroundPage, getTabValue)
+  require('./extensions/context-menus-main')(manifestMap, sendToBackgroundPage, getTabValue)
+  require('./extensions/i18n-main')(manifestMap)
+  require('./extensions/management-main')(manifestMap)
+  require('./extensions/alarms-main')(sendToBackgroundPage)
+
+  return hookWebContentsEvents
+}
\ No newline at end of file
diff --git a/lib/browser/chrome-extension.js b/lib/browser/chrome-extension.js
old mode 100644
new mode 100755
index 5bd9f81bd..3fedba168
--- a/lib/browser/chrome-extension.js
+++ b/lib/browser/chrome-extension.js
@@ -1,19 +1,20 @@
 'use strict'
 
-const { app, webContents, BrowserWindow } = require('electron')
+const { ipcMain, app, webContents, BrowserWindow, session } = require('electron')
 const { getAllWebContents } = process.atomBinding('web_contents')
 const renderProcessPreferences = process.atomBinding('render_process_preferences').forAllWebContents()
-const ipcMain = require('@electron/internal/browser/ipc-main-internal')
+const mime = require('./extensions/mime')
 
 const { Buffer } = require('buffer')
 const fs = require('fs')
 const path = require('path')
 const url = require('url')
 
+const hjson = require('@electron/internal/browser/extensions/hjson')
+
 // Mapping between extensionId(hostname) and manifest.
-const manifestMap = {} // extensionId => manifest
-const manifestNameMap = {} // name => manifest
-const devToolsExtensionNames = new Set()
+const manifestMap = {}  // extensionId => manifest
+const devToolsExtensionIds = new Set()
 
 const generateExtensionIdFromName = function (name) {
   return name.replace(/[\W_]+/g, '-').toLowerCase()
@@ -21,11 +22,20 @@ const generateExtensionIdFromName = function (name) {
 
 const isWindowOrWebView = function (webContents) {
   const type = webContents.getType()
-  return type === 'window' || type === 'webview'
+  return type === 'window' || type === 'webview' || type === 'browserView'
+}
+
+const isWebView = function (webContents) {
+  const type = webContents.getType()
+  return type === 'webview' || type === 'browserView'
+}
+
+const removeBom = function(x){
+  return x.charCodeAt(0) === 0xFEFF ? x.slice(1) : x
 }
 
 // Create or get manifest object from |srcDirectory|.
-const getManifestFromPath = function (srcDirectory) {
+const getManifestFromPath = function (srcDirectory, admin) {
   let manifest
   let manifestContent
 
@@ -38,16 +48,23 @@ const getManifestFromPath = function (srcDirectory) {
   }
 
   try {
-    manifest = JSON.parse(manifestContent)
+    manifest = hjson.parse(removeBom(manifestContent.toString()).replace('\\u003Call_urls>','<all_urls>'))
+    manifest.base_path = srcDirectory
+    manifest.current_locale = app.getLocale()
+    manifest.admin = admin
+
+    manifest.id = path.basename(path.parse(srcDirectory).dir)
+    if(manifest.id == 'default') manifest.id = 'dckpbojndfoinamcdamhkjhnjnmjkfjd'
+    manifest.url = `https://chrome.google.com/webstore/detail/${manifest.id}`
   } catch (parseError) {
     console.warn(`Parsing ${path.join(srcDirectory, 'manifest.json')} failed.`)
     console.warn(parseError.stack || parseError)
     throw parseError
   }
 
-  if (!manifestNameMap[manifest.name]) {
-    const extensionId = generateExtensionIdFromName(manifest.name)
-    manifestMap[extensionId] = manifestNameMap[manifest.name] = manifest
+  if (!manifestMap[manifest.id]) {
+    const extensionId = manifest.id
+    manifestMap[extensionId] = manifest
     Object.assign(manifest, {
       srcDirectory: srcDirectory,
       extensionId: extensionId,
@@ -61,8 +78,8 @@ const getManifestFromPath = function (srcDirectory) {
       })
     })
     return manifest
-  } else if (manifest && manifest.name) {
-    console.warn(`Attempted to load extension "${manifest.name}" that has already been loaded.`)
+  } else if (manifest && manifest.id) {
+    console.warn(`Attempted to load extension "${manifest.id}" that has already been loaded.`)
     return manifest
   }
 }
@@ -71,7 +88,8 @@ const getManifestFromPath = function (srcDirectory) {
 const backgroundPages = {}
 
 const startBackgroundPages = function (manifest) {
-  if (backgroundPages[manifest.extensionId] || !manifest.background) return
+  if (backgroundPages[manifest.extensionId]) return
+  if(!manifest.background) manifest.background = {scripts: []}
 
   let html
   let name
@@ -86,8 +104,16 @@ const startBackgroundPages = function (manifest) {
     html = Buffer.from(`<html><body>${scripts}</body></html>`)
   }
 
+  // const win = new BrowserWindow({
+  //     webSecurity: false,
+  //     isBackgroundPage: true,
+  //     commandLineSwitches: ['--background-page']
+  // })
+  // const contents = win.webContents
+
   const contents = webContents.create({
-    partition: 'persist:__chrome_extension',
+    // partition: 'persist:__chrome_extension',
+    webSecurity: false,
     isBackgroundPage: true,
     commandLineSwitches: ['--background-page']
   })
@@ -108,124 +134,41 @@ const removeBackgroundPages = function (manifest) {
 }
 
 const sendToBackgroundPages = function (...args) {
-  for (const page of Object.values(backgroundPages)) {
-    page.webContents._sendInternalToAll(...args)
+  let success = false
+  for(let cont of webContents.getAllWebContents()){
+    if(!cont.isDestroyed() && cont.getURL().startsWith('chrome-extension:')){
+      cont.sendToAll(...args)
+      success = true
+    }
   }
+  return success
 }
 
-// Dispatch web contents events to Chrome APIs
-const hookWebContentsEvents = function (webContents) {
-  const tabId = webContents.id
-
-  sendToBackgroundPages('CHROME_TABS_ONCREATED')
-
-  webContents.on('will-navigate', (event, url) => {
-    sendToBackgroundPages('CHROME_WEBNAVIGATION_ONBEFORENAVIGATE', {
-      frameId: 0,
-      parentFrameId: -1,
-      processId: webContents.getProcessId(),
-      tabId: tabId,
-      timeStamp: Date.now(),
-      url: url
-    })
-  })
-
-  webContents.on('did-navigate', (event, url) => {
-    sendToBackgroundPages('CHROME_WEBNAVIGATION_ONCOMPLETED', {
-      frameId: 0,
-      parentFrameId: -1,
-      processId: webContents.getProcessId(),
-      tabId: tabId,
-      timeStamp: Date.now(),
-      url: url
-    })
-  })
-
-  webContents.once('destroyed', () => {
-    sendToBackgroundPages('CHROME_TABS_ONREMOVED', tabId)
-  })
-}
-
-// Handle the chrome.* API messages.
-let nextId = 0
-
-ipcMain.on('CHROME_RUNTIME_CONNECT', function (event, extensionId, connectInfo) {
-  const page = backgroundPages[extensionId]
-  if (!page) {
-    console.error(`Connect to unknown extension ${extensionId}`)
-    return
-  }
-
-  const portId = ++nextId
-  event.returnValue = { tabId: page.webContents.id, portId: portId }
-
-  event.sender.once('render-view-deleted', () => {
-    if (page.webContents.isDestroyed()) return
-    page.webContents._sendInternalToAll(`CHROME_PORT_DISCONNECT_${portId}`)
-  })
-  page.webContents._sendInternalToAll(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, event.sender.id, portId, connectInfo)
-})
-
-ipcMain.on('CHROME_I18N_MANIFEST', function (event, extensionId) {
-  event.returnValue = manifestMap[extensionId]
-})
-
-let resultID = 1
-ipcMain.on('CHROME_RUNTIME_SENDMESSAGE', function (event, extensionId, message, originResultID) {
-  const page = backgroundPages[extensionId]
-  if (!page) {
-    console.error(`Connect to unknown extension ${extensionId}`)
-    return
-  }
-
-  page.webContents._sendInternalToAll(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, event.sender.id, message, resultID)
-  ipcMain.once(`CHROME_RUNTIME_ONMESSAGE_RESULT_${resultID}`, (event, result) => {
-    event.sender._sendInternal(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`, result)
-  })
-  resultID++
-})
-
-ipcMain.on('CHROME_TABS_SEND_MESSAGE', function (event, tabId, extensionId, isBackgroundPage, message, originResultID) {
-  const contents = webContents.fromId(tabId)
-  if (!contents) {
-    console.error(`Sending message to unknown tab ${tabId}`)
-    return
-  }
-
-  const senderTabId = isBackgroundPage ? null : event.sender.id
-
-  contents._sendInternalToAll(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, senderTabId, message, resultID)
-  ipcMain.once(`CHROME_RUNTIME_ONMESSAGE_RESULT_${resultID}`, (event, result) => {
-    event.sender._sendInternal(`CHROME_TABS_SEND_MESSAGE_RESULT_${originResultID}`, result)
-  })
-  resultID++
-})
-
-ipcMain.on('CHROME_TABS_EXECUTESCRIPT', function (event, requestId, tabId, extensionId, details) {
-  const contents = webContents.fromId(tabId)
-  if (!contents) {
-    console.error(`Sending message to unknown tab ${tabId}`)
-    return
-  }
-
-  let code, url
-  if (details.file) {
-    const manifest = manifestMap[extensionId]
-    code = String(fs.readFileSync(path.join(manifest.srcDirectory, details.file)))
-    url = `chrome-extension://${extensionId}${details.file}`
-  } else {
-    code = details.code
-    url = `chrome-extension://${extensionId}/${String(Math.random()).substr(2, 8)}.js`
+const sendToBackgroundPage = function (extensionId, ...args) {
+  let success = false
+  // console.log('sendToBackgroundPage',extensionId,...args)
+  for(let cont of webContents.getAllWebContents()){
+    if(!cont.isDestroyed() && cont.getURL().startsWith(`chrome-extension://${extensionId}`)){
+      cont.sendToAll(...args)
+      success = true
+    }
   }
+  return success
+}
 
-  contents._sendInternal('CHROME_TABS_EXECUTESCRIPT', event.sender.id, requestId, extensionId, url, code)
-})
+const chromeExtensionApi = require('./chrome-extension-api')
+const hookWebContentsEvents = chromeExtensionApi(manifestMap, backgroundPages, sendToBackgroundPage, sendToBackgroundPages)
 
 // Transfer the content scripts to renderer.
 const contentScripts = {}
+const contentScriptsEntry = {}
+
+ipcMain.on('get-render-process-preferences', e =>{
+  e.returnValue = [...Object.values(contentScriptsEntry)]
+})
 
 const injectContentScripts = function (manifest) {
-  if (contentScripts[manifest.name] || !manifest.content_scripts) return
+  if (contentScripts[manifest.id] || !manifest.content_scripts) return
 
   const readArrayOfFiles = function (relativePath) {
     return {
@@ -237,6 +180,9 @@ const injectContentScripts = function (manifest) {
   const contentScriptToEntry = function (script) {
     return {
       matches: script.matches,
+      exclude_matches: script.exclude_matches,
+      include_globs: script.include_globs,
+      exclude_globs: script.exclude_globs,
       js: script.js ? script.js.map(readArrayOfFiles) : [],
       css: script.css ? script.css.map(readArrayOfFiles) : [],
       runAt: script.run_at || 'document_idle'
@@ -246,19 +192,23 @@ const injectContentScripts = function (manifest) {
   try {
     const entry = {
       extensionId: manifest.extensionId,
+      admin: manifest.admin,
+      name: manifest.name,
       contentScripts: manifest.content_scripts.map(contentScriptToEntry)
     }
-    contentScripts[manifest.name] = renderProcessPreferences.addEntry(entry)
+    contentScripts[manifest.id] = renderProcessPreferences.addEntry(entry)
+    contentScriptsEntry[manifest.id] = entry
   } catch (e) {
     console.error('Failed to read content scripts', e)
   }
 }
 
 const removeContentScripts = function (manifest) {
-  if (!contentScripts[manifest.name]) return
+  if (!contentScripts[manifest.id]) return
 
-  renderProcessPreferences.removeEntry(contentScripts[manifest.name])
-  delete contentScripts[manifest.name]
+  renderProcessPreferences.removeEntry(contentScripts[manifest.id])
+  delete contentScripts[manifest.id]
+  delete contentScriptsEntry[manifest.id]
 }
 
 // Transfer the |manifest| to a format that can be recognized by the
@@ -267,7 +217,8 @@ const manifestToExtensionInfo = function (manifest) {
   return {
     startPage: manifest.startPage,
     srcDirectory: manifest.srcDirectory,
-    name: manifest.name,
+    name: manifest.id,
+    // name: manifest.name, //@TODO CHECK
     exposeExperimentalAPIs: true
   }
 }
@@ -280,6 +231,7 @@ const loadExtension = function (manifest) {
 
 const loadDevToolsExtensions = function (win, manifests) {
   if (!win.devToolsWebContents) return
+  if(manifests.every(manifest => !manifest.devtools_page)) return
 
   manifests.forEach(loadExtension)
 
@@ -290,46 +242,90 @@ const loadDevToolsExtensions = function (win, manifests) {
   win.devToolsWebContents.executeJavaScript(`DevToolsAPI.addExtensions(${JSON.stringify(extensionInfoArray)})`)
 }
 
-app.on('web-contents-created', function (event, webContents) {
+ipcMain.on('web-contents-created', function (event, webContents) {
   if (!isWindowOrWebView(webContents)) return
 
+  console.log('web-contents-created',45454)
   hookWebContentsEvents(webContents)
   webContents.on('devtools-opened', function () {
     loadDevToolsExtensions(webContents, Object.values(manifestMap))
   })
 })
 
+const accessKey = `${process.hrtime()}_${Math.random().toString()}`
+ipcMain.on('get-access-key', e => {
+  e.returnValue = accessKey
+})
+
+const cache = {}
 // The chrome-extension: can map a extension URL request to real file path.
 const chromeExtensionHandler = function (request, callback) {
-  const parsed = url.parse(request.url)
-  if (!parsed.hostname || !parsed.path) return callback()
-
-  const manifest = manifestMap[parsed.hostname]
-  if (!manifest) return callback()
-
-  const page = backgroundPages[parsed.hostname]
-  if (page && parsed.path === `/${page.name}`) {
-    // Disabled due to false positive in StandardJS
-    // eslint-disable-next-line standard/no-callback-literal
-    return callback({
-      mimeType: 'text/html',
-      data: page.html
-    })
+  if(cache[request.url] && !request.headers.Range){
+    return callback({...cache[request.url][0], data: cache[request.url][1]()})
   }
 
-  fs.readFile(path.join(manifest.srcDirectory, parsed.path), function (err, content) {
-    if (err) {
-      // Disabled due to false positive in StandardJS
-      // eslint-disable-next-line standard/no-callback-literal
-      return callback(-6) // FILE_NOT_FOUND
-    } else {
-      return callback(content)
+  const parsed = new URL(request.url)
+  if (!parsed.hostname || !parsed.pathname) return callback()
+
+  const manifest = manifestMap[parsed.hostname]
+  if (!manifest) return callback({statusCode: 404})
+
+  // const page = backgroundPages[parsed.hostname]
+  // if (page && parsed.path === `/${page.name}`) {
+  //   // Disabled due to false positive in StandardJS
+  //   // eslint-disable-next-line standard/no-callback-literal
+  //   return callback({
+  //     mimeType: 'text/html',
+  //     data: page.html
+  //   })
+
+  const isGetFile = parsed.hostname == 'dckpbojndfoinamcdamhkjhnjnmjkfjd' && parsed.searchParams.get('file')
+  if(isGetFile && parsed.searchParams.get('key') != accessKey) return callback({statusCode: 500})
+  const filePath = path.join(manifest.base_path,parsed.pathname)
+  const isValidPath = filePath.startsWith(path.join(manifest.base_path))
+  if(!isValidPath) return callback({statusCode: 500})
+
+  const validFilePath = isGetFile ? parsed.searchParams.get('file').replace(/^file:\/\//,"") : isValidPath ? filePath : ''
+  // console.log(validFilePath)
+
+  fs.stat(validFilePath, (err, stats) => {
+    if(err) return callback({statusCode: 404})
+
+    let type = mime.getType(validFilePath)
+    const range = request.headers.Range
+    if (range) {
+      const parts = range.replace(/bytes=/, "").split("-")
+      const start = parseInt(parts[0], 10)
+      const fileSize = stats.size
+      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1
+      cache[request.url] = [{
+        statusCode: 206,
+        headers: {
+          'Content-Range': `bytes ${start}-${end}/${fileSize}`,
+          'Accept-Ranges': 'bytes',
+          'Content-Length': end - start + 1,
+          'Content-Type': type,
+        }
+      },()=>fs.createReadStream(validFilePath, {start, end, highWaterMark: 1024 * 1024})]
+      callback({...cache[request.url][0], data: cache[request.url][1]()})
+    }
+    else {
+      cache[request.url] = [{
+        statusCode: 200,
+        headers: {
+          'Cache-Control': 'public',
+          'Content-Length': stats.size,
+          'Content-Type': type && `${type}${type.startsWith('text') ? '; charset=UTF-8' : ''}`
+        }
+      },()=>fs.createReadStream(validFilePath, {highWaterMark: 1024 * 1024})]
+      callback({...cache[request.url][0], data: cache[request.url][1]()})
     }
   })
+
 }
 
 app.on('session-created', function (ses) {
-  ses.protocol.registerBufferProtocol('chrome-extension', chromeExtensionHandler, function (error) {
+  ses.protocol.registerStreamProtocol('chrome-extension', chromeExtensionHandler, function (error) {
     if (error) {
       console.error(`Unable to register chrome-extension protocol: ${error}`)
     }
@@ -341,8 +337,8 @@ let loadedDevToolsExtensionsPath = null
 
 app.on('will-quit', function () {
   try {
-    const loadedDevToolsExtensions = Array.from(devToolsExtensionNames)
-      .map(name => manifestNameMap[name].srcDirectory)
+    const loadedDevToolsExtensions = Array.from(devToolsExtensionIds)
+      .map(id => manifestMap[id].srcDirectory)
     if (loadedDevToolsExtensions.length > 0) {
       try {
         fs.mkdirSync(path.dirname(loadedDevToolsExtensionsPath))
@@ -360,6 +356,69 @@ app.on('will-quit', function () {
 
 // We can not use protocol or BrowserWindow until app is ready.
 app.once('ready', function () {
+
+  // session.fromPartition('persist:__chrome_extension').webRequest.onHeadersReceived((details, callback) => {
+  //   const extUrl = webContents.fromId(details.webContentsId).getURL()
+  //   if(extUrl){
+  //     details.responseHeaders["Access-Control-Allow-Origin"] = [extUrl.match(/^(chrome-extension:\/\/[^\/]+)/)[0]]
+  //     details.responseHeaders["Access-Control-Allow-Credentials"] = ['true']
+  //   }
+  //   if(details.headers['Access-Control-Request-Headers']){
+  //     details.responseHeaders['Access-Control-Allow-Headers'] = details.headers['Access-Control-Request-Headers'].split(',')
+  //   }
+  //   if(details.headers['Access-Control-Request-Method']){
+  //     details.responseHeaders['Access-Control-Allow-Methods'] = [details.headers['Access-Control-Request-Method']]
+  //   }
+  //   callback({
+  //     cancel: false,
+  //     responseHeaders: {...details.responseHeaders}
+  //   })
+  // })
+
+  // session.fromPartition('persist:__chrome_extension').webRequest.onHeadersReceived((details, callback) => {
+  //   details.responseHeaders["Access-Control-Allow-Origin"] = [new URL(details.url).origin]
+  //   details.responseHeaders["Access-Control-Allow-Credentials"] = ['true']
+  //
+  //   if(details.headers['Access-Control-Request-Headers']){
+  //     details.responseHeaders['Access-Control-Allow-Headers'] = details.headers['Access-Control-Request-Headers'].split(',')
+  //   }
+  //   if(details.headers['Access-Control-Request-Method']){
+  //     details.responseHeaders['Access-Control-Allow-Methods'] = [details.headers['Access-Control-Request-Method']]
+  //   }
+  //   details.responseHeaders['content-security-policy'] = []
+  //   delete details.responseHeaders['x-frame-options']
+  //   delete details.responseHeaders['x-content-type-options']
+  //   delete details.responseHeaders['x-xss-protection']
+  //   // console.log(details)
+  //   callback({
+  //     cancel: false,
+  //     responseHeaders: details.responseHeaders
+  //   })
+  // })
+  //
+  //
+  // session.fromPartition('persist:__chrome_extension').webRequest.onBeforeSendHeaders((details, callback) => {
+  //   details.requestHeaders.Origin = new URL(details.url).origin
+  //   callback({
+  //     cancel: false,
+  //     requestHeaders: details.requestHeaders
+  //   })
+  // })
+
+  // Load persisted extensions.
+  loadedDevToolsExtensionsPath = path.join(app.getPath('userData'), 'DevTools Extensions')
+  try {
+    const loadedDevToolsExtensions = JSON.parse(fs.readFileSync(loadedDevToolsExtensionsPath))
+    if (Array.isArray(loadedDevToolsExtensions)) {
+      for (const srcDirectory of loadedDevToolsExtensions) {
+        // Start background pages and set content scripts.
+        BrowserWindow.addDevToolsExtension(srcDirectory)
+      }
+    }
+  } catch (error) {
+    // Ignore error
+  }
+
   // The public API to add/remove extensions.
   BrowserWindow.addExtension = function (srcDirectory) {
     const manifest = getManifestFromPath(srcDirectory)
@@ -370,66 +429,62 @@ app.once('ready', function () {
           loadDevToolsExtensions(webContents, [manifest])
         }
       }
-      return manifest.name
+      return manifest.id
     }
   }
 
-  BrowserWindow.removeExtension = function (name) {
-    const manifest = manifestNameMap[name]
+  BrowserWindow.addExtensionWebview = function (srcDirectory, admin) {
+    const manifest = getManifestFromPath(srcDirectory, admin)
+    if (manifest) {
+      loadExtension(manifest)
+      for (const webContents of getAllWebContents()) {
+        if (isWebView(webContents)) {
+          loadDevToolsExtensions(webContents, [manifest])
+        }
+      }
+      return manifest
+    }
+  }
+
+
+  BrowserWindow.removeExtension = function (id) {
+    const manifest = manifestMap[id]
     if (!manifest) return
 
     removeBackgroundPages(manifest)
     removeContentScripts(manifest)
-    delete manifestMap[manifest.extensionId]
-    delete manifestNameMap[name]
+    delete manifestMap[id]
   }
 
   BrowserWindow.getExtensions = function () {
     const extensions = {}
-    Object.keys(manifestNameMap).forEach(function (name) {
-      const manifest = manifestNameMap[name]
-      extensions[name] = { name: manifest.name, version: manifest.version }
+    Object.keys(manifestMap).forEach(function (id) {
+      const manifest = manifestMap[id]
+      extensions[id] = {id, name: manifest.name, version: manifest.version}
     })
     return extensions
   }
 
   BrowserWindow.addDevToolsExtension = function (srcDirectory) {
-    const manifestName = BrowserWindow.addExtension(srcDirectory)
-    if (manifestName) {
-      devToolsExtensionNames.add(manifestName)
+    const extensionId = BrowserWindow.addExtension(srcDirectory)
+    if (extensionId) {
+      devToolsExtensionIds.add(extensionId)
     }
-    return manifestName
+    return extensionId
   }
 
-  BrowserWindow.removeDevToolsExtension = function (name) {
-    BrowserWindow.removeExtension(name)
-    devToolsExtensionNames.delete(name)
+  BrowserWindow.removeDevToolsExtension = function (id) {
+    BrowserWindow.removeExtension(id)
+    devToolsExtensionIds.delete(id)
   }
 
   BrowserWindow.getDevToolsExtensions = function () {
     const extensions = BrowserWindow.getExtensions()
     const devExtensions = {}
-    Array.from(devToolsExtensionNames).forEach(function (name) {
-      if (!extensions[name]) return
-      devExtensions[name] = extensions[name]
+    Array.from(devToolsExtensionIds).forEach(function (id) {
+      if (!extensions[id]) return
+      devExtensions[id] = extensions[id]
     })
     return devExtensions
   }
-
-  // Load persisted extensions.
-  loadedDevToolsExtensionsPath = path.join(app.getPath('userData'), 'DevTools Extensions')
-  try {
-    const loadedDevToolsExtensions = JSON.parse(fs.readFileSync(loadedDevToolsExtensionsPath))
-    if (Array.isArray(loadedDevToolsExtensions)) {
-      for (const srcDirectory of loadedDevToolsExtensions) {
-        // Start background pages and set content scripts.
-        BrowserWindow.addDevToolsExtension(srcDirectory)
-      }
-    }
-  } catch (error) {
-    if (process.env.ELECTRON_ENABLE_LOGGING) {
-      console.error('Failed to load browser extensions from directory:', loadedDevToolsExtensionsPath)
-      console.error(error)
-    }
-  }
 })
diff --git a/lib/browser/extensions/alarms-main.js b/lib/browser/extensions/alarms-main.js
new file mode 100755
index 000000000..17c1fe667
--- /dev/null
+++ b/lib/browser/extensions/alarms-main.js
@@ -0,0 +1,55 @@
+const {ipcFuncMain, ipcFuncMainCb, getIpcNameFunc, shortId} = require('./util-main')
+const {ipcMain, BrowserWindow} = require('electron')
+const getIpcName = getIpcNameFunc('alarms')
+
+module.exports = function(sendToBackgroundPage) {
+  const alarmMap = {}
+
+  const clear = (e, extensionId, name)=> {
+    if(alarmMap[extensionId] && alarmMap[extensionId][name]){
+      clearTimeout(alarmMap[extensionId][name][1])
+      clearInterval(alarmMap[extensionId][name][2])
+      delete alarmMap[extensionId][name]
+      return true
+    }
+    return false
+  }
+
+  ipcFuncMain('alarms', 'create', (e, extensionId, name, alarmInfo)=> {
+    if(!alarmMap[extensionId]) alarmMap[extensionId] = {}
+    clear(e, extensionId, name)
+
+    const alarm = {name, ...alarmInfo}
+
+    let setIntervalId
+    const setTimeoutId = setTimeout(()=>{
+      sendToBackgroundPage(extensionId, getIpcName('onAlarm'), alarm)
+      if(alarmInfo.periodInMinutes && alarmMap[extensionId][name]){
+        setIntervalId = setInterval(()=>{
+          sendToBackgroundPage(extensionId, getIpcName('onAlarm'), alarm)
+        },alarmInfo.periodInMinutes * 1000 * 60)
+      }
+    }, alarmInfo.when ? alarmInfo.when - Date.now() : alarmInfo.delayInMinutes * 1000 * 60)
+    alarmMap[extensionId][name] = [alarm,setTimeoutId,setIntervalId]
+  })
+
+  ipcFuncMain('alarms', 'get', (e, extensionId, name)=> {
+    return alarmMap[extensionId] && alarmMap[extensionId][name]
+  })
+
+  ipcFuncMain('alarms', 'getAll', (e, extensionId)=> {
+    return alarmMap[extensionId] && Object.values(alarmMap[extensionId])
+  })
+
+  ipcFuncMain('alarms', 'clear', clear)
+
+  ipcFuncMain('alarms', 'clearAll', (e, extensionId)=> {
+    if(alarmMap[extensionId] && alarmMap[extensionId].length){
+      for(let name of Object.keys(alarmMap[extensionId])){
+        clear(e, extensionId, name)
+      }
+      return true
+    }
+    return false
+  })
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/browser-action-main.js b/lib/browser/extensions/browser-action-main.js
new file mode 100755
index 000000000..d9f7de47e
--- /dev/null
+++ b/lib/browser/extensions/browser-action-main.js
@@ -0,0 +1,38 @@
+const {ipcFuncMainCb, getIpcNameFunc, shortId} = require('./util-main')
+const {ipcMain, BrowserWindow} = require('electron')
+const getIpcName = getIpcNameFunc('browserAction')
+
+module.exports = function(sendToBackgroundPage, getTabValue) {
+
+  ipcMain.on('chrome-browserAction-onClicked', async (e, extensionId, tabId)=>{
+    sendToBackgroundPage(extensionId, getIpcName('onClicked'), await getTabValue({}, tabId))
+  })
+
+  ipcFuncMainCb('browserAction', 'getInfo', (e, extensionId, details, property, cb)=> {
+    for (let win of BrowserWindow.getAllWindows()) {
+      if (win.getTitle().includes('Sushi Browser')) {
+        if (!win.webContents.isDestroyed()){
+          const key = shortId()
+          win.webContents.send(`chrome-browser-action-get-info-${extensionId}`, key, details)
+          ipcMain.once(`chrome-browser-action-get-info-${extensionId}-reply_${key}`,(e, info) => {
+            cb(info[property])
+          })
+        }
+      }
+    }
+    cb()
+  })
+
+  ipcFuncMainCb('browserAction', 'enable', (e, extensionId, tabId, value, cb)=> {
+    for (let win of BrowserWindow.getAllWindows()) {
+      if (win.getTitle().includes('Sushi Browser')) {
+        if (!win.webContents.isDestroyed()){
+          win.webContents.send(`chrome-browser-action-enable-${extensionId}`, tabId, value)
+        }
+      }
+    }
+    cb()
+  })
+
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/browsing-data-main.js b/lib/browser/extensions/browsing-data-main.js
new file mode 100755
index 000000000..40bf37a63
--- /dev/null
+++ b/lib/browser/extensions/browsing-data-main.js
@@ -0,0 +1,25 @@
+const {ipcFuncMainCb,getIpcNameFunc} = require('./util-main')
+const { ipcMain} = require('electron')
+
+module.exports = function(){
+  ipcFuncMainCb('BrowsingData','remove', (e,options,dataToRemove,cb)=>{
+    if(options.since) return cb()
+
+    const arr = ['cookies','appcache','fileSystems','indexedDB','localStorage','serviceWorkers','webSQL']
+    const map = {cache: 'clearCache',downloads: 'clearDownload',formData: 'clearAutofillData', history: 'clearHistory',passwords: 'clearPassword'}
+
+    for(let [key,val] of Object.entries(dataToRemove)){
+      if(val) continue
+      let args
+      if(arr.includes(key)){
+        args = ['clearStorageData',{storages: [key]}]
+      }
+      else if(map[key]){
+        args = [map[key]]
+      }
+      if(args) ipcMain.emit('clear-browsing-data',null,...args)
+    }
+    cb()
+  })
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/commands-main.js b/lib/browser/extensions/commands-main.js
new file mode 100755
index 000000000..8d2a8e6c7
--- /dev/null
+++ b/lib/browser/extensions/commands-main.js
@@ -0,0 +1,35 @@
+const {ipcFuncMain, getIpcNameFunc, eventRegist, getFocusedWebContents} = require('./util-main')
+const {ipcMain} = require('electron')
+const getIpcName = getIpcNameFunc('Commands')
+
+const eventOnCommand = eventRegist(getIpcName('onCommand'))
+let first = true
+
+module.exports = function(sendToBackgroundPage){
+
+  const registBackgroundPages = new Map()
+  eventOnCommand.regist((extensionId, eventId)=>{
+    if(first){
+      ipcMain.on('chrome-commands-exec',(e,{id,command})=>{
+        for(let [eventId, extensionId] of registBackgroundPages) {
+          if(id != extensionId) continue
+          if(command == '_execute_browser_action' || command == '_execute_page_action'){
+            getFocusedWebContents().then(cont=>{
+              cont.send('chrome-browserAction-onClicked', id, cont.id)
+            })
+          }
+          else{
+            sendToBackgroundPage(extensionId, getIpcName('onCommand', extensionId), eventId, command)
+          }
+        }
+      })
+      first = false
+    }
+    registBackgroundPages.set(eventId, extensionId)
+  })
+  eventOnCommand.unregist((extensionIds, eventId)=>{
+    registBackgroundPages.delete(eventId)
+  })
+
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/content-settings-main.js b/lib/browser/extensions/content-settings-main.js
new file mode 100755
index 000000000..120b3d7df
--- /dev/null
+++ b/lib/browser/extensions/content-settings-main.js
@@ -0,0 +1,56 @@
+const {ipcFuncMainCb} = require('./util-main')
+const {ipcMain} = require('electron')
+
+const matchesPattern = function (pattern, url) {
+  if (pattern === '<all_urls>') return true
+  const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+?.\\/\s]/g, '\\$&').replace(/\*/g, '.*')}$`)
+  return url.match(regexp)
+}
+
+module.exports = function(manifestMap){
+
+  const contentSettingsMap = {}
+  ipcFuncMainCb('contentSettings','get',(e,details,extensionId,type,cb)=>{
+    if(!contentSettingsMap[extensionId] || !contentSettingsMap[extensionId][type]) return cb({})
+
+    for(let val of contentSettingsMap[extensionId][type]){
+      const resource = details.resourceIdentifier ? details.resourceIdentifier.id : void 0
+      const matchPrimary = matchesPattern(val.primaryPattern, details.primaryUrl)
+      const matchSecondary = !details.secondaryUrl || matchesPattern(val.secondaryPattern, details.secondaryUrl)
+      const matchResource = !resource || resource == val.resourceId
+      if(matchPrimary && matchSecondary && matchResource){
+        return cb(val)
+      }
+    }
+  })
+
+
+
+  ipcFuncMainCb('contentSettings','set',(e,details,extensionId,type,cb)=>{
+    if(!contentSettingsMap[extensionId]){
+      contentSettingsMap[extensionId] = {}
+    }
+    if(!contentSettingsMap[extensionId][type]){
+      contentSettingsMap[extensionId][type] = []
+    }
+
+    contentSettingsMap[extensionId][type].push({primaryPattern: details.primaryPattern,setting: details.setting})
+    if(details.secondaryPattern) contentSettingsMap[extensionId][type].secondaryPattern = details.secondaryPattern
+    if(details.resourceIdentifier) contentSettingsMap[extensionId][type].resourceId = details.resourceIdentifier.id
+
+    let conf = defaultConf
+    for(let val of Object.values(contentSettingsMap)){
+      conf = {...conf,...val}
+    }
+    // session.defaultSession.userPrefs.setDictionaryPref('content_settings', conf) @TODO FIX
+    cb()
+  })
+
+
+  ipcFuncMainCb('contentSettings','clear',(e,details,extensionId,type,cb)=>{
+    if(!contentSettingsMap[extensionId] || !contentSettingsMap[extensionId][type]) return cb()
+    delete contentSettingsMap[extensionId][type]
+    cb()
+  })
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/context-menus-main.js b/lib/browser/extensions/context-menus-main.js
new file mode 100755
index 000000000..95973e7bf
--- /dev/null
+++ b/lib/browser/extensions/context-menus-main.js
@@ -0,0 +1,46 @@
+const {ipcFuncMain, ipcFuncMainCb, getIpcNameFunc} = require('./util-main')
+const {session, ipcMain} = require('electron')
+const getIpcName = getIpcNameFunc('ContextMenus')
+
+module.exports = function(manifestMap, sendToBackgroundPage, getTabValue) {
+  const extensionMenu = {}
+
+  ipcMain.on('get-extension-menu',(e) => ipcMain.emit('get-extension-menu-reply', null, extensionMenu))
+
+  ipcMain.on('chrome-context-menus-clicked', async (e, extensionId, tabId, info)=>{
+    sendToBackgroundPage(extensionId, getIpcName('onClicked'), info, await getTabValue({}, tabId))
+  })
+
+  ipcFuncMainCb('contextMenus', 'create', (e, extensionId, createProperties, cb)=> {
+    const manifest = manifestMap[extensionId]
+    const icon = Object.values(manifest.icons)[0]
+    const menuItemId = createProperties.id
+
+    if(!extensionMenu[extensionId]) extensionMenu[extensionId] = []
+    extensionMenu[extensionId].push({properties: createProperties, menuItemId, icon})
+    //TODO onClick
+    cb()
+  })
+
+
+  ipcFuncMain('contextMenus', 'update', (e, extensionId, id, updateProperties) => {
+    const menu = extensionMenu[extensionId]
+    if(menu){
+      const item = menu.find(propeties=>propeties.id === id || propeties.menuItemId === id)
+      if(item) Object.assign(item.properties,updateProperties)
+    }
+  })
+
+  ipcFuncMain('contextMenus', 'remove', (e, extensionId, menuItemId) => {
+    const menu = extensionMenu[extensionId]
+    if(menu){
+      const i = menu.findIndex(propeties=>propeties.menuItemId === menuItemId || propeties.id === menuItemId)
+       if(i != -1) menu.splice(i,1)
+    }
+  })
+
+  ipcFuncMain('contextMenus', 'removeAll', (e, extensionId) => {
+    delete extensionMenu[extensionId]
+  })
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/cookies-main.js b/lib/browser/extensions/cookies-main.js
new file mode 100755
index 000000000..fb59a41df
--- /dev/null
+++ b/lib/browser/extensions/cookies-main.js
@@ -0,0 +1,46 @@
+const {ipcFuncMainCb, getIpcNameFunc} = require('./util-main')
+const {session} = require('electron')
+
+module.exports = function(sendToBackgroundPages) {
+
+  session.defaultSession.on('changed', (event, cookie, cause, removed)=>{
+    sendToBackgroundPages('CHROME_COOKIES_ONCHANGED',{removed, cookie, cause})
+  })
+
+  ipcFuncMainCb('cookies', 'get', (e, details, cb) => {
+    session.defaultSession.cookies.get(details, (error, cookie) => {
+      let first = cookie
+
+      if (Array.isArray(cookie) && cookie.length) {
+        first = cookie[0]
+      }
+      cb(first)
+    })
+  })
+
+  ipcFuncMainCb('cookies', 'getAll', (e, details, cb) => {
+    session.defaultSession.cookies.get(details, (error, cookie) => {
+      if (!Array.isArray(cookie)) {
+        cookie = [cookie]
+      }
+      cb(cookie)
+    })
+  })
+
+  ipcFuncMainCb('cookies', 'set', (e, details, cb) => {
+    session.defaultSession.cookies.set(details, (error) => {
+      session.defaultSession.cookies.get(details, (error, cookie) => {
+        let first = cookie
+
+        if (Array.isArray(cookie) && cookie.length) {
+          first = cookie[0]
+        }
+        cb(first)
+      })
+    })
+  })
+
+  ipcFuncMainCb('cookies', 'remove', (e, details, cb) => {
+    session.defaultSession.cookies.remove(details.url, details.name, ()=>cb(details))
+  })
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/franc-min.js b/lib/browser/extensions/franc-min.js
new file mode 100755
index 000000000..9e634f46c
--- /dev/null
+++ b/lib/browser/extensions/franc-min.js
@@ -0,0 +1 @@
+!function(b,a){typeof exports==='object'&&typeof module!=='undefined'?module.exports=b():typeof define==='function'&&define.amd?define([],b):(typeof window!=='undefined'?a=window:typeof global!=='undefined'?a=global:typeof self!=='undefined'?a=self:a=this,a.franc=b())}(function(){return function(){function a(b,c,e){function f(d,k){if(!c[d]){if(!b[d]){var i='function'==typeof require&&require;if(!k&&i)return i(d,!0);if(g)return g(d,!0);var j=new Error("Cannot find module '"+d+"'");throw j.code='MODULE_NOT_FOUND',j}var h=c[d]={exports:{}};b[d][0].call(h.exports,function(a){var c=b[d][1][a];return f(c||a)},h,h.exports,a,b,c,e)}return c[d].exports}for(var g='function'==typeof require&&require,d=0;d<e.length;d++)f(e[d]);return f}return a}()({1:[function(b,a,c){a.exports={Latin:{spa:' de|os |de | la|la | y | a |es |n |in|rec|ere|der| co|e l|el |en |ien|cho|ent|ech|ci|aci|o a|a p| el|a l|al |as |e d| en|na |ona|s d|da |nte| to|ad |ene|con| pr| su|tod| se|ho |los| pe|per|ers| lo|o d| ti|cia|n d|cio| es|ida|res|a t|tie|ion|rso|te |do | in|son| re| li|to |dad|tad|e s|est|pro|que|men| po|a e|oda|nci| qu| un|ue |ne |n e|s y|lib|su | na|s e|nac|ia |e e|tra| pa|or |ado|a d|nes|ra |se |ual|a c|er |por|com|nal|rta|a s|ber| o |one|s p|dos|r |sta|les|des|ibe|ser|era|ar |ert|ter| di|ale|l d|nto|hos|del|ica|a a|s n|n c|oci|imi|io |o e|re |y l|e c|ant|cci| as|las|par|ame| cu|ici|ara|enc|s t|ndi| so|o s|mie|tos|una|bre|dic|cla|s l|e a|l p|pre|ntr|o t|ial|y a|nid|n p|a y|man|omo|so |n l| al|ali|s a|no | ig|s s|e p|nta|uma|ten|gua|ade|y e|soc|mo | fu|igu|o p|n t|hum|d d|ran|ria|y d|ada|tiv|l e|cas| ca|vid|l t|s c|ido|das|dis|s i| hu|s o|nad|fun| ma|rac|nda|eli|sar|und| ac|uni|mbr|a u|die|e i|qui|a i| ha|lar| tr|odo|ca |tic|o y|cti|lid|ori|ndo|ari| me|ta |ind|esa|cua|un |ier|tal|esp|seg|ele|ons|ito|ont|iva|s h|d y|nos|ist|rse| le|cie|ide|edi|ecc|ios|l m|r e|med|tor|sti|n a|rim|uie|ple|tri|ibr|sus|lo |ect|pen|y c|an |e h|n s|ern|tar|l y|egu|gur|ura|int|ond|mat|l r|r a|isf|ote',eng:' th|the| an|he |nd |and|ion| of|of |tio| to|to |on | in|al |ati|igh|ght|rig| ri|or |ent|as |ed |is |ll |in | be|e r|ne |one|ver|all|s t|eve|t t| fr|s a| ha| re|ty |ery| or|d t| pr|ht | co| ev|e h|e a|ng |ts |his|ing|be |yon| sh|ce |ree|fre|ryo|n t|her|men|nat|sha|pro|nal|y a|has|es |for| hi|hal|f t|n a|n o|nt | pe|s o| fo|d i|nce|er |ons|res|e s|ect|ity|ly |l b|ry |e e|ers|e i|an |e o| de|cti|dom|edo|eed|hts|ter|ona|re | no| wh| a | un|d f| as|ny |l a|e p|ere| en| na| wi|nit|nte|d a|any|ted| di|ns |sta|th |per|ith|e t|st |e c|y t|om |soc| ar|ch |t o|d o|nti|s e|equ|ve |oci|man| fu|ote|oth|ess| al| ac|wit|ial| ma|uni| se|rea| so| on|lit|int|r t|y o|enc|thi|ual|t a| eq|tat|qua|ive| st|ali|e w|l o|are|f h|con|te |led| is|und|cia|e f|le | la|y i|uma|by | by|hum|f a|ic | hu|ave|ge |r a| wo|o a|ms |com| me|eas|s d|tec| li|n e|en |rat|tit|ple|whe|ate|o t|s r|t f|rot| ch|cie|dis|age|ary|o o|anc|eli|no | fa| su|son|inc|at |nda|hou|wor|t i|nde|rom|oms| ot|g t|eme|tle|iti|gni|s w|itl|duc|d w|whi|act|hic|aw |law| he|ich|min|imi|ort|o s|se |e b|ntr|tra|edu|oun|tan|e d|nst|l p|d n|ld |nta|s i|ble|n p| pu|n s| at|ily|rth|tho|ful|ssi|der|o e|cat|uca|unt|ien| ed|o p|h a|era|ind|pen|sec|n w|omm|r s',por:'os |de | de| a | e |o d|to |o | di|ent|da |ito|em | co|eit|as |dir|es |ire|rei| se|o|ade|a p|dad|e d|s d|men|nte|do |s e| pr| pe|dos| to| da|a a|o e| o |o a|ess|con|tod|que| qu|te |e a| do|al |res|ida|m d| in| ou|er |sso| na| re| po|a s| li|uma|cia|ar |pro|e e|a d| te|a|a t| es| su|ou |ue |s p|tos|a e|des|ra |com|no |ame|ia |e p|tem|nto| pa|is |est|tra|es|na |s o|oda|das|ser|soa|s n|pes|o p|s a|o s|e o| em| as|  |o o|ais|ber|ado|oa |o t|e s|man|sua|ua | no| os|a c|ter|e|erd|lib|rda|s s|nci|ibe|e n|ica|odo|so |nal|ntr|s t|hum|ura| ao|ona|ual| so|or |ma |sta|o c|a n|pre|ara|era|ons|e t|r a|par|o | hu|ind|por|cio|ria|m a|s c| um|a l|gua|ran| en|ndi|o i|e c|ra|ion|nid|aci|ano|soc|e r|oci| ac|und|sen|nos|nsi|rec|ime|ali|int|um |per|nac| al|m o|r p| fu|ndo|ont|a| ig|igu|fun|nta| ma|uni|c|ere| ex|a i| me|ese|rio|l d|a o|s h|pel|ada|pri|ide|am |m p|pod|s f|m |a f|io |ode|ca |ita|lid|tiv|e f|vid|r e|esp|nda|omo|e l|na|o r|ant|a q|tad|lic|iva| fa|ver|s l|ial|cla|ngu|ing| ca|mo |der| vi|eli|ist|ta |se |ati|ios|ido|r o|eci|dis| un|e i|r d|ec|o q|s i|qua|nc|a m|seu|sti|nin|uer|rar|cas|aos|ens|gu|ias|sid|um|tur|dam|sse|ao |ela|l e|for|tec|ote| pl|ena| tr|m c|tro| ni|ico|rot',ind:'an |ang| da|ng | pe|ak | ke| me|ata| se|dan|kan| di| be|hak|ber|per|ran|nga|yan|eng| ya| ha|asa|gan|men|ara|nya|n p|n d|n k|a d|tan| at|at |ora|ala|san| ba|ap |erh|n b|rha|ya | ma|g b|a s|pen|eba|as |aan|uk |ntu| or|eti|tas|aka|tia|ban|set| un|n s|ter|n y| te|k m|tuk|bas|iap|lam|beb|am | de|k a|keb|n m|i d|unt|ama|dal|ah |ika|dak|ebe|p o|sa |pun|mem|n h|end|den|ra |ela|ri |nda| sa|di |ma |a m|n t|k d|n a|ngg|tau|man|gar|eri|asi| ti|un |al |ada|um |a p|lak|ari|au | ne|neg|a b|ngs|ta |ole|leh|ert|ers|ida|k h|ana|gsa|dar|uka|tid|bat|sia|era|eh |dap|ila|dil|h d|atu|sam|ia |i m| in|lan|aha|uan|tu |ai |t d|a a|g d|har|sem|na |apa|ser|ena|kat|uat|erb|erl|mas|rta|ega|ung|nan|emp|n u|kum|l d|g s| hu|ka |ent|pat|mba|aga|nta|adi| su|eni|uku|n i|huk|ind|ar |rga|i s|aku|ndi|sua|ni |rus|han|si |car|nny| la|in |u d|ik |ua |lah|rik|usi|emb|ann|mer|ian|gga|lai|min|a u|lua|ema|emu|arg|dun|dip|a t|mat|aya|rbu|aru|erk|rka|ini|eka|a k|rak|kes|yat|iba|nas|rma|ern|ese|s p|nus| pu|anu|ina| ta|mel|mua|kel|k s|us |ndu|nak|da |sya|das|pem|lin|ut |yar|ami|upu|seo|aik|eor|iny|aup|tak|ipe|ing|tin| an|dik|uar|ili|g t|rse|sar|ant|g p|a n|aks|ain| ja|t p| um|g m|dir|ksa|umu|kep|mum|i k|eca|rat|m p|h p|aba|ses|m m',fra:' de|es |de |ion|nt |et |tio| et|ent| la|la |e d|on |ne |oit|e l|le | le|s d|e p|t d|ati|roi| dr|dro|it |  | co|t |ns |te |e s|men|re | to|con| l|tou|que| qu|les| so|des|son| pe|ons| un|s l|s e| pr|ue | pa|e c|t l|ts |onn| au|e a|eme|e e| li|ont|ant|out|ute|t |res|ers| sa|ce | a |tre|per|a d|cti|er |lib|it| en|ux | re|en |rso| l| ou| in|lle|un |nat|ou |nne|n d|une| d| se|par|nte|us |ur |s s|ans|dan|a p|r l|pro|its|s |t p|ire|e t|s p|sa | d|ond| d|a l|nce|ert|aux|omm|nal|me | na| fo|iqu| ce|rt|ect|ale|ber|t a|s a| da|mme|ibe|san|e r| po|com|al |s c|qui|our|t e| ne|e n|ous|r d|ali|ter| di|fon|e o|au | ch|air|ui |ell| es|lit|s n|iss|ra|tes|soc|aut|oci|tr|ien|int|du |est|t|tra|pou| pl|rat|ar |ran|rai|s o|ona|ain|cla|ga|anc|rs |eur|pri|n c|e m|s t| u| do|ure|bre|ut | t|age| t|nsi|sur|ein|sen|ser|ndi|ens|ess|ntr|ir | ma|cia|n p|st |a c| du|l e| su|bli|ge |rs| r|e q|ass|nda|peu|e |la| te|a s|tat|il |ts|ais|u d|ine|ind| e|qu| ac|s i|n t|t c|n a|lh|t q|soi|t s|cun|rit| g|oir|en|nta|hom| on|n e| mo|ie |ign|rel|nna|t i|l n| tr|ill|ple|s |le|rec|a r|ote|sse|uni|id|ive|s u|t |ins|act| fa|n s| vi|gal| as|lig|ssa|pr|leu|e f|lic|dis|ver| nu|ten|ssi|rot|tec|s m|abl',deu:'en |er |der| un|nd |und|ein|ung|cht| de|ich|sch|ng | ge|ie |che|ech| di|die|rec|gen|ine|eit| re|ch | da|n d|ver|hen| zu|t d| au|ht | ha|lic|it |ten|rei| be|in | ve| in| ei|nde|auf|den|ede|zu |n s|uf |fre|ne |ter|es | je|jed|n u| an|sei|and| fr|run|at | se|e u|das|hei|s r|hte|hat|nsc|nge|r h|as |ens| al|ere|lle|t a| we|n g|rde|nte|ese|men| od|ode|ner|g d|all|t u|ers|te |nen| so|d d|n a|ben|lei| gr| vo|wer|e a|ege|ion| st|ige|le |cha| me|haf|aft|n j|ren| er|erk|ent|bei| si|eih|ihe|kei|erd|tig|n i|on |lun|r d|len|gem|ies|gru|tli|unt|chu|ern|ges|end|e s|ft |st |ist|tio|ati| gl|sta|gun|mit|sen|n n| na|n z|ite| wi|r g|eic|e e|ei |lie|r s|n w|gle|mei|de |uch|em |chl|nat|rch|t w|des|n e|hre|ale|spr|d f|ach|sse|r e| sc|urc|r m|nie|e f|fen|e g|e d| ni|dur|dar|int| du|geh|ied|t s| mi|alt|her|hab|f g|sic|ste|taa|aat|he |ang|ruc|hli|tz |eme|abe|h a|n v|nun|geg|arf|rf |ehe|pru| is|erf|e m|ans|ndl|e b|tun|n o|d g|n r|r v|wie|ber|r a|arb|bes|t i|h d|r w|r b| ih|d s|igk|gke|nsp|dig|ema|ell|eru|n f|ins|rbe|ffe|esc|igu|ger|str|ken|e v|gew|han|ind|rt | ar|ie|n h|rn |man|r i|hut|utz|d a|ls |ebe|von|lte|r o|rli|etz|tra|aus|det|hul|e i|one|nne|isc|son|sel|et |ohn|t g|sam| fa|rst|rkl|ser|iem|g v|t z|err',jav:'ng |an |ang| ka|ing|kan| sa|ak |lan| la|hak| ha| pa| ma|ngg|ara|sa |abe|ne | in|n k|ant| ng|tan|nin| an|nga|ata|en |ran| ba|man|ban|ane|hi |n u|ong|ra |nth|ake|ke |thi| da|won|uwo|ung|ngs| uw|asa|gsa|ben|sab|ana|aka|beb|a k|g p|nan|nda|adi|at |awa|san|ni |dan|g k|pan|eba| be|e k|g s|ani|bas| pr|dha|aya|gan|ya |wa |di |mar|n s| wa|ta |a s|g u| na|e h|arb|a n|a b|a l|n n| ut|yan|n p|asi|g d|han|ah |g n| tu| um|as |wen|dak|rbe|dar| di|ggo|sar|mat|k h|a a|iya| un|und|eni|kab|be |art|ka |uma|ora|n b|ala|n m|ngk|rta|i h| or|gar|yat|kar|al |a m|n i|na |g b|ega|pra|ina|kak|g a|a p|tum|nya|kal|ger|gge| ta|kat|i k|ena|oni|kas| pe|dad|aga|g m|duw|k k|uta|uwe| si| ne|adh|pa |n a|go |and|i l| ke|nun|nal|ngu|uju|apa|a d|t m|i p|min|iba|er | li|anu|sak|per|ama|gay|war|pad|ggu|ha |ind|taw|ras|n l|ali|eng|awi|a u| bi|we |bad|ndu|uwa|awe|bak|ase|eh | me|neg|pri| ku|ron|ih |g t|bis|iji|i t|e p| pi|aba|isa|mba|ini|a w|g l|ika|n t|ebu|ndh|ar |sin|lak|ur |mra|men|ku | we|e s|a i|liy| ik|ayo|rib|ngl|ami|arg|nas|yom|wae|ut |kon|ae |rap|aku| te|dil|tin|rga|jud|umu| as|rak|bed|k b|il |kap|h k|jin|k a| nd|e d|i s| lu|i w|eka|mum|um |uha|ate| mi|k p|gon|eda| ti|but|n d|r k|ona|uto|tow|wat|gka|si |umr|k l|oma',vie:'ng |c |c | qu| th|a |nh | ng|i | nh|va| va|n |uy| ph| ca|quy|n|y|i | ch|nh| tr| cu|ng|i n|g||t |i| gi|ac| co|t |o |c t| |n t|ca|ng| kh||c| t| |i||in|i | ha|co|i |gia| |pha| mo|oi|mo|nh|n n|cu| ba|n |a |ua|n c|u |ng|n |u|t| bi|t|hn| vi|g t| la|n ||nh| ti|t c| |n |ba|hi|u c| t|do |hn| do|ch | q| t| na|n |ay | hi|an| d|i|ha| i|hay|g n| m|c|u|n v|i|h|th|p |qu| ho|p |na|ao|ng|n |i |ch|n |o |kh|c h|i c|c | h|i v|tro| a|ng|m|i t|t|g v|ia |ng|an||n|ng|h t|h |n|n b|c|a |la|c c|g c| o| c|n h|ha|h| b|a |y | v| t|i |i| c|t t|g |c|in| v|vi|v|h v|c|c|t|tha|m |ron|ong|ap|g b|h| s|a c|s|o |ao|h c| |o v|u|a m| |ia| c|cho|qua|ha|uc| mi| n|ph|c q|cn|o c|a |i h|ai| h| h| c|n l|bi| lu|b|ca|in|h | xa||g h|c n|c p|thu|ai| | h| c|o n| n|n|o |ao|xa|oa|y t|ha|t| c| t|th| du|m v|mi|ho |h|c| t|h|an|n p|cu|un|i|i|ti| |h|p|hoa|y |chi|o h| |ay| t|o|c l|v| |i b|kha|c b| |lu|ai | n||t|h|tri|p q|n|du|hi|g q|yn|ho|nh| ta| b|c g|n g|th|o t|c v|am |c m|an ',ita:' di|to | de|ion| in|la |e d|di |ne | e |zio|re |le |ni |ell|one|lla|rit|a d|o d|del|itt|iri|dir| co|ti |ess|ent| al|azi|tto|te |i d|i i|ere|t | pr|ndi|e l|ale|o a|ind|e e|e i|gni|nte|con|i e|li |a s| un|men|ogn| ne|uo | og|idu|e a|ivi|duo|vid| es|tti| ha|div| li|a p|no |all|pro|za |ato|per|sse|ser| so|i s| la| su|e p| pe|ibe|na |a l| il|ber|e n|il |ali|lib|ha |che|in |o s|e s| qu|o e|ia |e c| ri|nza|ta |nto|he |oni|o i| o |sta|o c|nel| a |o p|naz|e o|so | po|o h|gli|i u|ond|i c|ers|ame|i p|lle|un |era|ri |ver|ro |el |una|a c| ch|ert|ua |i a|ssi|rt|a e|ei |dis|ant| l |tat|a a|ona|ual| le|it|are|ter| ad|nit| da|pri|dei| e|cia| st| si|nal|est|tut|ist|com|uni| ed|ono| na|sua|al |si |anz| pa| re|raz|gua|ita|res|der|soc|man|o o|ad |i o|ese|que|enz|ed | se|io |ett|on | tu|dic| d|sia|i r|rso|oci|rio|ari|qua|ial|pre|ich|rat|ien|tra|ani|uma|se |ll |eri|a n|o n| um|do |ara|a t|zza|er |tri|att|ico|pos|sci|i l|son|nda|par|e u|fon| fo|nti|uzi|str|utt|ati|sen|int|nes|iar| i |hia|n c|sti|chi|ann|ra | eg|egu|isp|bil|ont|a r| no|rop| me|opr|ost| ma|ues|ica|sso|tal|cie|sun|lit|ore|ina|ite|tan| ra|non|gio|d a|e r|dev|i m|l i|ezz|izi| cu|nno|r |a i|tta|ria|lia|cos|ssu|dal|l p| as|ass|opo|ve |eve',tur:' ve| ha|ve |ler|lar|ir |in |hak| he|her|bir|er |an |ar|eri|ya | bi|ak |r h|eti|n |iye|yet| ka|as|n| ol|tle|eya|kk|ara|akk|etl|sn|esi|na |de |ek | ta|nda|ini| bu|ile|rn|rin|vey|ne |kla|e h|ine|r |ere|ama|dr|n h| sa|na|sin|e k|le | ge|mas|nd|nn| v| va|lan|lma|erk|rke|nma|tin|rle| te|nin|akl|a v|da | de|let|ill|e m|ard|en |riy|aya|n | h| a|e b|k v|kn|k h| me|mil|san| il|si |rd|e d|dan|hr|var|ana|e a|kes|et |mes|ah|dir| mi|ret|rri| se|ola|rr|irl|bu |mak| ma|mek|n e|k |n v|n i|lik|lle| ed| hi|n b|a h| ba|nsa| i|eli|kar| i| h|ala|li |ulu|rak|evl|e i|ni |re |r |eme|etm|e t|ik |e s|a b|i |n k|hai|nde|aiz| e|izd|un |olm|hi|zdi|ar |unm|ma | g|ilm|lme|im |n t|tir|dil|mal|e g|i v| ko|lun|e e|mel|ket|k |n s|ele|la |el |r v|ede|it|ili|ei|yla|a i| an|an| et|r |ahs| ya|s |edi|siy|t v|i b|se |ii|in|bul|ame| da|mi|may|tim|a k|tme|r b|ins|yan|nla|mle| di|eye|ger|ye |uu|erd|din|ser| m|mem|vle| ke|nam|ind|len|eke|es | ki|n m|it | in| ku|r|a s|ar| ay|eml|lek|oru|rme|kor|rde|i m| so|tr|al |lam|eni|nun| uy|ken|hs|i i|a d|ri |dev|n |a m|r a|mey|cak|yl|maz|e v|ece|ade|i |ma|mse|te |tn|ims|kim|e y| |end|k g|ndi|al| ce|lem|r|t|k i|r t| |bt|anl| b',pol:' pr|nie| i |ie |pra| po|ani|raw|ia |nia|wie|go | do|ch |ego|iek|owi| ni|ci|ci |a p|do |awo| cz|oc|ych| ma|ek |rze| na|prz| w |wo |ej | za|no|cz|zo|eni|wa | je|ow|i p|wol|oln| lu|rod| ka| wo|lno|wsz|y c|ma |ny |ka|ad|o d|stw|owa|dy |dy| wy|rzy|sta|ecz| sw|dzi|i w|e p|czn|twa|na |zys|w |szy|ub |lub|a w|est|kie|k m|wan| sp|aj| ws|e w|pow|pos|nyc|rac|spo|a |a i|cze|sze|neg|yst|jak| ja|o p|pod|acj|ne |st|aro|mi | z |i i|nar| ko|obo|awa| ro|i n|jc|zec|zne|zan|dow| r|iej|zy |zen|nic|ony|aw |i z|czy|no |nej|o s|rw|odn|cy |wn|odz|o w|o z|jeg|edn|o o|aki|mie|ien|kol| in|zie|bez|ami|es|owo|dno| ob| or| st|a s|ni |orz|o u|ym |st|tp|ec|jed|i k| os|w c|lwi|ez |olw|oe|po|cji|y w|o n|wia| be|kt|a j|zna|zyn|owe|wob|ka |wyc|owy|ji | od|aln|inn|jes|icz|h p|i s|si|a o|j |ost|kra|st |sza|swo|war|cza|roz|y s|raz|nik|ara|ora|lud|i o|a z|zes| kr|ran|ows|ech|w p|dw| p|pop|a n|tki|stk|gan|zon|raj|e o|iec|i l| si|e |eka| kt| de|em |tr|i |wni|lni|ejs|ini|odo|dni|en|kow|pe|a d|ron|dek|pie|udz|bod|nan|h i|dst|ieg|taw|z p|z w|ze|god|iu |ano|lar| to|y z|a k|ale|kla|trz|zaw|ich|e i|ier|iko|dzy|chn|w z|by |kw|adz|ekl|ywa|ju |och|kor|sob|ocz|oso|u p|du |tyc|tan|dz| mi|e s| ta|ki ',gax:'aa |an |uu | ka|ni |aan|umm|ii |mma|maa| wa|ti |nam| fi|ta |tti| na|saa|fi | mi|rga|i k|a n| qa|dha|iyy|oot|in |mir|irg|raa|qab|a i|a k|kan|akk|isa|chu|amu|a f|huu|aba|kka| ta|kam|a a| is|amn|ami|att|ach|mni|yaa| bi|yuu|yyu|ee |wal|miy|waa|ga |ata|aat|tii|oo |a e|moo| ni| ee|ba | ak|ota|a h|i q| ga| dh|daa|haa|a m|ama|yoo|a b|i a|ka |kaa| hi|sum|aas|arg|man| hu| uu|u n| yo| ar| ke| ha|ees| ba|uf |i i|taa|uuf|iin|ada|a w|i f|ani|rra|na |isu| ad|i w|a u|nya|irr|da |hun|hin|ess| ho| ma|i m|und|i b|bar|ana|een|mu |is |bu |f m| ir| sa|u a|add|aad| la|i d|n h|eeg|i h|sa |hoj|abu| ya|kee|al |udh|ook|goo|ala|ira|nda|itt|gac|as |n k|mum|see|rgo|uum|ra |n t|n i|ara|muu|ums|mat|nii|sii|ssa|a d|a q| da|haw|a g|yya|asu|eef|u h|tum|biy| mo|a t|ati|eny|gam|abs|awa|roo|uma|n b|n m|u y|a s|sat|baa|gar|n a|mmo|nis| qo|nna| ku|eer| to|kko|bil|ili|lis|bir|otu|tee|ya |msa|aaf|suu|n d|jii|n w|okk|rka|gaa|ald|un |rum| ye|ame| fu|mee|yer|ero|amm|era|kun|i y|oti|tok|ant|ali|nni| am|lda|lii|n u|lee|ura|lab|aal|tan|laa|i g|ila|ddu|aru|u m|oji|gum|han|ega| se|ffa|dar|faa|ark|n y|hii|qix|gal|ndi| qi|asa|art|ef |uud| bu|jir| ji|arb|n g|chi|tam|u b|dda|bat|di |kar|lam|a l| go|bsi|sad|oka|a j|egu|u t|bee|u f|uun',swh:'a k|wa |na | ya| ku|ya | na| wa|a m| ha|i y|a h|a n|ana|ki |aki|kwa| kw|hak| ka| ma|la |a w|tu |li |a u|ni |i k|a a|ila| ki|ali|a y|ati|za |ili|ifa| mt|ke | an|kil|kat|mtu|ake|ote|te |ka |ika|ma |we |a s|yo |fa |i n|ata|e k|ama|zi |amb|u a|ia |u w| yo|azi|kut|ina|i z|asi| za|o y|uhu|yak|au |ish|mba|e a|u k|hur|ha |tik|wat| au|uru| bi|sha|mu |ara|u n| as|hi | hi|ru |aif|tai|cha|ayo|a b|hal| uh| ch|yot|i h| zi|awa|chi|atu|e n|ngi|u y|mat|shi|ani|eri| am|uli|ele|sa |ja |e y|a t|oja|o k|nch|i a|a j| nc|ima| sh|ami| ta|end|any|moj|i w|ari|ham|uta|ii |iki|ra |ada|wan|wak|nay|ye |uwa| la|ti |eza|o h|iri|iwa|kuw|iwe| wo|fan| sa|she|bu |kan|ao |jam|wen|lim|i m|her|uto|ria| ja| ni|kam|di | hu|zo |a l|da |kaz|ahi|amu|wot|o w|si |dha|bin|ing|adh|a z|bil|e w|nya|kup|har|ri |ang|aka|sta|aji|ne |kus|e m|zim|ini|ind|lin|kul|agu|kuf|ita|bar|o n|uu |iyo|u h|nad|maa|mwe|ine|gin|nye|nde|dam|ta | nd|ndi|rik|asa| ba|rif|uni|nga|hii|lez|bo |azo|uzi|mbo|sil|ush|tah|wam|ibu|uba|imu| ye|esh| ut|taa|aar|wez|i s|e b| si|ala|dhi|eng|aza|tak|hir|saw|izo|kos|tok|oka|yan|a c|wal|del|i b|pat| um|ndo|zwa|mam|a i|guz|ais|eli|mai|laz|ian|aba|man|ten|zin|ba |nda|oa |u m|uku|ufu| mw|liw|aha|ndw|kuh|ua |upa| el|umi|sia',sun:'an |na |eun| ka|ng | sa|ana|ang| di|ak | ha|nga|hak|un |ung|keu|anu| ba| an|nu |a b| bo| je|a h|ata|asa|jeu|ina| ng|ara|nan|awa|gan|ah |sa |a k| na|n k|kan|aha|a p|a s|ga |ban| ma|a n|ing|oga|bog|sar| pa| ku|man|a a|ha |san|ae |bae|din|g s|aga|sah|ra |tan|n s| pe|ala| si|kat|ma |per| ti|aya|sin| at| pi| te|n a|aan|lah|pan|gar|n n|u d|ta |eu |ari|kum|ngs|a m|n b|n d|ran|a d|gsa|wa |taw|k h|ama|ku |ike|n p|eba|bas| ja|al |a t|ika|at |beb|kab|pik|asi|atu|nda|una|a j|nag|e b|n h|en |g k|oh |aba|ila|rta|aku|boh|ngg|abe|art|ar |n j|di |ima|um |ola|geu|usa|aca|sak|adi|k a|udu|teu|car|tin| me| ay|h k| po|eh |u s|aka|rim|ti |sac|k n|ngt|jen|awe|ent|u a|uma|teh|law|ur |h s|dan|bar|uku|gaw|aru|ate|iba|dil|pol|aja|ieu|ere|jal|nar| hu|n t|nya|pa |are|upa|mas|ake|ut |wan| ge|kal|nus| so|ngk|ya |yan|huk| du|tun| mi|mpa|isa|lan|ura|u m|uan|ern|ena|nte|rup|tay|n m| ke|ka |han|und|us |h b|kud|ula|tut| tu| ie|hna|kaw|u k|lak|gam|mna|umn|g d| nu|yun|ri |ayu|wat| wa|eri|g n|a u|i m|u p| ta|du |dit|umu|k k|ren|mba|rik|gta| be|ali|h p|h a|eus|u n|alm|il | da|sas|ami|min|lma|ngu|nas|yat|rak|amp|mer|k j|sab|mum| ra|rua|ame|ua |ter|sal|ksa|men|kas|nge|k d|ona| bi|bis|sio|ion|nal|taa| de|uh |gal|dip|we |bad',ron:' de|i | i|re | n|are|te |de |ea |ul |rep|le |ept|dre|e d| dr|ie |n |e a|ate|ptu| sa|tul| pr|or |e p| pe|la |e s|ori| la| co|lor| or|ii |rea|ce |au |tat|ai| a | ca|ent| fi|ale| a|a s| ar|ers|per|ice| li|uri|a d|al | re|e c|ric|n |i s|e o|ei |tur| s|lib|con|men|ibe|ber|rso|s |t|sau| ac|ilo|pri|i|i a|i l|car|l l|ter| in|ie|c |soa|oan|ii|l |tea|ri |a p| al|ril|e |an|in |nal|pre|i |uni|ui |se |e f|ere|i d|e |ita| un|ert|ile|t |a o| se|i |pen|ia |ele|fie|i c|a l|ace|nte|ntr|eni| c|al| ni|ire| d|pro|est|a c| cu| nu|n c|lui|eri|ona| as|sal|nd|na|ecu|i p|rin|in| su|r |e n| om|ici|nu |i n|oat|ri|l d| to|tor| di| na|iun| po|oci|tre|ni |ste|soc|ega|i o|gal| so| tr| p|a a|n m|sta|va | |fi |res|rec|ulu|nic|din|sa |cla|nd | mo| ce| au|ara|lit|int|i e|ces|uie|at |rar|rel|iei|ons|e e|leg|nit| f| m|a |act|e l|ru |u d|nta|a f|ial|ra | c| eg| | fa|i f|rt|tru|tar|i | |ion|ntu|dep|ame|i i|reb|ect|ali|l c|eme|nde|n a|ite|ebu|bui|t |ili|toa|dec| o |pli|v|nt |e r|u c|a |t |l |cu |rta|cia|ane|io|ca |it|poa|ci|mp|bil|r | st|omu||iu|rie|uma|mn| ma|ani|na|cur|era|u a|tra|oar| ex|t s|iil|ta |rit|rot|mod|tri|riv|od |lic|rii|eze|man|nv|ne |nv|a |cti',hau:'da | da|in |a k|ya |an |a d|a a| ya| ko| wa| a |sa |na | ha|a s|ta |kin|wan|wa | ta| ba|a y|a h|n d|n a|iya|ko |a t|ma |ar | na|yan|ba | sa|asa| za| ma|a w|hak|ata| ka|ama|akk|i d|a m| mu|su |owa|a z|iki|a b|nci| a| ci| sh|ai |kow|anc|nsa|a |a c| su|shi|ka | ku| ga|ci |ne |ani|e d|uma|ya|cik|kum|uwa|ana| du| y|an|ali|i k| yi|ada|as|aka|kki|utu|n y|a n|hi | ra|mut| do| ad|tar| a|nda| ab|man|a g|nan|ars|and|cin|ane|i a|yi |n k|min|sam|ke |a i|ins|yin|ki |nin|aa|ann|ni |tum|za |e m|ami|dam|kan|yar|en |um |n h|oka|duk|mi | ja|ewa|abi|kam|i y|dai|mat|nna|wa|n s|ash|ga |kok|oki|re |am |ida|sar|awa|mas|abu|uni|n j|una|ra |i b| u|dun|a |cew|a r|aba|un|ce |e s|a |san|she|ara|li |kko|ari|n w|m n|buw|aik|u d|kar| ai|niy| ne|hal|rin|bub|zam|omi| la|rsa|ubu|han|are|aya|a l|i m|zai|ban|o n|add|n m|i s| fa|bin|r d|ake|n |uns|sas|tsa|dom| ce|ans| hu|me |kiy|ar| am|in| an|ika|jam|i w|wat|n t|yya|ame|n |abb|bay|har|din|hen|dok|yak|n b|nce|ray|gan|fa |on | ki|aid| ts|rsu| al|aye| id|n r|u k|ili|nsu|bba|aur|kka|ayu|ant|aci|dan|ukk|ayi|tun|aga|fan|unc| lo|o d|lok|sha|un |lin|kac|ai|fi |gam|i i|yuw|sun|aif|aja| ir|yay|imi|war| iy|riy|ace|nta|uka|o a|bat|mar|bi |sak|n i| ak|tab|afi|sab',fuv:'de | e |e n|nde| ha|la |e e| ka|akk| nd| wa|ina|al |hak|na | in|ndi|kke|o |di |ii |ade|aad|um |ko |i h|ala| mu| ne|lla|mum|ji |wal| jo| fo|all|e| le|ne|e h|kal| ko|taa|re | ng|aaw|e k|aa |jog|e w|ley|ee |ke |laa|e m|eed|e l|nnd|aag|o|ol | ta|o k|gu |kee|le |waa|ond|gal|a j|ogi|am |eji|dee|m e|ti |nga|e d|e |awa|e | wo|gii|eej|ede|gol|aan| re| go|i e|agu|e t|ann|fot|eyd|oti|ee|pot| po|maa|naa|oto|ydi| he|i n|ni |taw|enn|een|dim|to |a i|e f|e j|goo|a k|der| fa| aa|ele| de|o n|dir| ba|er |ngu|oot|ndo|i k|ota|ima| sa|won|ay |ka |a n|oor|a f|ngo|tee| ja|i f| to|o f|e |i w|wa |ren|a e|nan|kam|hay|ma |ey|o t|awi|ye|ore|o e|too|and|fof|i m|a w|aa|e y|hee| do|eel|ira|nka|aak|e g|e s|l e|of |aar| e|dii| la|ani|e p|tin|a t| te| na|e i| so|o w|ral|e r|are|ooj|awo|woo|gaa| ma|u m|kaa|faw| a|dow| mo|oo | ya|aam|nge|nng| yi|und| ho|en |i l|so | mb| li|o i|e a| nj| o |ude|e b|o h|igg|i |lig|nda|ita|baa| di|iin| fe|iti|aa|ama|inn|haa|ii|a h| no|tii|den|tal| tu|tuu|yan|l n|yim|do |non|im|bel| je|ine| hu|njo|ugn|guu|no | da|edd|uug|mii|nee|jey|a d|ano| ke|lit|lli|go |je |ank|tde|amt|ent|ee|am| a|me|y g|aga|alt|a|ind|wit| su|nna| e|ree|de|i a|m t|ad|l h|ja|ago|ow |ete| u',bos:' pr| i |je |rav| na|pra|na |da |ma |ima| sv|a s|nje|a p| da| po|anj|a i|vo |va |ko |ja | u |ako|o i|no | za|e s|ju |avo| im|ti |sva|ava|i p|o n|li |ili|i s|van|ost| ko|vak|ih |ne |a u| sl|nja|koj| dr| ne|jed| bi|i d|ije|stv|u s|lob|im |slo| il|bod|obo| ra|sti|pri| je| su|vje|om |a d|se |e i| ob|a n|i i| se|dru|enj| os|voj|cij|e p|a b|su |o d|uje|u p|raz|i n|a o| od|lo |u o|ova|u i|edn|i u| nj|ovo|jen|lju|ni |oje|nos|a k|ran|dje|iti|o p|aci|av|a j|i o|e o|pre|pro|bra|nih|ji | ka|e d|jeg|og |sta| tr|tre|bud|u n|dr|u z|ra|bit|svo|ija|elj|reb|e b|mij|jem|avn|pos| bu|ka |aju| iz|ba |ve |rod|de |aro|e u|iva|a z|em |ti|ilo|eni|lje|i |red|bil|jel|jer| ni|odn|m i|du |tva|nar|gov| sa|oji| do|tu |vim|u d| st|o k|e n|a t|za |nim| dj| sm|ui|in|dna|i m|oda|vno|eba|ist|nac|e k|no|nak|ave|tiv|eu|nov|olj|sno|ani|aln|an |nom|i b|stu|nst|eno|oj |osn|a r|ovj|nap|smi|nog|ov|oja|nju|ara|nu |dno|ans|ovi|jan|edi|m s| kr|h p|tup| op| o|iko|jek|tvo| vj| mi|tel|vu |obr|iv|tit|o o|una|odu| mo| ov|kri|ego|din|rug|nik|rad|pod|nji|sam|sto|lja|dst|rim|ite|riv| te|m n|vol|i v|e t|vni|akv|itu|g p| ta|at|za|svi|ao |te |o s|ak |mje|a |odr|udu|kla|i t|avi|tno|ni| vr|nic|dni|u u|ina| de|oba|od |jih|st ',hrv:' pr| i |je |rav|pra|ma | na|ima| sv|na |ti |a p|nje| po|a s|anj|a i|vo |ko |da |vat|va |no | za|i s|o i|ja |avo| u | im|sva|i p| bi|e s|ju |tko|o n|li |ili|van|ava| sl|ih |ne |ost| dr|ije| ne|jed|slo| ra|u s|lob|obo| os|bod| da| ko|ova|nja|koj|i d|atk|iti| il|stv|pri|om |im | je| ob| su| ka|i i|i n|e i|vje|i u|se |dru|bit|voj|ati|i o|en|a o|o p|a b|a n|ui| se|enj|sti|a u|edn|dje|lo |av| mo|raz|u p| od|ran|ni |rod|a k|su |aro|dr|svo|ako|u i|ra|a j|mij|ji |nih|eni|e n|e o| nj|pre|pos|iv|oje|eno|e p|nar|oda|nim|ovo|aju|ra |i |og |nov|iva|a d|nos|bra|bil|i b|avn|a z|jen|e d|ve |ora|tva|jel|sta|mor|u o|cij|pro|ovi|za |jer|ka |sno|ilo|jem|red|em |lju|osn|oji| iz|aci| do|lje|i m| ni|odn|nom|jeg| dj|vno|vim|elj|u z|o d|rad|o o|m i|du |uje| sa|nit|e b| st|oj |tit|a |dno|e u|o s|u d|eu|ani|dna|nak|nst|stu| sm|e k|u u|an |gov|nju|ju|aln|m s|tu |a r|ov|jan|u n|o k|ist|u |te |tvo|ans|ti|nu |ara|nap|m p|ni|olj|bud| bu|edi|ovj|i v|pod|sam|obr|tel| mi|ina|za|e m|at| vj|ona|nji|jek| ta|du|ija| o|tup|h p|oja|smi|ada| op|oso|una|sob|odu|dni|rug|udu|ao |di |avi|tno|jim|itu|itk|e |odr|ave|me|nog|din|svi| i|kak|kla|rim|akv|elo|tv|ite|vol|jet|op|pot|tan|ak |nic|nac|ue| sk| me|ven',nld:'en |de |an | de|van| va| en| he|ing|cht|der|ng |n d|n v|et |een| ge|ech|n e|ver|rec|nde| ee| re| be|ede|er |e v|gen|den|het|ten| te| in| op|n i| ve|lij| zi|ere|eli|zij|ijk|te |oor|ht |ens|n o|and|t o|ijn|ied|ke | on|eid|op | vo|jn |id |ond|in |sch| vr|aar|n z|aan| ie|rde|rij|men|ren|ord|hei|hte| we|eft|n g|ft |n w|or |n h|eef|vri|wor| me|hee|al |t r|of |le | of|ati|g v|e b|eni| aa|lle| wo|n a|e o|nd |r h|voo| al|ege|n t|erk| da| na|t h|sta|jke|at |nat|nge|e e|end| st|om |e g|tie|n b|ste|die|e r|erw|wel|e s|r d| om|ij |dig|t e|ige|ter|ie |gel|re |jhe|t d| za|e m|ers|ijh|nig|zal|nie|d v|ns |d e|e w|e n|est|ele|bes| do|g e|che|vol|ge |eze|e d|ig |gin|dat|hap|cha|eke| di|ona|e a|lke|nst|ard| gr|tel|min| to|waa|len|elk|lin|eme|jk |n s|del|str|han|eve|gro|ich|ven|doo| wa|t v|it |ove|rin|aat|n n|wet|uit|ijd|ze | zo|ion| ov|dez|gem|met|tio|bbe|ach| ni|hed|st |all|ies|per|heb|ebb|e i|toe|es |taa|n m|nte|ien|el |nin|ale|ben|daa|sti| ma|mee|kin|pen|e h|wer|ont|iet|tig|g o|s e| er|igd|ete|ang|lan|nsc|ema|man|t g|is |beg|her|esc|bij|d o|ron|tin|nal|eer|p v|edi|erm|ite|t w|t a| hu|rwi|wij|ijs|r e|weg|js |rmi|naa|t b|app|rwe| bi|t z|ker|ame|eri|ken| an|ar | la|tre|ger|rdi|tan|eit|gde|g i|d z|oep',srp:' pr| i |rav|pra| na|na |ma | po|je | sv|da |a p|ima|ja |a i|vo |nje|va |ko |anj|ti |i p| u |ako|a s| da|avo|i s|ju |ost| za|sva|o i|vak| im|e s|o n|ava| sl|nja| ko|no |ne |li |om | ne|ili| dr|u s|slo|koj|a n|obo|ih |lob|bod|im |sti|stv|a o| bi| il| ra|pri|a u|og | je|jed|e p|enj|ni |van|u p|nos|a d|iti|a k|edn|i u|pro|o d|ova| su|ran|cij|i i|sta|se | os|e i|dru| ob|i o|rod|aju|ove| de|i n| ka|aci|e o| ni| od|ovo|i d|ve | se|eni|voj|ija|su |u i|av|avn|uje| st|red|m i|dna|a b|odi|ara|dr|ji |nov|lju|e b|ra|tva|to|u o|oja| ov|a j|odn|u u|jan|po|jen| nj|nim|ka |ot|du |raz|a z| iz|sno|o p|vu |u n|u d|ti|osn|e d|pre|u z|de |ave|nih|bit|aro|oji|bez|tu |gov|lje|in| sa|lja|svo|lo |za |vno|e n|eu| tr|nar| me|vim|no|oda|ani|en|nac|nak|an |to |tre|at| kr|stu|nog|o k|m s|tit|aln|nom|oj |pos|e u|reb| vr|olj|dno|iko|ku |me |nik| do|ika|e k|jeg|nst|tav|em |i m|sme|o s|dni|bra|nju|en|ovi|tan|te |avi|vol| li|za|ilo|rug|var|kao|ao |riv|tup|st |iv|ans|eno|ov|tv|kla|vre|bud|ena| ve|ver|odu|me|oju|ut| bu|kom|kri|pod|ru|m n|i b|ba |a t|ugi|edi| mo|la |u v|kak| sm|ego|akv|o j|rad|dst|jav|del|tvo| op|nu |por|vlj|avl|m p|od |jem|oje| o|a r|sam|i v|ere|pot|o o|te|rem|vek|svi| on|rot|e r',ckb:' he|  |n | bi| ma|in |na | di|maf|an |ku | de| ku| ji|xwe|her| xw|iya|ya |kes|kir|rin|iri| ne|ji |bi |yn|af|e b|de |tin|e h|iy|ke |es |ye | we|er |di |we | d|i b| be|erk|ina| na| an| |y |eye| y|k |rke|n |diy|ete|eke|ber|hem|hey| li| ci|wek|li |n d|f | b| te|ne |y | se|net|r |tew|yek|sti|af | ki|re |yan|n b|kar|hev|e k|aza|n |w | ew|i h|n k| b| b| mi| az|dan| w|ek| a|a m|zad|e d|mir|bin|est|ara|iro|nav|ser|a w|adi|rov|n h|an|t |ewe|be |ewl|ev |m | ya|t |ta |em| y|ast|wle| t|n m| bo|wey|s m|bo | tu|n j|ras| da| me|din| d| h|n n|n w|ing|st | ke| ge|n |ar | p|iye|na|bat|r k|ema|cih| b|wed| m|d | a|vak| t|ekh|par| ye|v |civ|n e|ana| h| k|khe|geh|nge|na|fn|ane|av | m|bik|ey|ey|e | re|man|erb|a x|v | m|iva|e n|h |bn|k | pa|er|j |end| ta|ela|nn|n x|a k|ika|f |f h| n|ari|m |a s|e j|eza|tn|nek| ni|ra |eh|tiy|n a|bes|rbe| h|rwe|zan| a |erw|ov |in|ama|ek |nn|b |ov|ike|a n| ra|riy|i d|an| d|e e|et| x|yet|aye| j|tem|e t|erd|i n|eta|ibe|a g|u d|xeb|at|i m|tu | wi|dew|mal|let|nda|ewa| n|awa|e m|a d|mam|han|u h|a b|p|ere| ba|lat|ist| za|bib|uke|tuk|are|as|rti|ar|i a|hn| h|edi|nn|an|qan| qa| hi| e|ine|n l|mn|n |e a',yor:'ti | n| | |n | l|n |on| |wo|n | e|kan|an |t | t|t| k| |t| w| t| |t|en|b |ti|lt|ti| gb|l|se| l|  |wo|gbo|n|n l| a | t| |ra | s|n t|k|s |t |ka|k|y|o | s|l|or|ni |yn|d || k| |d| or|n |rl|| |j|d|b|||tb|n | |n | t| l|jo| ti|e | t| wo|ny| | n| j| s|l |k |n |w| b|n n|s | f| s| a|r|fn| p| m|ni|gb| k| n|n|in |m| |ba |nir|p |ira|mn|ni|n o|rn|gb| g|b |e | r| n|k |n e|un |gba| p| |n | o|nn|gb|y | ka|n|a k|fi | fi|mo|b|od|d|d| s|i l| o| |w | i|i |hun|b |i |d |bo|om|mo|w|bo | | k| j|l|gb|ohu| oh| b| |b |ara|y|ogb|r|n s| | b|p| k| l|bog|i t| t| |y|k|g| l|n|r |l | y| | e|a w| y|r| f| w| l| t| b|i n|w|gb|y | w|k| a|l|wj|b|i |jo|fin|n|n k| e|i j| | k|fi| f| ar|i s|m|r| m| ir|rin|n| n|j | b| y| t|| i | m|f|kn|r | | n|w |s| | m| t|y| g|k|d|d|w|k| d|ir| o|i o|i |l| n|pa| k|np| m|a l|k|b |i g|de |b|n |by||gb|w|ng|m |lb| |n f|s| w|n |i a|ay|y| y|m| | ni|n b| w|je| j|gb|n|g',uzn:'lar|ish|an |ga |ar | va| bi|da |va |ir | hu|iga|sh |uqu|shi|bir|quq|huq|gan| bo| ha|ini|ng |a e|r b| ta|lis|ni |ing|lik|ida|ol|ili|ari|nin|on |ins| in|adi|nso|son|iy | o|lan| ma|dir|hi |kin|har|i b|ash| yo|bo| mu|dan|uqi|ila|ega|qla|r i|qig|oz| eg|kla|a b|qil|erk|ki | er|oli|nli|at | ol|gad|lga|rki|oki|i h|a o| qa|yok|lig|osh|igi|ib |las|n b|atl|n m| ba|ara| qi|ri | sh|iya|ala|lat|in |ham|bil|a t|a y|bos|r h|siy|n o|yat|inl|ik |a q|cha|a h| et|eti|nis|a s|til|ani|h h|i v|mas|tla|osi|asi| qo|li|ati|i m|rni|im |uql|arn|ris|qar|a i|gi | da|n h|ha |sha|i t|mla|rch| xa|i o|li |hun|bar|lin|z |arc|rla| bu|a m|a a| as|mum| be| tu|aro|r v|ikl|lib|ta|h v|tga|tib|un |lla|mda| ke|shg| to|n q|sid|n e|mat|amd|shu|hga| te|tas|ali|umk|oya|hla|ola|aml|iro|ill|tis|iri|rga|mki|irl| ya|xal|dam| de|gin|eng|rda|tar|ush|rak|ayo| e| so|ten|alq| sa|ur | is|imo|r t| ki|mil| mi|era|zar|hqa|aza|k b| si|nda|hda|kat|ak |or|n v|a k|or |rat|ada|lg|miy|tni|i q|shq|oda|shl|bu |dav|nid|y t|ch |asl|sos|ilg|aso|n t|atn|sin|am |ti |as |ana|rin|siz|yot|lim|uni|nga|lak|n i|a u|qon|i a|h k|vla|avl|ami|dek| ja|ema|a d|na | em|ekl|gi|si |i e|ino| ka|uch|bor|ker| ch|lma|liy|a v|ti|lli|aka|muh|rig|ech|i y|uri|ror',zlm:'an |ang| ke| se|ng | da|dan|ada|ara| pe|ak | be|ran|ber| me|ah |nya|hak|per|n s|ata|ala|ya |a s|kan|asa|n k|lah| di|da |aan|gan|nga|dal| ma|n d|erh|eba|rha|a p| ha|kep|pad|yan| ya|ap |ama| ba|nda| te|ra |tia|man|eng|a b|a d|ora|men|n p|ter|iap|san|epa| or|pen|eti| ad| at|a a|n a|set|tan|h b|tau|sia|n t|apa|dak|pa |sa |au |ta |ela|bas|at | sa|n b|beb|n m|keb|h d|p o|end|ega|aka|a k|am |sam|gar|ana|leh|lam|ole| un|neg|k k|ban|g a|di |n y|eh |a m|eri|aha|han| ti|a t|ma |any|uan|seb|ebe|ngs|atu|mas|bag|car|mem|ing|ian| ne|kes|i d|gsa|ia |ika|mat|agi|ert| de| la|emb|und|nan|asi|emu|ers|epe|na |anu|gi |ung|erk|n h|ngg|tu |ind|pem|i m|g b|kla| in|iha|pun|i s|erl|akl|era|as |dap|eca|sec|al |k m|bar|nus|usi|lan|tin|si |awa|nny| su|bol|sas| as|ini|rta|rat|ena|sem|aya|ni |den|g m|g t|kem|i k|adi|ai |ti | ap| ta|in | he| bo|had|uka|tar| an|hen|ann|ain|ka |rka|ri |ema|k h|n i|g s|dia|dun|ira|rsa|elu|nta|a n|mel|iad|uk |mpu|ua |har|kat|aga|lai|enu|ses|emp|ntu|k d|ent|un |mba|rma|jua|uat|k a|mar|rak|h m|ila|lua|i a|aja|ker|dil|g d|uma|rli|lin|esi|sua|nak|ndu|l d| pu|t d|erm|ser|ar |ese|ati|tuk|rga|i p|dar|esa|bah| ol|ari|ngk|ant|sek|gam|raa|mbe|ida|sat|iri|kea|i b|saa|dir|g u|erj|tik|unt|eka|rja',ibo:'a n|e n|ke | na|na |  | b| n |nwe|ere| b|re |nye| nk|ya |la | nw| ik| ma|ye |e |ike|a o|nke|a m| n| ya|a |ma |bl|la| on| a |e i|kik|iki|ka |ony|ta |b |kwa| nd|a i|i n|di |a a|wa |wer|do | mm|d |e a|ha | ga|any| ob|ndi| ok|he |e m|e o|a e| n|ite|r |hi |mma|ga|wu |ara| d|aka|che|oke|we |o n| ih|n o|ad|mad|obo|bod|a g|odo| ka| ez|te |h |be |ta|d | an|zi | oh|ae|akw|gba|i m|me | ak|u n|nya|ihe|ala|ohe|ghi|ri | z|her|ra |weg| nt| iw| mb|ba |pt| si|ro |oro|iwu|chi|aa|r | i| | eb|iri|ebe|r|z | in|a y|ezi|e |kpa|le |ile|r|n e|kpe|mba| ha|bi |sit|e e|inw|nil|as| en|mak|a u| ni|ap|ch|i i|gh|i |i o|si | e |ide|o i|e y| m|a s|u o|kwu|ozu|yer|ru |enw| o|z|gid|h |n a|ah|nkw|sor|egh|edo|a |tar|n i|toz| o|pa |i a| me|ime|uru|kwe| mk|tu |ama|eny|uso|de | im| d|osi|hed|a d| kw|mkp|wet| r| n|obi|r| k| to|gas| ch|ch|nha|n|nd| nc| al|n | m| us|n |u |nch| o |eta|n u| ot|otu|sir|sr| nh|a k|ali|o m| ag| gb|e s|ta|nwa| n|lit|ega|ji |d|e k|ban|e g| k|esi|agb|eme|hu |ikp|zu |pe |nta|na|ch|u a|a b|uch|n |onw|ram|kw|ek|i e| n| ug|ch|u m|gwu|a h|zz|ugw|meg| e|nat|e h|dg|o y|kpu|pr|cha|z |hc|ich| ng|ach| og|wap|wan|gh|uwa| di| nn|i ',ceb:'sa | sa|ng |ang| ka|an | pa|ga | ma|nga|pag| ng|a p|on |kat|a k|ug |od | ug|g m| an|ana|n s|ay |ung|ata|ngo|a m|atu|ala|san|ag |tun|g s|g k|god|d s|a s|ong|mga| mg|g p|n u|yon|a a|pan|ing|usa|tan|tag|una|aga|mat|ali|g u|han|nan| us|man|y k|ina|non|kin| na|syo|lan|a b|asa|nay|n n|a i|awa| ta|taw|gaw|nsa|a n|nas| o |ban|agp|isa|dun|was|iya| gi|asy|adu|ini|bis| ad|ili|o s| bi|g a|nah|nag|a t| ki|lin|lay|ahi|sam|al |wal| di|nal|asu| ba|ano|agt| wa|ama|yan|a u| iy|kan|him|n k|gan|ags|n a|kag| un|ya |kas|gpa|g t| su|aha|wha|agk|awh|gka|a g|kal|l n|gla|gsa|sud|gal|imo|ud |d u|ran|uka|ig |aka|aba|ika|g d|ara|ipo|ngl|g n|uns|n o|kau|i s|y s|og |uta|d n|li | si|gik|g i|mta|ot |iin| la| og|o a|ayo|ok |awo|aki|kab|aho|n m|hat|o p|gpi|a w|apa|lip|ip | hu| ga|a h|uba|na | ti|bal|gon|la |ati|wo |ad |hin|sal|gba|buh| bu| ub|uha|agb|hon|ma |nin|uga|t n|ihi| pi|may| pu|mak|ni | ni|d a|pin|abu|agh|ahu|uma|as |dil|say| in|at |ins|lak|hun|ila|mo |s s|sak|amt|o u|pod|ngp|tin|a d|but|ura|lam|aod|t s|bah|ami|aug|mal|sos|os |k s| il|tra| at|gta|bat|aan|ulo|iha|ha |n p| al|g b|lih|kar|lao|agi|amb|mah|ho |sya|ona|aya|ngb|in |inu|a l| hi|mag|iko|it |agl|mbo|oon|tar|o n|til|ghi|rab|y p| re|yal|aw |nab|osy|dan',tgl:'ng |ang| pa|an |sa | sa|at | ka| ng| ma|ala|g p|apa| na|ata|pag|pan| an| at|ay |ara|ga |a p|tan|g m|mga| mg|n n|pat| ba|n a|aya|na |ama|g k|awa|kar|a k|lan|rap|gka|nga|n s|g n|aha|g b|a a| ta|agk|gan|tao|asa|aka|yan|ao |a m|may|man|kal|ing|a s|nan|aga| la|ban|ali|g a|ana|y m|kat|san|kan|g i|ong|pam|mag|a n|o a|baw|isa|wat| y |lay|g s|y k|in |ila|t t| ay|aan|o y|kas|ina|t n|ag |t p|wal|una|yon| o | it|nag|lal|tay|pin|ili|ans|ito|nsa|lah|kak|any|a i|nta|nya|to |hay|gal|mam|aba|ran|ant|agt|on |t s|agp| wa| ga|gaw|han|kap|o m|lip|ya |as |g t|hat|y n|ngk|ung|no |g l|gpa|wa |lag|gta|t m|kai|yaa|sal|ari|lin|a l|pap|ahi| is| di|ita| pi|pun|agi|ipi|mak|a b|y s|bat|yag|ags|o n|aki|tat|pah|la |gay|hin| si|di |i n|sas|iti|a t|t k|mal|ais|s n|t a|al |ipu|ika|lit|gin| ip|ano|gsa|alo|nin|uma|hal|ira|ap |ani|od |i a|gga|y p|par|tas|ig |sap|ihi|nah|ini| bu|ngi|syo|o s|nap|o p|a g| ha|uka|a h|aru|a o|mah|iba|asy|li |usa|g e|uha|ipa|mba|lam|kin|kil|duk|n o|iga| da|dai|aig|igd|gdi|pil|dig|pak| tu|d n|sam|nas|nak|ba |ad |lim|sin|buh|ri |lab|it |tag|g g|lun|ain|and|nda|pas|kab|aho|lig|nar|ula| ed|edu| ib|git|ma |mas|agb|ami|agg|gi |sar|i m|siy|g w|api|pul|iya|amb|nil|agl|sta|uli|ino|abu|aun|ayu| al|iyo',hun:' sz| a |en | va|s | s|min|ek | mi| jo|jog|ind|an |nek|sze|sg| az|gy |sza|nde|ala|az |den|a v|val|ele| el|oga|ml|egy| eg|n a|ga |zab| me|zem|em|aba|int|van|bad|tel|tet| te|ak |ts|ny|t a| ne|gye|ly|tt |n s|ben|sg|zet|lam|meg|nak|ni | se|ete|sen|agy|let|lyn|s a|yne|ra |z e|et | al|mel|kin|k j|et|ok |tek| ki|vag|re |n m|oz |hoz|ez |s s|ett|gok|ogy| k|mbe|es |em |nem|ely| le|ell|emb|hog|k a|at|kz|nt | ho|yen|hez|el |z a|len|ds|s|ts|ads|k m| l| em|a s|nte|a m|szt|a t|ll|s |y a|ogo|sem|a h|enk|nye|ese|nki|go|t s|lap|ame|ber|l |k |nyi|ban|mn|s e|i m|t m| v|lla|ly |be|lat|g |ami|on |mze|n v|emz|fel|a n|l |a a|eki|eri|yes| cs|lle|tat|el|nd |i |g |s|lis|yil|vet|t |kl|rt| ke|te|rs|l a|het|szo|art|al| ny|tar|koz| am|a j|sz|enl|el|l |s k|tr|s |le|s t|lem|st|ges|ott| fe|n k|tko|zs|t |kel|ja | ha|al|zs|nl|se|ot |ri |lek|ms|t |vel|i j|se |ehe|tes|eve|ss|tot|t k|olg|eze|i v|za|leh|n e|l |tte|os |ti |atk|zto|e a|tos|ny|na|zte|fej|del|rs|k k|kor|ge|sz|t n| bi|zat|vd|nev|elm|de|zer|tb|biz|rra|ife|izt|ere|at |ll |k e|ny |sel| n|ba|lt |ai |sl|hz|kif|t e| ar|leg|d a|is |i e|arr|t t|so|it |et|al | m|t v| b|br|a |es|lye|m l| es|nyo',azj:' v|v |r |lar| h|in |ir | ol| h| bi|hq|qu|quq|na |lr|d |hr| |bir|an |lik| t|r b|mal|lma|as|ini|r h|xs|x|n |ar|qla|a m|dir|aq |uqu|ali| ma|una|il|n |yt| ya|ara|ikd|ri|ar |si|ti|r |rin|yy|n h| az|dn|nin|r|tin|iyy|mk|zad| m|sin| m|ni |nda|t |nd|aza|rn|n |n| a|i v|nn|olu|qun| qa| et|ilm|lq| y|k |lm|l |kdi|ind|na|olm|lun|mas|xs |sn| b| in|n m|q v|n |mi|n t|ya |da | b|tm|dl|adl|br| on|ya| h|s |nun|maq|dan|in|etm|un | v|rl|n b|si |raq| va| m|n a|nd|r |an| z|ra|nma|n i|ama|a b|irl|ala|li |ins|bil|ik | al| di|| d|lt|il |l| i|q |n |nla|dil|md|n v| e|unm|al| s|xsi| o|uq |uql|nsa|tl| d|ili|da|asi| he|ola|san|ni|ms| da|lan| bu|tr|hm|dr|kil|i |u v| ki|min|eyn|mi |yin| ha|sos|he|bu |e | ed|kim|l|alq|xal| as|sia|osi|r v|q h|r |yan|i s| s|daf|afi| i| h|fi| ta| q|ql|a q|yar|sas|l |ill|mil|sa|liy|tl|siy|a h|mz|tn| t| is|ist|iyi| so|n |al |ifa|ina|ld| o|d|m|r |d|ial| mi|yi|miy|n|n e|iya|edi| c| b|bt|t|xil||mn|ad|t v|a v|axi|dax|r a|onu| |se| n| se|man|ril|sil|z |i |z |l|aya|qan|i t|r|tm|ulm|rf|mh| xa|n| d| ni|sti|ild|am|qu |nam|n o|n d|var|ad |zam|tam|th',ces:' pr| a |n | ne|pr|rv|ost| sv| po|na |ho |ch | na|nos|o n|n| ro|ti |neb|vo |m |vo|ebo|ka|ad| ka|ou | m|bo | za| je| p|d|d |svo|a s|sti| st| p| v |obo|vob|bod| sp| z|pro|rod|ch|vn|ho| by| m|en|n | n|spo|ov|o p|ter|mi |n | a|roz|to |a p|by |jak|nr|ro| li| ja|a z| p|i a| v|lid|kte|ny |u p|o v|m |odn|at |mu | vy| ma| so|li |zk| kt|kla| n|tn|a v|v |oli|pod|m |en |je | do|st|byl|t s|do |em |va|pol|bt| b|o s| ve|ve| s|it | b|in|rov|dn|tv| se| k |t |vol|sou|a n|ejn|nou|se |ran|nc|nes|stn|ci |i s|v |m |kol|p|ova|ch|en|du |en|stv|e s|mez|sv|aj|tt|k |u s|jeh|eho|nm|va |nm|ech|er|o z|maj| ze|ole| i |mu|i v|y s|ids|kon|hra|nu |ave| v| to|m p|o d|i n|len|pra|chn|esm|e | ta| ni| os|vat|sta|dsk|st | e|ovn|rac|lad|i p|chr|aby|m a| ab|ako|ak|nh|sob|sm|v |bez|dy |en|ln| m|vou|le|a m|t v|ln| ji|pi|ln|oci|rav|i k|mi| i|ens|odu|m n| s |j |kl|zem|kdo|och| oc|ste| vz|ven|ky |oko|tej|jin|slu|ivo|zen|inn|sk|y b|zac|a j|vd|ezi| me|nez|u a|sk|stu|a o|oln|il|nit|s|nc| z|u k|pln| tr|u o|sv|nik|ikd| od|oe|anu|vin|i j|cho|aci|dl| pl|v|a t|odi| k| vo|adn|est|tup| mu|obe|ve |din|od|h n|u v|nem|por|hov|no|kh| v|tak|jno',run:'ra |we |wa | mu|e a|se | n |a k|ira|ntu|tu | ku| um|ko |a i|mu |iri|mun|hir|ye |unt|ing|ash|ere|shi|a n|umu|zwa| bi|gu |ege|a a|za |teg|ama|e k|go |uba|aba|ngo|ora|o a|ish| ba| ar|ung|a m| we|e n|na |sho|ese|nga| ab|e m|mwe|ugu| kw|ndi| gu|ate|kwi|wes|riz|ger|u w| at|di |gih|iza|n u|ngi|ban|yo |ka |e b|a b| am| ca|ara|e i|obo|hob|ri |u b|can|nke|ro |bor| in|bah|ahi|ezw|a u|gir|ke |igi|iki|iwe|rez|ihu|hug|aku|ari|ang|a g|ank|ose|u n|o n|rwa|kan| ak|nta|and|ngu| vy|aka|n i|ran| nt| ub|kun|ata|i n|kur|ana|e u| ko|gin|nye|re | ka|any|ta |uko|amw|iye| zi|ga |ite| ib|aha| ng|era|o b|ako|o i| bu|o k|o u|o z| ig|o m|ho |mak|sha| as| iv|ivy|n a|i b|izw|o y| uk|ubu|aga|ba |kir|vyi|aho| is|nya|gan|uri| it| im|u m|kub|rik|hin|guk|ene|bat|nge|jwe|imi| y |vyo|imw|ani|kug|u a|ina|gek|ham|i i|e c|ze |ush|e y|uru|bur|amb|ibi|agi|uza|zi |eye|u g|gus|i a| nk|no |abi|ha |rah|ber|eme|ras|ura|kiz|ne |tun|ron| zu|ma |gen|wo |zub|w i|kor|zin|wub|ind| gi|y i|ugi|je |iro|mbe| mw|bak| ma|ryo|eka|mat| ic|onk|a z| bo|ika|eko|ihe|ukw|wir|bwa| ry| ha|bwo| ag|umw|yiw|tse| ya|he |eng| ki|nka|bir|ant|aro|gis|ury|twa| yo|bik|rek|ni | ah| bw|uro|mw |tan|i y|nde|ejw| no|zam|puz|ku |y a|a c|bih|ya |mur|utu|eny|uki|bos',plt:'ny |na |ana| ny|y f|a n|sy |aha|ra |a a| fa|n n|y n|a m|an | fi|tra|any| ma|han|nan|ara|y a| am|ka |in |y m|ami|olo| ts|lon|min| mi| sy| na|a t| ol|fan| ha|a i|man|iza| iz|ina|ona|y h|aka|o a|ian|a h|reh|etr|a s|het|on |a f|ire|fah|tsy|mba| ar| hi|zan|ay |ndr|y o|ira|y t| an|ehe|o h|afa|y i|ren|ran| zo|ena|amb|dia|ala|amp|zo |ika| di|tan|y s|y z| az|ia |m p|rin|jo |n j| jo| dr|zy |ry |a d|ao |and|dre|haf|nen|mpi|rah| ka|eo |n d| ir|ho |am |rai|fa |elo|ene|oan|omb| ta| pi| ho|ava|azo|dra|itr|iny|ant|tsi|zon|asa|tsa| to|ari|ha |a k|van|n i|fia|ray| fo|mbe|ony|sa |isy|azy|o f|lal|ly |ova|lom| vo|nat|fir|sam|oto|zay|mis|ham|bel| ra|a r|ban|kan|iha|nin|a e|ary|ito| he| re| no|ita|voa|nam|fit|iar| ko|tok|isa|fot|no |otr|mah|aly|har|y v|y r| sa|o n|ain|kam|aza|n o|oka|ial|ila|ano|atr|oa | la|y l|eri|y d|ata|hev|sia|pia|its|reo| ao|pan|anj|aro|tov|nja|o s|fam|pir| as|ty |nto|oko|y k|sir|air|tin|hia|ais|mit|ba | it| eo|o t|mpa|kon|a z|a v|ity|ton|rak|era|ani|ive|mik|ati|tot|vy |hit|hoa|aho|ank|ame|ver|vah|tao|o m|ino|dy |dri|oni|ori| mo|hah|nao|koa|ato|end|n t| za|eha|nga|jak|bar|lah|mia|lna|aln|va | mb|lan| pa|aov|ama|eve|za |dro|ria|to |nar|izy|ifa|adi|via|aja| va|ind|n k|idi|fiv|rov|vel',qug:'una|ta | ka|na |ka |ash|cha|a k|ari|ish|kun|kta|ana|pak|hka|shk|apa|mi |ach|hay|akt|shp|man|ak | ch| ha|rin|ata|tak|lla|ita|ami|ama|aku|har| pa|pas|ay|yi|ina| ma| ru|uku|sh |hpa|run|all|kuy|aka|an | tu|tuk|yta|chi|chu|a c|it|in |nak|a h|nka|ris|tap|kan| ki|ayt|pi | sh|pa |i k|a p|nap|kam|kaw|pay|nam|ayp|aws|iri|wsa|a s|ank|nta|uy |a t|hin|a m|ay | li|ant|lia|kay|nat|a r|shi|iak|lak|uya| wa|yuy|say|kis|y r|ypa|hun|a a| yu|n t|tam| ti|yay|n k| ya|a w|hpi|lli| al|api|yku|un |ipa|a i|iku|ayk|shu| sa|ush|pir|ich|kat|hu |huk| il|ill|kas|a y|rik|yac|a l| ku|kac|hik|tan|wan|ypi|ink|ika| ni|ila|ima|i c|yll|ayl| wi|mac|nis| ta|i y|kus|tin|n s|i p|yan|llu|la |iks|tik|kpi| pi|awa|may|lan|li | ri|kll|yas|kin|kak|aya|ksi|k h|aym|war|ura| ay|lat|ukt|i t|iya|ull|mas|sha|kir|uch|h k|nch|akp|uma|pip|han|kik|iki|riy|aki| ii|i s|n p|h m|kar|nal|y h|tac| su|nac|mak|n m|nki|k a|mam|iwa|k t|k k|i m|yma| a|wil|asi|nmi|kap|pal|sam|pam|k i|k l|i i|pan|sum|i w| hu|his| mu|iia|mun|k m|u t|pik|was|ik |ma |hat|k r|akl|huc| im|mal|uyk|imi|n y|anc|y k|a n|ii| i|wak|unk|yka| mi|ia|a u|has|ywa| ak|llp|ian|ha |tar|rmi|i a|arm|las|ati|pur|sak|ayw|hap|yar|uti|si |iyt|uri|kim| ar|san|h p|akk|iy |wat|wpa|y i|u k',mad:'an |eng|ban|ng | sa| ka|dha| ba|ren|ak |ang| se| ha|hak| dh|na | pa|se |adh|a s|aba|n s|ara|ngg|are|ha |aga|sa | or|ore|asa|sar|ana| ma|aan|a k|ale|gi | ag|gad|a b|n o|n k|eba|ala|ra |gan| ke|dhu|ota|aja|bas|n b|ka |man|tab|dhi|beb|sab|ama|ako|abb|at |ggu|nga| ta|pan|wi |huw|uwi|eka|ata|a d|san| ot|agi|lak|hal|ba |bba|i h|ong|em |kab|g a|lem|a o| pe| na|ane|par|ngs|nge|gar|a a|tan|gsa|a p|ran|i s|k h|n p|uy |guy|ken|n a|al |ada| ga|apa|pon|e d| e |nek| an|g s|ta |kaa|on |kal|a m|ssa|ona|abe|kat| la|a e|e e|sal|ate|jan|ri |nan|lab|asi|sad|i p|e a|lan|aka|a h|ari| bi|ena|si |daj| ng|ton|e k|har|oss|gen|i k|g k|car|ase|ano|era|kon| be|nya|n d|nag|bad|ar |epo| da|mas| kl| al|n t|mat|nos|n n|ela|g e|a n|k k|uwa|adi|pad|ggi|uan|i d|ne | so|hi |sae|oan|wan|as |le |gap|ter|yat|om |kla|k a|e b|ina|ah |k s|koa|i a|ega|neg|n h|m p|aha| as| ja|abi|ma |kas|bi | mo|aon| di|one| ep|per|aya|e s|nto|te |bat|epa|nda|n e| ca|int|pam|di |ann| ra|aen|k d|amp|a t|nta|and|e p|rga|pen|yar|mpo|ste|dra|ok |oko|ila|g p|k b|i b|set|to |isa|nao|nna|n m|ett| a |bis|hid|bin|i m|nas| ho|kar|t s| po|dil| to|aju|ika|kom|arg|ant|raj|a l|das|tto|ost|mos|lae|ga |rek|idh|tad|hig|en |rny|arn|ndh|eta|adu| dr|jat|jua|gam',nya:'ndi|ali|a k|a m| ku| nd|wa |na |nth| mu| al|yen|thu|se |ra |nse|hu |di |a n|la | pa|mun| wa|nga|unt| la|a u|u a|e a|ons|za | ma| lo|iye|ace|ce |a l|idw|ang| ka|kha|liy|ens|li |ala|ira|ene|pa |i n|we |e m|ana|dwa|era|hal|ulu|lo |ko |dzi| ci|yo |o w|iko|ga |a p|chi| mo|lu |o l|o m|oyo|ufu| um|moy|zik| an|ner|and|umo|ena| uf|dan|iri|ful|a a|ka |to |hit|nch| nc|a c|ito|fun|dwe| da|kuk|wac| dz|e l|a z|ape|kap|u w|e k|ere|ti |lir| za|pen|tha|aye|kut|mu |ro |ofu|ing|lid| zo|amu|o c|i m|mal|kwa|mwa|o a|eza|i p|o n|so |i d|lin|nso| mw|iro|zo | a |ati| li|i l|a d|ri |edw|kul|una|uti|lan|a b|iki|i c|alo|i k| ca|lam|o k|dza|ung|o z|mul|ulo|uni|gan|ant|nzi| na|nkh|e n|san|oli|wir|tsa|u k|ome|ca |gwi|unz|lon|dip|ipo|yan|gwe|pon|akh|uli|aku|mer|ngw|cit| po| ko|kir|mba|ukh|tsi|bun|iya|ope|kup|bvo|han| bu|pan|ame|vom|ama| ya|siy| am|rez|u n|zid|men|osa|ao |pez|i a| kw| on|u o|lac|ezo|aka|nda|hun|u d|ank|diz|ina|its|adz| kh|ne |nik|e p|o o|ku |phu|eka| un|eze|mol|ma | ad|pat|oma|ets|wez|kwe|kho|ya |izo|sa |o p|kus|oci|khu|okh|ans|awi|izi|zi |ndu|iza|no |say| si|i u|aik|jir|ats|ogw|du |mak|ukw|nji|mai|ja |sam|ika|aph|sid|isa|amb|ula|osi|haw|u m| zi|oye|lok|win|lal|ani| ba|si | yo|e o|opa|ha |map|emb',zyb:'bou|aeu|enz|nz |eng|iz |ih |uz |uq |oux|ing| bo| di| ca|z g|dih|ux |ngh|cae|gen|euq|z c|you|ng |ung|ngz|ij | gi| mi|miz|aen| ge|z d| ci|gya| yi| de|ouj|uj | gu|cin|ngj|ien|mbo|dae| mb|zli| se|gij|j g|ang|ouz|z y|j d|nae| cu| ba| da|h g|oz |yin|de |z b|nzl|li |nj |euz|x m| cw|iq | yo|gz |q g|yau|inh|vun|x b|h c| ga|ix |cwy|wyo| ro|rox|oxn|vei|nda|i c| nd|z m|gh |j b|wz | si| gy|hoz|unz|xna|cun|gue| li|ei |z h|yen|bau|can|inz|q c|dan| hi|gj |uh |yie| vu|faz|hin| bi|uek|goz|zci|nh |aej|ya |ej | fa|gun|ciz|au | go| ae|h m|ngq|den|gva|ouq|nq |z s|q d|ekg|q s| do|h d|kgy|eix| wn|ci |az |hu |nhy| ha|j c|u d|j n|z l|auj|gai|gjs|lij|eve|h s|sen|sin|sev|ou |sou|aiq|q y|h y|jso|bin|nei| la|en |ouh|din|uen|enj|enh|i b|z r|awz|q n|vih|j y|anj|bwn|sei|z n| ne|ozc|hye|j s|i d|awj|liz|g g|bae|wng|g b|eiq|bie|enq|zda| ya|n d|h f|x d|gak|hix|z v|h b|oen|anh|u c|in |i g|ghc|zsi|hci|siz|anz|ghg|ez |dun|cou| du|ngg|ngd|j m|cuz| ho|law|eiz|g c| dw|aw |g d|izy|hgy|ak |nde|min|dei|gda|ujc|wn |env|auy|iuz|ai |wnj|a d|hen|ozg|nzg|ek |g y|gzd|gzs|yaw|e c|yuz|daw|giz|jhu|ujh| co|nvi|guh|coz| ve| he|i m|sae|aih|x l|iet|iuj|dwg|iqg|qgy|gih|yai| na| fu|uyu|zbi|zdi|q b|cie|inj|zge|wnh|jsi|uzl| bu| le|eij|izc|aq ',kin:'ra | ku| mu|se |a k|ntu|nga|tu |umu|ye |li | um|mun|unt|a n|ira| n |ere|wa |we | gu|mu |ko |a b|e n|o k|e a|a u|a a|u b|e k|ose|uli|aba|ro | ab|gom|e b|ba |ugu| ag|omb|ang| ib|eng|mba|o a|gu | ub|ama| by| bu|za |ihu|ga |e u|o b| ba|kwi|hug|ash|ren|yo |ndi|e i| ka| ak| cy|iye| bi|ora|re |gih|igi|ban|ubu| nt| kw|di |gan|a g|a m|aka|nta|aga| am|a i|ku |iro|i m|ta |ka |ago|byo|ali|and|ibi|na |uba|ili| bw|sha|cya|u m|yan|o n| ig|ese|no |obo|ana|ish|kan|sho| we|era|ya |aci|wes|ura|i a|uko|e m|n a|o i|kub|uru|hob|ber|ran|bor| im|ure|u w|wo |cir|gac|ani|bur|u a|o m|ush| no|e y| y |rwa|eke|nge|ara|wiy|uga|zo |ne |ho |bwa|yos|anz|aha|ind|mwe|teg|ege|are|ze |n i|rag|ane|u n|ge |mo |u k|bul| uk|bwo|bye|iza|age|ngo|u g|gir|ger|zir|kug|ite|bah| al| ki|uha|go |mul|ugo|n u|tan|guh|y i| ry|gar|bih|iki|atu|ha |mbe|bat|o g|akw|iby|imi|kim|ate|abo|e c|aho|o u|eye|tur|kir| ni|je |bo |ata|u u| ng|shy|a s|gek| ru|iko| bo|bos|i i| gi|nir|i n|gus|eza|nzi|i b|kur| ya|o r|ung|rez|ugi|ngi|nya| se|mat|eko|o y| in|uki| as|any|bis|ako|gaz|imw|rer|bak|ige|mug|ing|byi|kor|eme|nu | at|bit| ik|hin|ire|kar|shi|yem|yam| yi|gen|tse|ets|ihe|hak|ubi|key|rek|icy| na|bag|yer| ic|eze|awe|but|irw| ur|fit|ruk|ubw|rya|uka|afi',zul:'nge|oku|lo | ng|a n|ung|nga|le |lun| no|elo|wa |la |e n|ele|ntu|gel|tu |we |ngo| um|e u|thi|uth|ke |hi |lek|ni |ezi| ku|ma |nom|o n|pha|gok|nke|onk|a u|nel|ulu|oma|o e|o l|kwe|unt|ang|lul|kul| uk|a k|eni|uku|hla| ne| wo|mun| lo|kel|ama|ath|umu|ho |ela|lwa|won|zwe|ban|elw|ule|a i| un|ana|une|lok|ing|elu|wen|aka|tho|aba| kw|gan|ko |ala|enz|o y|khe|akh|thu|u u|na |enk|kho|a e|zin|gen|i n|kun|alu|mal|lel|e k|nku|e a|eko| na|kat|lan|he |hak| ez|o a|kwa|o o|ayo|okw|kut|kub|lwe| em|yo |nzi|ane|obu| ok|eth|het|ise|so |ile|nok| ba|ben|eki|nye|ike|i k|isi| is|aph|esi|nhl|mph| ab|fan|e i|isa| ye|nen|ini|ga |zi |fut| fu|uba|ukh|ka |ant|uhl|hol|ba |and|do |kuk|abe|za |nda| ya|e w|kil|the| im|eke|a a|olo|sa |olu|ith|kuh|o u|ye |nis| in|ekh|e e| ak|i w|any|khu|eng|eli|yok|ne |no |ume|ndl|iph|amb|emp| ko|i i| le|isw|zo |a o|emi|uny|mel|eka|mth|uph|ndo|vik| yo|hlo|alo|kuf|yen|enh|o w|nay|lin|hul|ezw|ind|eze|ebe|kan|kuz|phe|kug|nez|ake|nya|wez|wam|seb|ufa|bo |din|ahl|azw|fun|yez|und|a l|li |bus|ale|ula|kuq|ola|izi|ink|i e|da |nan|ase|phi|ano|nem|hel|a y|hut|kis|kup|swa|han|ili|mbi|kuv|o k|kek|omp|pho|kol|i u|oko|izw|lon|e l| el|uke|kus|kom|ulo|zis|hun|nje|lak|u n|huk|sek|ham| ol|ani|o i|ubu|mba| am',swe:' oc|och|ch |er |ing|fr|tt |ar |en |tt|nde| f|rt|ill|et |and| r| en| ti| de|til|het|ll |de |om |var|lig|gen| fr|ell|ska|nin|ng |ter| ha|as | in|ka |att|lle|der|sam| i |und|lla|ghe|fri|all|ens|ete|na |ler| at|r |den| el|av | av| so|igh|r h|nva|ga |r r|env|la |tig|nsk|iga|har|t a|som|tti| ut|ion|t t|a s|nge|ns |a f|r s|mn|a o| sk| si|rna|isk|an | st|r |ra | vi| al|t f| sa|a r|ati| r| me| be|n s| an|tio|nna|lan|ern|t e|med| va|ig |ns| t|sta|ta |nat| un|kli|ten| gr|vis|ll| la|one|han|nd|t s|st|t i|ner|ans|gru| ge|ver| m| li|lik|ihe|ers|rih|r a| re|m |sni|n f|t o| m| na|r e|ri |ad |ent|kla|det| v|run|rkl|da |h r|upp|dra|rin|igt|dig|n e|erk|kap|tta|ed |d f|ran|e s|tan|uta|nom|lar|gt |s f| p| om|kte|lin|r u|vid|g o|nn|erv|ika|ari|a i|lag|rvi|id |r o|s s|vil|r m|rk|ot |ndl|str|els|ro |a m|mot| mo|i o|p |r d|on |del|isn|sky|e m|ras| h|r f|i s|a n|nad|n o|gan|tni|era|rd|a d|tl|ber|nga|r i|enn|nd |n a| up|sin|dd |rs|je |itt|kal|n m|amt|n i|kil|lse|ski|nas|end|s e| s|inn|tat|per|t v|arj|e f|l a|rel|t b|int|tet|g a|ra|l v|kyd|ydd|rje| fa|bet|se |t l|lit|sa |nr|hl|l s|ndr|nis|yck|h a|llm|lke|h f|arb|lm|nda|bar|ckl|v s|rn|gar|tra|re |ege|r g|ara|ess|d e|vr|mt |ap ',lin:'na | na| ya|ya |a m| mo|a b|to | ko| bo|li |o n| li|i n| pe|i y|a y|a n|ngo|ki | ba| ma|kok|pe |la |a l|zal|oki|ali|nso|oto|ala|ons|so |mot|a k|nyo|eng|kol|go |nge| ny|yon|o e|ang|eko|te |o y|oko|olo|ma |iko|a e|e m|e b|lik|ko |o a|ako|ong| ye|mak|ye |isa| ek|si |lo |aza|sal|ama| te|bat|o p|oyo|e n| az|a p|ani|sen|o m|ela|ta |amb|i k|ban|ni | es|yo |mi |mba|osa| oy|aka|lis|i p|eli|a t|mok|i m|ba |mbo| to| mi|isi|bok|lon|ato|ing|o b| nd|ota|bot| ez|ge |nga|eza|o t|nde|ka |bo |gel|kan|e k|lam|sa |ese|koz| po|den|ga |oba|omb|oli|yan|kop|bon|mos|e e|kob|oka|kos|bik|lin|po |e a| lo| bi|kot|te|ngi|sam| t|omi|e y|ti |i b| el|elo|som|lok|esa|gom|ate|kam|i t|ika|a s|ata|kat|ati|wa |ope|oza|iki|i e| ka|bom|tal|o l|bek|zwa|oke|pes| se|bos|o o|ola|bak|lak|mis|omo|oso|nza| at|nda|bal|ndi|mu |mob|osu|e t|asi|bis|ase|i l|ele|sus|usu|su |ozw|and|mol|tel|lib|mbi|ami| nz|ne |ene|kel|aye|emb|yeb|nis|gi |obo|le |kum|mal|wan|a |pon| ep|baz|tan|sem|nya|e l| ta|gis|opo|ana|ina|tin|obe| ti|san| ak|mab|bol|oku|u y|mat|oti|bas|ote|mib|ebi|a o|da |bi | mb|lel|tey|ibe|eta|boy|umb|e p|eni|za |be |mbe|bwa|ike|se | et|ibo|eba|ale|yok|kom| en|i a|mik|ben|i o| so|gob|bu |son|sol|sik|ime|eso|abo| as|kon|eya|mel',som:' ka|ay |ka |an |uu |oo |da |yo |aha| iy|ada|aan|iyo|a i| wa| in|sha| ah| u |a a| qo|ama| la|hay|ga |ma |aad| dh| xa|ah |qof|in | da|a d|aa |iya|a s|a w| si| oo|isa|yah|eey|xaq|ku | le|lee| ku|u l|la |taa| ma|q u|dha|y i|ta |aq |eya|sta|ast|a k|of |ha |u x|kas|wux| wu|doo|sa |ara|wax|uxu| am|xuu|inu|nuu|a x|iis|ala|a q|ro |maa|o a| qa|nay|o i| sh| aa|kal|loo| lo|le |a u| xo| xu|o x|f k| ba|ana|o d| uu|iga|a l|yad|dii|yaa|si |a m|gu |ale|u d|ash|ima|adk|do |aas| ca|o m|lag|san|dka|xor|adi|add| so|o k| is|lo | mi|aqa|na | fa|soo|baa| he|kar|mid|dad|rka|had|iin|a o|aro|ado|aar|u k|qaa| ha|ad |nta|o h|har|axa|quu| sa|n k| ay|mad|u s| ga|eed|aga|dda|hii|aal|haa|n l|daa|xuq|o q|o s|uqu|uuq|aya|i k|hel|id |n i| ee|nka| ho|ina|waa|dan|nim|elo|agu|ihi|naa|mar|ark|saa|riy|rri|qda|uqd| bu|ax |a h|o w|ya |ays|gga|ee |ank| no|n s|oon|u h|n a|ab |haq|iri|o l| gu|uur|lka|laa|u a|ida|int|lad|aam|ood|ofk|dhi|dah|orr|eli| xi|ysa|arc|rci|to |yih|ool|kii|h q|a f| ug|ayn|asa| ge|sho|n x|siy|ido|a g|gel|ami|hoo|i a|jee|n q|agg|al | di| ta|e u|o u| ji|goo|a c|sag|alk|aba|sig| mu|caa|aqo|u q|ooc|oob|bar|ii |ra |a b|ago|xir|aaq| ci|dal|oba|mo |iir|hor|fal|qan| du|dar|ari|uma|d k|ban|y d|qar|ugu| ya|xay|a j',hms:'ang|gd |ngd|ib | na|nan|ex |id | ji|ad |eb |nl |b n|d n| li|ud |jid| le|leb| ga|ot |anl|aot|d g|l l|b l| me|ob |x n|gs |ngs|mex|nd |d d| ne|jan|ul | ni|nja| nj| gu| zh|lib|l n|ong| gh|gao|b j|b g|nb |l g|end|gan| ad| je|jex|ngb|gb |han|el | sh| da|ub |d j|d l|t n| nh|nha|b m|is |d z|x g| ya|oul|l j| wu|she|il |nex| ch|b y|d s|gue|gho|uel|wud|d y| gi|d b|hob|nis|s g| zi| yo|lie|es |nx |it |aob|gia|ies| de|eib|you| ba| hu|ian|zib|d m|s j|oud|b d|chu|ol |ut | do|t j|nen|hud|at |s n|hen|iad|ab |enl| go|dao| mi|t g|zha|b z|enb|x j| ze|eit|hei|d c|nt |b s| se|al | xi|inl|hao| re| fa|d h|gua|yad|ren| ho|anb|gx |ngx|ix |nib|x z|and|b h|b w|fal| xa|d x|t l|x m|don|gou|bao|ant|s z|had|d p|yan|anx|l d|zhe|hib| pu|ox | du|hui|sen|uib|uan|lil|dan|s m| di| we|gha|xin|b x|od |zhi|pud| ju| ng|oub|xan| ge|t z|hub|t h|hol|t m|jil|hea|x l| ma|eud|jul|enx|l z|l s|b a| lo| he|nga|d r|zen| yi|did|hon|zho|gt |heb|ngt|os |d a|s l|aos| si|dei|dud|b b|geu|wei|d w|x c|x b|d k|dou|l h|lou| bi|x a|x d|b c| sa|s a| bo|eut|blo| bl|nia|lol|t w|bad|aod| qi|ax |deb| ja|eab| nd|x s|can|pao| pa|gl |ngl|che|sat|s y|l m|t s|b f|heu|s w| to|lia| ca|aox|unb|ghu|ux | cu|d f|inb|iel| pi|jib|t p|x x|zei|eul|l t|l y|min|dad',hnj:'it | zh| ni|ab |at | sh|ang|nit|os | do|uat|ox |ax |nx |ol |ob | nd|t d|x n|nf |zhi|as | ta|tab|ef |if |d n|ad | mu| cu|uax|cua|mua|b n|uf |ib |s d|dos|id |enx|nb |hit| lo|f n|t l|ngd|gd |us |inf|ux |ed | go|she|b d|b z|t n| ho|x z| yi|aob|l n|ong|t z| zi|ix |nda|d z|ut |yao|uab|enb| de|dol|f g| dr|zhe| yo| le|euf|x d|inx|nen|das| ne|dro|gb |ngb|d s| ge|hox|f z|uef|s n|len|b g| ua|ud |nd |gox| na|il | du|x j|oux|f y|f h|ndo|x c|han|of |zha|uad|s z| da| ny| ja| gu|heu| ji|ik | bu|shi|lob|od | ya|gf |t g|hai|ged|ngf|b h|you| hu|ex |bua|out|nil|hen|rou|yin|zhu|ous|nya|enf|f d|is | re|b c|lol|nad|dou|af | xa| id|t s| ha|uk |jai|xan|sha|b y|hua|aib|s s|d d| la| qi|ren|x l|hue|l m|x g|ot | xi| ba| zo| kh| dl|jua| ju|aod|zif|ait|bao| di| ga|x y| nz|b s|x s|xin| li|aof|b b|ngx|gx |eb |b l|x t|x m|hed| be|dax|b t|s t|hef|las|d j|gua| pi|t y|f b|d l|l d|nzh| ib|hif|t h|dus|t r|hou|f l|hun|und|s l|el |aik|d y|aos|f t| mo| bi|hab|ngt|gai| za|uas|x h|gt | zu|ros|aid|zos| gh|end|pin|k n|k z| ao|iao|s b|dex|x b|due|ak |d g| fu|s x|deu|s y|mol|x i|f s|hik| hl| bo|l b|eut|lb |uaf|zho|d b| lb|s m|lan|al |b k|t b| ch|d p|x x|f x|ub |t c|d m| ro| nt|d h|et |uak|aox|gon|tua|yua|t t|zis|deb|d t| we|shu',ilo:'ti |iti|an |nga|ga | ng| pa| it|en | ka| ke| ma|ana| a | ti|pan|ken|agi|ang|a n|a k|aya|gan|n a|int|lin|ali|n t|a m|dag|git|a a|i p|teg|a p| na|nte|man|awa|kal|da |ng |ega|ada|way|nag|n i| da|na |i k|sa |n k|ysa|n n|no |a i|al |add|aba| me|i a|eys|nna|dda|ngg|mey| sa|pag|ann|ya |gal| ba|mai| tu|gga|kad|i s|yan|ung|nak|tun|wen|aan|nan|aka| ad|enn| ag|asa| we|yaw|i n|wan|nno|ata| ta|l m|i t|ami|a t| si|ong|apa|kas|li |i m|ina| an|aki|ay |n d|ala|gpa|a s|g k|ara|et |n p|at |ili|eng|mak|ika|ama|dad|nai|g i|ipa|in | aw|toy|oy |ao |yon|ag |on |aen|ta |ani|ily|bab|tao|ket|lya|sin|aik| ki|bal|oma|agp|ngi|a d|y n|iwa|o k|kin|naa|uma|daa|o t|gil|bae|i i|g a|mil| am| um|aga|kab|pad|ram|ags|syo|ar |ida|yto|i b|gim|sab|ino|n w| wa| de|a b|nia|dey|n m|o n|min|nom|asi|tan|aar|eg |agt|san|pap|eyt|iam|i e|saa|sal|pam|bag|nat|ak |sap|ed |gsa|lak|t n|ari|i u| gi|o p|nay|kan|t k|sia|aw |g n|day|i l|kit|uka|lan|i d|aib|pak|imo|y a|ias|mon|ma | li|den|i g|to |dum|sta|apu|o i|ubo|ged|lub|agb|pul|bia|i w|ita|asy|mid|umi|abi|akd|kar|kap|kai| ar|gin|kni| id|ban|bas|ad |bon|agk|nib|o m|ibi|ing|ran|kda|din|abs|iba|akn|nnu|t i|isu|o a|aip|as |inn|sar| la|maa|nto|amm|idi|g t|ulo|lal|bsa|waw|kip|w k|ura|d n|y i'},Cyrillic:{rus:' |  ||| || ||| | || |  | | | || || | || | ||| || |||| || ||| || ||||| | |||| | || ||| || | || | | ||| || || ||| | | || | | | || | || ||| | | || || |||| || |||| || | |||| || | ||| | || | ||||| || | || ||||| ||||||||| | ||| ||||||||||| | ||||| | ||| ||| ||| || | | || || ||||||| | ||| | ||||||| || || | | | | || ||| | | ||| || ||  | | |||| | | ||||| ||||| || | ||||| | |||||| ||||||| || || | || || |||| | |||||| || | ||| ||| |||||',ukr:' | |  ||| | || || | | || | | | ||| | | |||| ||||||| ||| | | || ||| | || |||| | | | || | | || | |||||| | | | | |||| | | | | | ||  | | | | | |||| |||||  ||| | || ||| ||||||| | |||| || || | || | | | || | || ||| || | || | | || | | ||||||||| | | || || ||| |||| | | | || ||||| | || |||||| || | |||| | || || ||| | || | | | ||| | | ||| | ||| | | ||| | ||| || ||| | || | | ||||| |||| ||||| | |||||| |||||||||| |||||| ||||| || | || ||| |||||| || | | | ',bos:' |  || || | | || | | | | | | | | | |  || | | | | || ||| | | || | || || | | || | | || | || | || |||||| || || | | | | || | | || | || | ||| | || | || || | | | | ||||| | ||||| | || || || || |||| ||| | ||| | | |||| || ||| | | ||||||| || | | || | | || || ||| ||||| | ||| || | | || | | |||| ||||||| | |||||||| | || || |||||||| | | | ||||||||| |||| ||| | ||||| ||||||||| ||| | | | | | || ||||| || |||| | ||| | ||| ||| | | | ||| |||||| |||||| ||||||| ',srp:' |  ||| | | | | | || | | | | | | |  || | || || | || ||| | | | | | | | | | | | || |||| ||| | | | || || || | || | | | | | | ||| || | || ||| || || | ||||| | ||| | | || || | | | | |||||| | | || || || ||||||||| | ||||| | || | || ||| || || | ||| |||| | | | | || || ||| |||| | || ||| || |||| |||| | || | | | | ||| |||||| ||| ||| || |||| || ||| |||| |||| || || ||||||| || | | | ||| |||| |||| || ||||||| | |||| | | | ||| ||||||| | |||| ||| | ||||||||||',uzn:'| | | | | | | | | ||||||| || | | | | ||| ||||||| || |||| ||| || | || || ||||| ||| | | ||| ||| |||| || | || | ||| | | | ||| | ||| || || || || ||| || |||| | | |||||| | ||| | | | || || | | || || |||| |||| ||| || | || | || ||| | | |||| ||| |||| | || ||||| ||||||||| | || || || ||||| ||||| | || | | || | ||| || || | || |||| | ||||| | || | | |||| ||| ||||| || | ||| |||||| || | |||| ||| | | ||||| | || | ||| | ||| |||||| || | |||||||',azj:' | | || | | | | | |||| || || || | || ||||| || ||||| ||| | | |||| ||| ||||| |||| | | || |||| ||| || |||||| | ||||| | | || | |||||| || || | | || || || || | ||| | || ||| ||| || | | || | || | ||||| ||| | | ||| | ||| | ||| |||| | | | | ||||| |||| || || |||||| | |||| || | | | ||| || || | || ||| | | | ||||| |||| | | | |||| ||| | |||| ||| || ||| |||||| || || | || || || || ||||||| | ||||| |||| ||| | | || ||| ||||| ||| |||| || ||| | | ',koi:' | | | | ||| || || ||| || | | | || | | || | | |||| | || | ||  | | | | | ||| | || | || | ||||| |||| ||||||||| | | || | || | || | || || | | | | ||| | | |||||| || | ||||| | | ||||| || | | |||| ||| | | | | | ||||| | | || | ||||||| ||| || || || | || |||| | ||| |||||| |||| || || | | | ||||| || | | | ||||| | |||| ||||||| | || | ||| | | | | ||| | || | ||||||| ||| |||| | | | | ||| | | || | ||||| ||| || ||||||| ||| || |||||||| ||||||||  ||||| ',bel:'  | ||| | | || | || | ||| | |||| | ||| ||| | | | | || | | | ||| | | ||| |||||| |  | | || |||| || | || | ||| |||| |||||| | | | || |||| | || |||||| |||| | || | || ||| || || | | |||| || || | | || | |||| || |||  | | ||||| | | | ||| | || || |||| ||||| ||||| | | ||| |||| | || | | |||| || | |||||| ||| ||| ||| | || |||| | | | | || || |||| | |||| ||||| ||||| |||||||||||| |||| || || | | ||||| ||| || || ||| ||| | |||||| | ||| | || ||| |||',bul:' | | | |  || || | || | | || | || | | | ||| | | | | | || | ||| || | || | | | | |||| ||| | |||| || ||| || | | | |  | ||| | | || |||||||| ||| | | || || | | | | |||| | || | ||  | | | || || || | || | || ||||| || || |||| || || || || || |||||||||| ||| || ||| || || ||| |  | || || |||| || | |||||| |||||||||| || |||||| | | || | ||| ||||||| | |||||| ||| | | || | || |||| ||| || |||||| |||| | |||| || ||||||| | |||||| || ||||| ||||| | | |||| |||',kaz:' | | ||| | | |||| | | |||| | | |||| ||| | | | | | || | |||| | |||| || ||| || | |||| | |||| | | | |||| | ||||| ||| |||| || | ||| || | | || || || | | | |||| || | ||||||| ||| |||| ||| | | |||| |||||| ||||| | || || ||| || | | |||||| | || ||||||||||| || | | | | | ||||||| || || || ||||| |||| |||| || ||| | |||| ||| | || | || || ||| | || ||||| | ||||| ||| |||||| | |||| ||||||| |||| | | | ||| | ||||| | |||||||| ||| || || || | '},Arabic:{arb:' | | || | || | | |||| | | | | || || | | | | | | | | | | || || | || || | | ||||| | | | | | | | ||| | | | | | | | | | | | ||| ||| | | || | ||| | | || | | || | | | | | ||| | || | | | || || | | ||| ||| | || || | |||||| | ||| |||||||| | || || | || | | | || | | || ||||| |||||| | | | || | | | | ||| ||||| | ||||| | ||| ||||||||| | || | | | | |||| ||||| |||| | |||| |||| ||| || || || | | ||||| | | | | ||| | | | || || | || ||||||| ||| | | | | || ||| || ||| | | | | | | |||',urd:' | || | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | || | | ||||| | | | || | | | | | | | | || | || | | | | | ||| | || | | | | || | || | | | | | | | || ||| | | | | | | | | || | | | | | | | | ||| | |||| ||| | || | | | || | | | | | | | | ||| ||| | || | ||| | ||| || || | ||| | | | | | | | ||| |  | | | || | | || || | ||| | | | ||| | | | | | ||| | | | || |||||| | || | | || | | || || || | ||||| | | | | | | || | |||| || || || | | | | || ||||| ||| || | || | | | | | | || | | ||| || | || || |',fas:'  | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | || || | | | || | | | | ||| | | | | | | | | |||||| | | | || || | | | | | | | | || | | || | || | | ||| | || || || || | | || | | | | || || | | | | | ||| || | |||| | | | || | | || |||||||| | | | | | | | || || | | | ||| | | | | | | | |||| | || | | | || | | || | ||| | | | | | || ||| ||| || | | || || | | |||| | | | |||| || || | |||| || ||| | | | || |||||||||| ||| || | | ||| | | | | | || |||| |||| || | |||| | || ||||| || ||| | |',zlm:' | || | | | | | | | || | | | | || | || || || ||| ||||| | | | ||| | || | || || || | || | | | | | | | | | ||| | | || | | |||| |||| | | || | || | || ||| |  | |||| | | || || | | | | ||| | | | ||| | || ||||| | | ||||||| | | || | || | |||| || | | |||| | || | | | | | ||| | | |||| ||| | | | | || | ||| |||| | || | | || | | |||| ||||| | ||||||| |||||||| |||| | || | ||| |||||||| | || || || | || || | ||||| || | || ||| | |||| | | | | || | ||| | |||| |||| |||||| ||| ',skr:' | | | | | | | | | || | | || | | | |  || | | | | | ||| | || || | | | | | | || | | | | || | |||| | || | || | | || || | || || | | || | |||| ||| || | | | | || | | | | || || | | | || | | | ||| | | | | | | | | | | | | || | | | || | || || | | | | | || |||| || | | || || ||| | | | | | | | | | | | || || || || || ||  | | | | || | | || | | | | | ||||| | |||| ||||| | | | | | ||| | ||| | || || | | || | || | | | ||| | | || | | || | || | ||| | ||| | ||| | || | | | | |||| | | | ||||| | | | | | | |||| | | | | | ||| | ',pbu:'  | | | | | | | | | | | | | | | | | | | | | | || | | || | | | || | | || ||| | || | | | | | | | ||| | || | | || ||| | | | || | | | | | || | | | | || | | | | | || ||| | | | || | | | | || | | | | || ||| || || | | | | || | | || ||| | | | || | || ||| ||||| | | | | | | | | | || | ||| ||| || | | | || | | | | | || | ||| | ||| || ||| | ||||| || |||| || || || | | | | || ||| | | | | | || | | | || ||| || | | || | | ||| ||| || | | ||| || | | | | | || | |||| | | | | || | | ||| | || | | | || | | || | | | | ||| | ||'},Devanagari:{hin:' || | | | | || | | | | | | | | || | ||| || | | | | | ||| || || || || | | || | || | ||| | | | | | || | | ||| ||| ||| | | ||| | || | | | |  || | | | | | || | || | | || |||| | ||| |||||||||| || || | | | | | | ||| | || |  || | | | | || ||| || || ||| |||| | || ||| | | ||| | ||| || | || | | ||| || || | | | |||||| | |||||| | | | ||| | || | | | || ||| | | | ||| ||| | ||| ||||| | | | |||| |||| || ||| | | | ||||| | || ||||| ||| | | | | | || ||| || | | || | | | |||| ||| || || ',mar:'| ||| |  ||||| ||| ||| || | | | |||| | || | | | || ||| | || | | | ||||||| | || |||| | | || | ||||| || | ||||| || ||||| | | | | |||||| | || ||| | || | ||| | || | | || | | |||| |||| | | || | | | || ||| || | | | | | || | ||| ||| | || ||| || | || ||| ||||| | | || || ||||| | || || ||| | | || | | |||||||| |||||||||| || || |||| || || | || | ||||| | |||||| || | ||||| | || ||| || ||||| |||||||| | || | | |||||| |||| |||||| | |||||| | ||',mai:' ||||| | | || | || || ||| | | ||||| | || | || ||||| | |||| |||| | | || | | | ||| ||| ||| | | | || |||| ||| || | | || |||| | ||| || | ||| | | | | | | || || | ||| || || | || |  | | | | || |||| | || | |||||| || ||||| ||||||| | | ||||| | | | || || | ||||| || | |||| || ||| | | ||| || | | | | || ||||| || | | || ||| | || ||| | || |||| || ||| | | | || ||| || |  | || | ||||| | | ||| || || | | || || | | | | | ||| || || | | | | || | || || ||| |||||| | | ||| | |',bho:' | | | |||| || | || | | | | | | | | || | | | | | | || | || | | | | ||| | || |||| | || | | | || || || || | || | | | || | |||| | | || | | || || | | ||| | | ||| | ||| | | | || | | || | || || || | | |||| | | | ||| | || ||||| | || |||||| | ||| || |||| | |||| | |  | | ||||| | | | | | ||| | | |||| | | | | | | |||| | | |||| | || || || ||| | ||| | | | | |  ||| | | | || | || | | ||| | | | | ||||| | ||| ||||| || ||| | | | | | | | | ||| | || | ||||| | | | | || | || || | | || | | | | | || ||',nep:' |  ||| | ||||| ||| ||| | || | || |||| |||| | || | || |||| | | | || ||||  ||| | | | | |||||  | | |||| |||||| | | | | |||| | | | || | | || | | | | ||| || | || ||| | || | ||| |||||| | ||| || ||| | |||| | | | || | | ||||||| || | | || || |||| |||| | || || ||| || |||||| || ||||| | | | || | || || || ||| | | | | || | || ||| ||| |||||| | | || | ||||| |||| | | | | || ||||| || || ||||| ||| ||| | |||| | | || || |||| ||||| | | ||||| | | || ||| | || |'}}},{}],2:[function(b,a,c){a.exports={cmn:/[\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FCC\uF900-\uFA6D\uFA70-\uFAD9]|[\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/g,Latin:/[A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A]/g,Cyrillic:/[\u0400-\u0484\u0487-\u052F\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69D\uA69F]/g,Arabic:/[\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u065F\u066A-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B2\u08E4-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC]|\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]/g,ben:/[\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB]/g,Devanagari:/[\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FB]/g,jpn:/[\u3041-\u3096\u309D-\u309F]|\uD82C\uDC01|\uD83C\uDE00|[\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D]|\uD82C\uDC00/g,kor:/[\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/g,tel:/[\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F]/g,tam:/[\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA]/g,guj:/[\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1]/g,kan:/[\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2]/g,mal:/[\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D75\u0D79-\u0D7F]/g,mya:/[\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F]/g,ori:/[\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77]/g,pan:/[\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75]/g,amh:/[\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]/g,tha:/[\u0E01-\u0E3A\u0E40-\u0E5B]/g,sin:/[\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4]|\uD804[\uDDE1-\uDDF4]/g,ell:/[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65]|\uD800[\uDD40-\uDD8C\uDDA0]|\uD834[\uDE00-\uDE45]/g}},{}],3:[function(c,a,d){'use strict';function b(a){return String(a).replace(/\s+/g,' ')}a.exports=b},{}],4:[function(c,b,d){'use strict';function a(a){function b(b){var c=[],d;if(b===null||b===undefined)return c;if(b=String(b),d=b.length-a+1,d<1)return c;while(d--)c[d]=b.substr(d,a);return c}if(typeof a!=='number'||isNaN(a)||a<1||a===Infinity)throw new Error('`'+a+'` is not a valid argument for n-gram');return b}b.exports=a,a.bigram=a(2),a.trigram=a(3)},{}],5:[function(b,m,a){'use strict';function e(a){return a===null||a===undefined?'':d(i(String(a).replace(/[\u0021-\u0040]+/g,' '))).toLowerCase()}function f(a){return h(' '+e(a)+' ')}function g(g){var d=f(g),e=d.length,a={},b;while(e--)b=d[e],c.call(a,b)?a[b]++:a[b]=1;return a}function k(d){var b=g(d),a=[],c;for(c in b)a.push([c,b[c]]);return a.sort(j),a}function l(d){var a=d.length,b={},c;while(a--)c=d[a],b[c[0]]=c[1];return b}function j(a,b){return a[1]-b[1]}var h=b('n-gram').trigram,i=b('collapse-white-space'),d=b('trim'),c={}.hasOwnProperty;a.clean=e,a.trigrams=f,a.asDictionary=g,a.asTuples=k,a.tuplesAsDictionary=l},{'collapse-white-space':3,'n-gram':4,trim:6}],6:[function(d,b,a){function c(a){return a.replace(/^\s*|\s*$/g,'')}a=b.exports=c,a.left=function(a){return a.replace(/^\s*/,'')},a.right=function(a){return a.replace(/\s*$/,'')}},{}],7:[function(d,s,t){'use strict';function j(a,b){return e(a,b)[0][0]}function e(c,l){var d=l||{},j=f,e;return d.minLength!==null&&d.minLength!==undefined&&(j=d.minLength),!c||c.length<j?b():(c=c.substr(0,k),e=p(c,i),e[0]in a?n(c,r(h.asTuples(c),a[e[0]],d)):e[1]===0?b():g(e[0]))}function n(g,a){var d=a[0][1],e=g.length*c-d,b=-1,f=a.length;while(++b<f)a[b][1]=1-(a[b][1]-d)/e||0;return a}function p(f,d){var a=-1,e,b,c;for(b in d)c=q(f,d[b]),c>a&&(a=c,e=b);return[e,a]}function q(b,c){var a=b.match(c);return(a?a.length:0)/b.length||0}function r(h,a,e){var c=[],f=e.whitelist||[],g=e.blacklist||[],d;a=l(a,f,g);for(d in a)c.push([d,m(h,a[d])]);return c.length?c.sort(o):b()}function m(f,g){var d=0,e=-1,h=f.length,b,a;while(++e<h)b=f[e],b[0]in g?(a=b[1]-g[b[0]]-1,a<0&&(a=-a)):a=c,d+=a;return d}function l(b,c,e){var d,a;if(c.length===0&&e.length===0)return b;d={};for(a in b)(c.length===0||c.indexOf(a)!==-1)&&e.indexOf(a)===-1&&(d[a]=b[a]);return d}function b(){return g('und')}function g(a){return[[a,1]]}function o(a,b){return a[1]-b[1]}var h=d('trigram-utils'),i=d('./expressions.js'),a=d('./data.json');j.all=e,s.exports=j;var k=2048,f=10,c=300;!function(b,d,e,f,g,c){for(g in a){b=a[g];for(d in b){f=b[d].split('|'),c=f.length,e={};while(c--)e[f[c]]=c;b[d]=e}}}()},{'./data.json':1,'./expressions.js':2,'trigram-utils':5}]},{},[7])(7)})
diff --git a/lib/browser/extensions/hjson.js b/lib/browser/extensions/hjson.js
new file mode 100755
index 000000000..c340aedb6
--- /dev/null
+++ b/lib/browser/extensions/hjson.js
@@ -0,0 +1,1490 @@
+/*!
+ * Hjson v3.1.1
+ * http://hjson.org
+ *
+ * Copyright 2014-2017 Christian Zangl, MIT license
+ * Details and documentation:
+ * https://github.com/hjson/hjson-js
+ *
+ * This code is based on the the JSON version by Douglas Crockford:
+ * https://github.com/douglascrockford/JSON-js (json_parse.js, json2.js)
+ */
+
+(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hjson = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
+/* Hjson http://hjson.org */
+"use strict";
+
+var common=require("./hjson-common");
+
+function makeComment(b, a, x) {
+  var c;
+  if (b) c={ b: b };
+  if (a) (c=c||{}).a=a;
+  if (x) (c=c||{}).x=x;
+  return c;
+}
+
+function extractComments(value, root) {
+
+  if (value===null || typeof value!=='object') return;
+  var comments=common.getComment(value);
+  if (comments) common.removeComment(value);
+
+  var i, length; // loop
+  var any, res;
+  if (Object.prototype.toString.apply(value) === '[object Array]') {
+    res={ a: [] };
+    for (i=0, length=value.length; i<length; i++) {
+      if (saveComment(res.a, i, comments.a[i], extractComments(value[i])))
+        any=true;
+    }
+    if (!any && comments.e){
+      res.e=makeComment(comments.e[0], comments.e[1]);
+      any=true;
+    }
+  } else {
+    res={ s: {} };
+
+    // get key order (comments and current)
+    var keys, currentKeys=Object.keys(value);
+    if (comments && comments.o) {
+      keys=[];
+      comments.o.concat(currentKeys).forEach(function(key) {
+        if (Object.prototype.hasOwnProperty.call(value, key) && keys.indexOf(key)<0)
+          keys.push(key);
+      });
+    } else keys=currentKeys;
+    res.o=keys;
+
+    // extract comments
+    for (i=0, length=keys.length; i<length; i++) {
+      var key=keys[i];
+      if (saveComment(res.s, key, comments.c[key], extractComments(value[key])))
+        any=true;
+    }
+    if (!any && comments.e) {
+      res.e=makeComment(comments.e[0], comments.e[1]);
+      any=true;
+    }
+  }
+
+  if (root && comments && comments.r) {
+    res.r=makeComment(comments.r[0], comments.r[1]);
+  }
+
+  return any?res:undefined;
+}
+
+function mergeStr() {
+  var res="";
+  [].forEach.call(arguments, function(c) {
+    if (c && c.trim()!=="") {
+      if (res) res+="; ";
+      res+=c.trim();
+    }
+  });
+  return res;
+}
+
+function mergeComments(comments, value) {
+  var dropped=[];
+  merge(comments, value, dropped, []);
+
+  // append dropped comments:
+  if (dropped.length>0) {
+    var text=rootComment(value, null, 1);
+    text+="\n# Orphaned comments:\n";
+    dropped.forEach(function(c) {
+      text+=("# "+c.path.join('/')+": "+mergeStr(c.b, c.a, c.e)).replace("\n", "\\n ")+"\n";
+    });
+    rootComment(value, text, 1);
+  }
+}
+
+function saveComment(res, key, item, col) {
+  var c=makeComment(item?item[0]:undefined, item?item[1]:undefined, col);
+  if (c) res[key]=c;
+  return c;
+}
+
+function droppedComment(path, c) {
+  var res=makeComment(c.b, c.a);
+  res.path=path;
+  return res;
+}
+
+function dropAll(comments, dropped, path) {
+
+  if (!comments) return;
+
+  var i, length; // loop
+
+  if (comments.a) {
+
+    for (i=0, length=comments.a.length; i<length; i++) {
+      var kpath=path.slice().concat([i]);
+      var c=comments.a[i];
+      if (c) {
+        dropped.push(droppedComment(kpath, c));
+        dropAll(c.x, dropped, kpath);
+      }
+    }
+  } else if (comments.o) {
+
+    comments.o.forEach(function(key) {
+      var kpath=path.slice().concat([key]);
+      var c=comments.s[key];
+      if (c) {
+        dropped.push(droppedComment(kpath, c));
+        dropAll(c.x, dropped, kpath);
+      }
+    });
+  }
+
+  if (comments.e)
+    dropped.push(droppedComment(path, comments.e));
+}
+
+function merge(comments, value, dropped, path) {
+
+  if (!comments) return;
+  if (value===null || typeof value!=='object') {
+    dropAll(comments, dropped, path);
+    return;
+  }
+
+  var i, length; // loop
+  var setComments=common.createComment(value);
+
+  if (path.length===0 && comments.r)
+    setComments.r=[comments.r.b, comments.r.a];
+
+  if (Object.prototype.toString.apply(value) === '[object Array]') {
+    setComments.a=[];
+    for (i=0, length=(comments.a||[]).length; i<length; i++) {
+      var kpath=path.slice().concat([i]);
+      var c=comments.a[i];
+      if (!c) continue;
+      if (i<value.length) {
+        setComments.a.push([c.b, c.a]);
+        merge(c.x, value[i], dropped, kpath);
+      } else {
+        dropped.push(droppedComment(kpath, c));
+        dropAll(c.x, dropped, kpath);
+      }
+    }
+    if (i===0 && comments.e) setComments.e=[comments.e.b, comments.e.a];
+  } else {
+    setComments.c={};
+    setComments.o=[];
+    (comments.o||[]).forEach(function(key) {
+      var kpath=path.slice().concat([key]);
+      var c=comments.s[key];
+      if (Object.prototype.hasOwnProperty.call(value, key)) {
+        setComments.o.push(key);
+        if (c) {
+          setComments.c[key]=[c.b, c.a];
+          merge(c.x, value[key], dropped, kpath);
+        }
+      } else if (c) {
+        dropped.push(droppedComment(kpath, c));
+        dropAll(c.x, dropped, kpath);
+      }
+    });
+    if (comments.e) setComments.e=[comments.e.b, comments.e.a];
+  }
+}
+
+function rootComment(value, setText, header) {
+  var comment=common.createComment(value, common.getComment(value));
+  if (!comment.r) comment.r=["", ""];
+  if (setText || setText==="") comment.r[header]=common.forceComment(setText);
+  return comment.r[header]||"";
+}
+
+module.exports={
+  extract: function(value) { return extractComments(value, true); },
+  merge: mergeComments,
+  header: function(value, setText) { return rootComment(value, setText, 0); },
+  footer: function(value, setText) { return rootComment(value, setText, 1); },
+};
+
+},{"./hjson-common":2}],2:[function(require,module,exports){
+/* Hjson http://hjson.org */
+"use strict";
+
+var os=require('os'); // will be {} when used in a browser
+
+function tryParseNumber(text, stopAtNext) {
+
+  // try to parse a number
+
+  var number, string = '', leadingZeros = 0, testLeading = true;
+  var at = 0;
+  var ch;
+  function next() {
+    ch = text.charAt(at);
+    at++;
+    return ch;
+  }
+
+  next();
+  if (ch === '-') {
+    string = '-';
+    next();
+  }
+  while (ch >= '0' && ch <= '9') {
+    if (testLeading) {
+      if (ch == '0') leadingZeros++;
+      else testLeading = false;
+    }
+    string += ch;
+    next();
+  }
+  if (testLeading) leadingZeros--; // single 0 is allowed
+  if (ch === '.') {
+    string += '.';
+    while (next() && ch >= '0' && ch <= '9')
+      string += ch;
+  }
+  if (ch === 'e' || ch === 'E') {
+    string += ch;
+    next();
+    if (ch === '-' || ch === '+') {
+      string += ch;
+      next();
+    }
+    while (ch >= '0' && ch <= '9') {
+      string += ch;
+      next();
+    }
+  }
+
+  // skip white/to (newline)
+  while (ch && ch <= ' ') next();
+
+  if (stopAtNext) {
+    // end scan if we find a punctuator character like ,}] or a comment
+    if (ch === ',' || ch === '}' || ch === ']' ||
+      ch === '#' || ch === '/' && (text[at] === '/' || text[at] === '*')) ch = 0;
+  }
+
+  number = +string;
+  if (ch || leadingZeros || !isFinite(number)) return undefined;
+  else return number;
+}
+
+function createComment(value, comment) {
+  if (Object.defineProperty) Object.defineProperty(value, "__COMMENTS__", { enumerable: false, writable: true });
+  return (value.__COMMENTS__ = comment||{});
+}
+
+function removeComment(value) {
+  Object.defineProperty(value, "__COMMENTS__", { value: undefined });
+}
+
+function getComment(value) {
+  return value.__COMMENTS__;
+}
+
+function forceComment(text) {
+  if (!text) return "";
+  var a = text.split('\n');
+  var str, i, j, len;
+  for (j = 0; j < a.length; j++) {
+    str = a[j];
+    len = str.length;
+    for (i = 0; i < len; i++) {
+      var c = str[i];
+      if (c === '#') break;
+      else if (c === '/' && (str[i+1] === '/' || str[i+1] === '*')) {
+        if (str[i+1] === '*') j = a.length; // assume /**/ covers whole block, bail out
+        break;
+      }
+      else if (c > ' ') {
+        a[j] = '# ' + str;
+        break;
+      }
+    }
+  }
+  return a.join('\n');
+}
+
+module.exports = {
+  EOL: os.EOL || '\n',
+  tryParseNumber: tryParseNumber,
+  createComment: createComment,
+  removeComment: removeComment,
+  getComment: getComment,
+  forceComment: forceComment,
+};
+
+},{"os":8}],3:[function(require,module,exports){
+/* Hjson http://hjson.org */
+"use strict";
+
+function loadDsf(col, type) {
+
+  if (Object.prototype.toString.apply(col) !== '[object Array]') {
+    if (col) throw new Error("dsf option must contain an array!");
+    else return nopDsf;
+  } else if (col.length === 0) return nopDsf;
+
+  var dsf = [];
+  function isFunction(f) { return {}.toString.call(f) === '[object Function]'; }
+
+  col.forEach(function(x) {
+    if (!x.name || !isFunction(x.parse) || !isFunction(x.stringify))
+      throw new Error("extension does not match the DSF interface");
+    dsf.push(function() {
+      try {
+        if (type == "parse") {
+          return x.parse.apply(null, arguments);
+        } else if (type == "stringify") {
+          var res=x.stringify.apply(null, arguments);
+          // check result
+          if (res !== undefined && (typeof res !== "string" ||
+            res.length === 0 ||
+            res[0] === '"' ||
+            [].some.call(res, function(c) { return isInvalidDsfChar(c); })))
+            throw new Error("value may not be empty, start with a quote or contain a punctuator character except colon: " + res);
+          return res;
+        } else throw new Error("Invalid type");
+      } catch (e) {
+        throw new Error("DSF-"+x.name+" failed; "+e.message);
+      }
+    });
+  });
+
+  return runDsf.bind(null, dsf);
+}
+
+function runDsf(dsf, value) {
+  if (dsf) {
+    for (var i = 0; i < dsf.length; i++) {
+      var res = dsf[i](value);
+      if (res !== undefined) return res;
+    }
+  }
+}
+
+function nopDsf(/*value*/) {
+}
+
+function isInvalidDsfChar(c) {
+  return c === '{' || c === '}' || c === '[' || c === ']' || c === ',';
+}
+
+
+function math(/*opt*/) {
+  return {
+    name: "math",
+    parse: function (value) {
+      switch (value) {
+        case "+inf":
+        case "inf":
+        case "+Inf":
+        case "Inf": return Infinity;
+        case "-inf":
+        case "-Inf": return -Infinity;
+        case "nan":
+        case "NaN": return NaN;
+      }
+    },
+    stringify: function (value) {
+      if (typeof value !== 'number') return;
+      if (1 / value === -Infinity) return "-0"; // 0 === -0
+      if (value === Infinity) return "Inf";
+      if (value === -Infinity) return "-Inf";
+      if (isNaN(value)) return "NaN";
+    },
+  };
+}
+math.description="support for Inf/inf, -Inf/-inf, Nan/naN and -0";
+
+function hex(opt) {
+  var out=opt && opt.out;
+  return {
+    name: "hex",
+    parse: function (value) {
+      if (/^0x[0-9A-Fa-f]+$/.test(value))
+        return parseInt(value, 16);
+    },
+    stringify: function (value) {
+      if (out && Number.isInteger(value))
+        return "0x"+value.toString(16);
+    },
+  };
+}
+hex.description="parse hexadecimal numbers prefixed with 0x";
+
+function date(/*opt*/) {
+  return {
+    name: "date",
+    parse: function (value) {
+      if (/^\d{4}-\d{2}-\d{2}$/.test(value) ||
+        /^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:.\d+)(?:Z|[+-]\d{2}:\d{2})$/.test(value)) {
+        var dt = Date.parse(value);
+        if (!isNaN(dt)) return new Date(dt);
+      }
+    },
+    stringify: function (value) {
+      if (Object.prototype.toString.call(value) === '[object Date]') {
+        var dt = value.toISOString();
+        if (dt.indexOf("T00:00:00.000Z", dt.length - 14) !== -1) return dt.substr(0, 10);
+        else return dt;
+      }
+    },
+  };
+}
+date.description="support ISO dates";
+
+module.exports = {
+  loadDsf: loadDsf,
+  std: {
+    math: math,
+    hex: hex,
+    date: date,
+  },
+};
+
+},{}],4:[function(require,module,exports){
+/* Hjson http://hjson.org */
+"use strict";
+
+module.exports = function(source, opt) {
+
+  var common = require("./hjson-common");
+  var dsf = require("./hjson-dsf");
+
+  var text;
+  var at;   // The index of the current character
+  var ch;   // The current character
+  var escapee = {
+    '"': '"',
+    "'": "'",
+    '\\': '\\',
+    '/': '/',
+    b:  '\b',
+    f:  '\f',
+    n:  '\n',
+    r:  '\r',
+    t:  '\t'
+  };
+
+  var keepComments;
+  var runDsf; // domain specific formats
+
+  function resetAt() {
+    at = 0;
+    ch = ' ';
+  }
+
+  function isPunctuatorChar(c) {
+    return c === '{' || c === '}' || c === '[' || c === ']' || c === ',' || c === ':';
+  }
+
+  // Call error when something is wrong.
+  function error(m) {
+    var i, col=0, line=1;
+    for (i = at-1; i > 0 && text[i] !== '\n'; i--, col++) {}
+    for (; i > 0; i--) if (text[i] === '\n') line++;
+    throw new Error(m + " at line " + line + "," + col + " >>>" + text.substr(at-col, 20) + " ...");
+  }
+
+  function next() {
+    // get the next character.
+    ch = text.charAt(at);
+    at++;
+    return ch;
+  }
+
+  function peek(offs) {
+    // range check is not required
+    return text.charAt(at + offs);
+  }
+
+  function string(allowML) {
+    // Parse a string value.
+    // callers make sure that (ch === '"' || ch === "'")
+    var string = '';
+
+    // When parsing for string values, we must look for "/' and \ characters.
+    var exitCh = ch;
+    while (next()) {
+      if (ch === exitCh) {
+        next();
+        if (allowML && exitCh === "'" && ch === "'" && string.length === 0) {
+          // ''' indicates a multiline string
+          next();
+          return mlString();
+        } else return string;
+      }
+      if (ch === '\\') {
+        next();
+        if (ch === 'u') {
+          var uffff = 0;
+          for (var i = 0; i < 4; i++) {
+            next();
+            var c = ch.charCodeAt(0), hex;
+            if (ch >= '0' && ch <= '9') hex = c - 48;
+            else if (ch >= 'a' && ch <= 'f') hex = c - 97 + 0xa;
+            else if (ch >= 'A' && ch <= 'F') hex = c - 65 + 0xa;
+            else error("Bad \\u char " + ch);
+            uffff = uffff * 16 + hex;
+          }
+          string += String.fromCharCode(uffff);
+        } else if (typeof escapee[ch] === 'string') {
+          string += escapee[ch];
+        } else break;
+      } else if (ch === '\n' || ch === '\r') {
+        error("Bad string containing newline");
+      } else {
+        string += ch;
+      }
+    }
+    error("Bad string");
+  }
+
+  function mlString() {
+    // Parse a multiline string value.
+    var string = '', triple = 0;
+
+    // we are at ''' +1 - get indent
+    var indent = 0;
+    for (;;) {
+      var c=peek(-indent-5);
+      if (!c || c === '\n') break;
+      indent++;
+    }
+
+    function skipIndent() {
+      var skip = indent;
+      while (ch && ch <= ' ' && ch !== '\n' && skip-- > 0) next();
+    }
+
+    // skip white/to (newline)
+    while (ch && ch <= ' ' && ch !== '\n') next();
+    if (ch === '\n') { next(); skipIndent(); }
+
+    // When parsing multiline string values, we must look for ' characters.
+    for (;;) {
+      if (!ch) {
+        error("Bad multiline string");
+      } else if (ch === '\'') {
+        triple++;
+        next();
+        if (triple === 3) {
+          if (string.slice(-1) === '\n') string=string.slice(0, -1); // remove last EOL
+          return string;
+        } else continue;
+      } else {
+        while (triple > 0) {
+          string += '\'';
+          triple--;
+        }
+      }
+      if (ch === '\n') {
+        string += '\n';
+        next();
+        skipIndent();
+      } else {
+        if (ch !== '\r') string += ch;
+        next();
+      }
+    }
+  }
+
+  function keyname() {
+    // quotes for keys are optional in Hjson
+    // unless they include {}[],: or whitespace.
+
+    if (ch === '"' || ch === "'") return string(false);
+
+    var name = "", start = at, space = -1;
+    for (;;) {
+      if (ch === ':') {
+        if (!name) error("Found ':' but no key name (for an empty key name use quotes)");
+        else if (space >=0 && space !== name.length) { at = start + space; error("Found whitespace in your key name (use quotes to include)"); }
+        return name;
+      } else if (ch <= ' ') {
+        if (!ch) error("Found EOF while looking for a key name (check your syntax)");
+        else if (space < 0) space = name.length;
+      } else if (isPunctuatorChar(ch)) {
+        error("Found '" + ch + "' where a key name was expected (check your syntax or use quotes if the key name includes {}[],: or whitespace)");
+      } else {
+        name += ch;
+      }
+      next();
+    }
+  }
+
+  function white() {
+    while (ch) {
+      // Skip whitespace.
+      while (ch && ch <= ' ') next();
+      // Hjson allows comments
+      if (ch === '#' || ch === '/' && peek(0) === '/') {
+        while (ch && ch !== '\n') next();
+      } else if (ch === '/' && peek(0) === '*') {
+        next(); next();
+        while (ch && !(ch === '*' && peek(0) === '/')) next();
+        if (ch) { next(); next(); }
+      } else break;
+    }
+  }
+
+  function tfnns() {
+    // Hjson strings can be quoteless
+    // returns string, true, false, or null.
+    var value = ch;
+    if (isPunctuatorChar(ch))
+      error("Found a punctuator character '" + ch + "' when expecting a quoteless string (check your syntax)");
+
+    for(;;) {
+      next();
+      // (detection of ml strings was moved to string())
+      var isEol = ch === '\r' || ch === '\n' || ch === '';
+      if (isEol ||
+        ch === ',' || ch === '}' || ch === ']' ||
+        ch === '#' ||
+        ch === '/' && (peek(0) === '/' || peek(0) === '*')
+        ) {
+        // this tests for the case of {true|false|null|num}
+        // followed by { ',' | '}' | ']' | '#' | '//' | '/*' }
+        // which needs to be parsed as the specified value
+        var chf = value[0];
+        switch (chf) {
+          case 'f': if (value.trim() === "false") return false; break;
+          case 'n': if (value.trim() === "null") return null; break;
+          case 't': if (value.trim() === "true") return true; break;
+          default:
+            if (chf === '-' || chf >= '0' && chf <= '9') {
+              var n = common.tryParseNumber(value);
+              if (n !== undefined) return n;
+            }
+        }
+        if (isEol) {
+          // remove any whitespace at the end (ignored in quoteless strings)
+          value = value.trim();
+          var dsfValue = runDsf(value);
+          return dsfValue !== undefined ? dsfValue : value;
+        }
+      }
+      value += ch;
+    }
+  }
+
+  function getComment(cAt, first) {
+    var i;
+    cAt--;
+    // remove trailing whitespace
+    // but only up to EOL
+    for (i = at - 2; i > cAt && text[i] <= ' ' && text[i] !== '\n'; i--);
+    if (text[i] === '\n') i--;
+    if (text[i] === '\r') i--;
+    var res = text.substr(cAt, i-cAt+1);
+    // return if we find anything other than whitespace
+    for (i = 0; i < res.length; i++) {
+      if (res[i] > ' ') {
+        var j = res.indexOf('\n');
+        if (j >= 0) {
+          var c = [res.substr(0, j), res.substr(j+1)];
+          if (first && c[0].trim().length === 0) c.shift();
+          return c;
+        } else return [res];
+      }
+    }
+    return [];
+  }
+
+  function errorClosingHint(value) {
+    function search(value, ch) {
+      var i, k, length, res;
+      switch (typeof value) {
+        case 'string':
+          if (value.indexOf(ch) >= 0) res = value;
+          break;
+        case 'object':
+          if (Object.prototype.toString.apply(value) === '[object Array]') {
+            for (i = 0, length = value.length; i < length; i++) {
+              res=search(value[i], ch) || res;
+            }
+          } else {
+            for (k in value) {
+              if (!Object.prototype.hasOwnProperty.call(value, k)) continue;
+              res=search(value[k], ch) || res;
+            }
+          }
+      }
+      return res;
+    }
+
+    function report(ch) {
+      var possibleErr=search(value, ch);
+      if (possibleErr) {
+        return "found '"+ch+"' in a string value, your mistake could be with:\n"+
+          "  > "+possibleErr+"\n"+
+          "  (unquoted strings contain everything up to the next line!)";
+      } else return "";
+    }
+
+    return report('}') || report(']');
+  }
+
+  function array() {
+    // Parse an array value.
+    // assuming ch === '['
+
+    var array = [];
+    var comments, cAt, nextComment;
+    try {
+      if (keepComments) comments = common.createComment(array, { a: [] });
+
+      next();
+      cAt = at;
+      white();
+      if (comments) nextComment = getComment(cAt, true).join('\n');
+      if (ch === ']') {
+        next();
+        if (comments) comments.e = [nextComment];
+        return array;  // empty array
+      }
+
+      while (ch) {
+        array.push(value());
+        cAt = at;
+        white();
+        // in Hjson the comma is optional and trailing commas are allowed
+        // note that we do not keep comments before the , if there are any
+        if (ch === ',') { next(); cAt = at; white(); }
+        if (comments) {
+          var c = getComment(cAt);
+          comments.a.push([nextComment||"", c[0]||""]);
+          nextComment = c[1];
+        }
+        if (ch === ']') {
+          next();
+          if (comments) comments.a[comments.a.length-1][1] += nextComment||"";
+          return array;
+        }
+        white();
+      }
+
+      error("End of input while parsing an array (missing ']')");
+    } catch (e) {
+      e.hint=e.hint||errorClosingHint(array);
+      throw e;
+    }
+  }
+
+  function object(withoutBraces) {
+    // Parse an object value.
+
+    var key = "", object = {};
+    var comments, cAt, nextComment;
+
+    try {
+      if (keepComments) comments = common.createComment(object, { c: {}, o: []  });
+
+      if (!withoutBraces) {
+        // assuming ch === '{'
+        next();
+        cAt = at;
+      } else cAt = 1;
+
+      white();
+      if (comments) nextComment = getComment(cAt, true).join('\n');
+      if (ch === '}' && !withoutBraces) {
+        if (comments) comments.e = [nextComment];
+        next();
+        return object;  // empty object
+      }
+      while (ch) {
+        key = keyname();
+        white();
+        if (ch !== ':') error("Expected ':' instead of '" + ch + "'");
+        next();
+        // duplicate keys overwrite the previous value
+        object[key] = value();
+        cAt = at;
+        white();
+        // in Hjson the comma is optional and trailing commas are allowed
+        // note that we do not keep comments before the , if there are any
+        if (ch === ',') { next(); cAt = at; white(); }
+        if (comments) {
+          var c = getComment(cAt);
+          comments.c[key] = [nextComment||"", c[0]||""];
+          nextComment = c[1];
+          comments.o.push(key);
+        }
+        if (ch === '}' && !withoutBraces) {
+          next();
+          if (comments) comments.c[key][1] += nextComment||"";
+          return object;
+        }
+        white();
+      }
+
+      if (withoutBraces) return object;
+      else error("End of input while parsing an object (missing '}')");
+    } catch (e) {
+      e.hint=e.hint||errorClosingHint(object);
+      throw e;
+    }
+  }
+
+  function value() {
+    // Parse a Hjson value. It could be an object, an array, a string, a number or a word.
+
+    white();
+    switch (ch) {
+      case '{': return object();
+      case '[': return array();
+      case "'":
+      case '"': return string(true);
+      default: return tfnns();
+    }
+  }
+
+  function checkTrailing(v, c) {
+    var cAt = at;
+    white();
+    if (ch) error("Syntax error, found trailing characters");
+    if (keepComments) {
+      var b = c.join('\n'), a = getComment(cAt).join('\n');
+      if (a || b) {
+        var comments = common.createComment(v, common.getComment(v));
+        comments.r = [b, a];
+      }
+    }
+    return v;
+  }
+
+  function rootValue() {
+    white();
+    var c = keepComments ? getComment(1) : null;
+    switch (ch) {
+      case '{': return checkTrailing(object(), c);
+      case '[': return checkTrailing(array(), c);
+      default: return checkTrailing(value(), c);
+    }
+  }
+
+  function legacyRootValue() {
+    // Braces for the root object are optional
+    white();
+    var c = keepComments ? getComment(1) : null;
+    switch (ch) {
+      case '{': return checkTrailing(object(), c);
+      case '[': return checkTrailing(array(), c);
+    }
+
+    try {
+      // assume we have a root object without braces
+      return checkTrailing(object(true), c);
+    } catch (e) {
+      // test if we are dealing with a single JSON value instead (true/false/null/num/"")
+      resetAt();
+      try { return checkTrailing(value(), c); }
+      catch (e2) { throw e; } // throw original error
+    }
+  }
+
+  if (typeof source!=="string") throw new Error("source is not a string");
+  var dsfDef = null;
+  var legacyRoot = true;
+  if (opt && typeof opt === 'object') {
+    keepComments = opt.keepWsc;
+    dsfDef = opt.dsf;
+    legacyRoot = opt.legacyRoot !== false; // default true
+  }
+  runDsf = dsf.loadDsf(dsfDef, "parse");
+  text = source;
+  resetAt();
+  return legacyRoot ? legacyRootValue() : rootValue();
+};
+
+},{"./hjson-common":2,"./hjson-dsf":3}],5:[function(require,module,exports){
+/* Hjson http://hjson.org */
+"use strict";
+
+module.exports = function(data, opt) {
+
+  var common = require("./hjson-common");
+  var dsf = require("./hjson-dsf");
+
+  var plainToken = {
+    obj:  [ '{', '}' ],
+    arr:  [ '[', ']' ],
+    key:  [ '',  '' ],
+    qkey: [ '"', '"' ],
+    col:  [ ':', '' ],
+    com:  [ ',', '' ],
+    str:  [ '', '' ],
+    qstr: [ '"', '"' ],
+    mstr: [ "'''", "'''" ],
+    num:  [ '', '' ],
+    lit:  [ '', '' ],
+    dsf:  [ '', '' ],
+    esc:  [ '\\', '' ],
+    uni:  [ '\\u', '' ],
+    rem:  [ '', '' ],
+  };
+
+  // options
+  var eol = common.EOL;
+  var indent = '  ';
+  var keepComments = false;
+  var bracesSameLine = false;
+  var quoteKeys = false;
+  var quoteStrings = false;
+  var condense = 0;
+  var multiline = 1; // std=1, no-tabs=2, off=0
+  var separator = ''; // comma separator
+  var dsfDef = null;
+  var token = plainToken;
+
+  if (opt && typeof opt === 'object') {
+    opt.quotes = opt.quotes === 'always' ? 'strings' : opt.quotes; // legacy
+
+    if (opt.eol === '\n' || opt.eol === '\r\n') eol = opt.eol;
+    keepComments = opt.keepWsc;
+    condense = opt.condense || 0;
+    bracesSameLine = opt.bracesSameLine;
+    quoteKeys = opt.quotes === 'all' || opt.quotes === 'keys';
+    quoteStrings = opt.quotes === 'all' || opt.quotes === 'strings' || opt.separator === true;
+    if (quoteStrings || opt.multiline == 'off') multiline = 0;
+    else multiline = opt.multiline == 'no-tabs' ? 2 : 1;
+    separator = opt.separator === true ? token.com[0] : '';
+    dsfDef = opt.dsf;
+
+    // If the space parameter is a number, make an indent string containing that
+    // many spaces. If it is a string, it will be used as the indent string.
+
+    if (typeof opt.space === 'number') {
+      indent = new Array(opt.space + 1).join(' ');
+    } else if (typeof opt.space === 'string') {
+      indent = opt.space;
+    }
+
+    if (opt.colors === true) {
+      token = {
+        obj:  [ '\x1b[37m{\x1b[0m', '\x1b[37m}\x1b[0m' ],
+        arr:  [ '\x1b[37m[\x1b[0m', '\x1b[37m]\x1b[0m' ],
+        key:  [ '\x1b[33m',  '\x1b[0m' ],
+        qkey: [ '\x1b[33m"', '"\x1b[0m' ],
+        col:  [ '\x1b[37m:\x1b[0m', '' ],
+        com:  [ '\x1b[37m,\x1b[0m', '' ],
+        str:  [ '\x1b[37;1m', '\x1b[0m' ],
+        qstr: [ '\x1b[37;1m"', '"\x1b[0m' ],
+        mstr: [ "\x1b[37;1m'''", "'''\x1b[0m" ],
+        num:  [ '\x1b[36;1m', '\x1b[0m' ],
+        lit:  [ '\x1b[36m', '\x1b[0m' ],
+        dsf:  [ '\x1b[37m', '\x1b[0m' ],
+        esc:  [ '\x1b[31m\\', '\x1b[0m' ],
+        uni:  [ '\x1b[31m\\u', '\x1b[0m' ],
+        rem:  [ '\x1b[35m', '\x1b[0m' ],
+      };
+    }
+
+    var i, ckeys=Object.keys(plainToken);
+    for (i = ckeys.length - 1; i >= 0; i--) {
+      var k = ckeys[i];
+      token[k].push(plainToken[k][0].length, plainToken[k][1].length);
+    }
+  }
+
+  //
+  var runDsf; // domain specific formats
+
+  var commonRange='\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff';
+  // needsEscape tests if the string can be written without escapes
+  var needsEscape = new RegExp('[\\\\\\"\x00-\x1f'+commonRange+']', 'g');
+  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\ and \")
+  var needsQuotes = new RegExp('^\\s|^"|^\'|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f'+commonRange+']', 'g');
+  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \n, \r, \\, \", \t unless multines is 'std')
+  var needsEscapeML = new RegExp('\'\'\'|^[\\s]+$|[\x00-'+(multiline === 2 ? '\x09' : '\x08')+'\x0b\x0c\x0e-\x1f'+commonRange+']', 'g');
+  // starts with a keyword and optionally is followed by a comment
+  var startsWithKeyword = new RegExp('^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$');
+  var meta = {
+    // table of character substitutions
+    '\b': 'b',
+    '\t': 't',
+    '\n': 'n',
+    '\f': 'f',
+    '\r': 'r',
+    '"' : '"',
+    '\\': '\\'
+  };
+  var needsEscapeName = /[,\{\[\}\]\s:#"']|\/\/|\/\*/;
+  var gap = '';
+  //
+  var wrapLen = 0;
+
+  function wrap(tk, v) {
+    wrapLen += tk[0].length + tk[1].length - tk[2] - tk[3];
+    return tk[0] + v + tk[1];
+  }
+
+  function quoteReplace(string) {
+    return string.replace(needsEscape, function (a) {
+      var c = meta[a];
+      if (typeof c === 'string') return wrap(token.esc, c);
+      else return wrap(token.uni, ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
+    });
+  }
+
+  function quote(string, gap, hasComment, isRootObject) {
+    if (!string) return wrap(token.qstr, '');
+
+    needsQuotes.lastIndex = 0;
+    startsWithKeyword.lastIndex = 0;
+
+    // Check if we can insert this string without quotes
+    // see hjson syntax (must not parse as true, false, null or number)
+
+    if (quoteStrings || hasComment ||
+      needsQuotes.test(string) ||
+      common.tryParseNumber(string, true) !== undefined ||
+      startsWithKeyword.test(string)) {
+
+      // If the string contains no control characters, no quote characters, and no
+      // backslash characters, then we can safely slap some quotes around it.
+      // Otherwise we first check if the string can be expressed in multiline
+      // format or we must replace the offending characters with safe escape
+      // sequences.
+
+      needsEscape.lastIndex = 0;
+      needsEscapeML.lastIndex = 0;
+      if (!needsEscape.test(string)) return wrap(token.qstr, string);
+      else if (!needsEscapeML.test(string) && !isRootObject && multiline) return mlString(string, gap);
+      else return wrap(token.qstr, quoteReplace(string));
+    } else {
+      // return without quotes
+      return wrap(token.str, string);
+    }
+  }
+
+  function mlString(string, gap) {
+    // wrap the string into the ''' (multiline) format
+
+    var i, a = string.replace(/\r/g, "").split('\n');
+    gap += indent;
+
+    if (a.length === 1) {
+      // The string contains only a single line. We still use the multiline
+      // format as it avoids escaping the \ character (e.g. when used in a
+      // regex).
+      return wrap(token.mstr, a[0]);
+    } else {
+      var res = eol + gap + token.mstr[0];
+      for (i = 0; i < a.length; i++) {
+        res += eol;
+        if (a[i]) res += gap + a[i];
+      }
+      return res + eol + gap + token.mstr[1];
+    }
+  }
+
+  function quoteKey(name) {
+    if (!name) return '""';
+
+    // Check if we can insert this key without quotes
+
+    if (quoteKeys || needsEscapeName.test(name)) {
+      needsEscape.lastIndex = 0;
+      return wrap(token.qkey, needsEscape.test(name) ? quoteReplace(name) : name);
+    } else {
+      // return without quotes
+      return wrap(token.key, name);
+    }
+  }
+
+  function str(value, hasComment, noIndent, isRootObject) {
+    // Produce a string from value.
+
+    function startsWithNL(str) { return str && str[str[0] === '\r' ? 1 : 0] === '\n'; }
+    function commentOnThisLine(str) { return str && !startsWithNL(str); }
+    function makeComment(str, prefix, trim) {
+      if (!str) return "";
+      str = common.forceComment(str);
+      var i, len = str.length;
+      for (i = 0; i < len && str[i] <= ' '; i++) {}
+      if (trim && i > 0) str = str.substr(i);
+      if (i < len) return prefix + wrap(token.rem, str);
+      else return str;
+    }
+
+    // What happens next depends on the value's type.
+
+    // check for DSF
+    var dsfValue = runDsf(value);
+    if (dsfValue !== undefined) return wrap(token.dsf, dsfValue);
+
+    switch (typeof value) {
+      case 'string':
+        return quote(value, gap, hasComment, isRootObject);
+
+      case 'number':
+        // JSON numbers must be finite. Encode non-finite numbers as null.
+        return isFinite(value) ? wrap(token.num, String(value)) : wrap(token.lit, 'null');
+
+      case 'boolean':
+        return wrap(token.lit, String(value));
+
+      case 'object':
+        // If the type is 'object', we might be dealing with an object or an array or
+        // null.
+
+        // Due to a specification blunder in ECMAScript, typeof null is 'object',
+        // so watch out for that case.
+
+        if (!value) return wrap(token.lit, 'null');
+
+        var comments; // whitespace & comments
+        if (keepComments) comments = common.getComment(value);
+
+        var isArray = Object.prototype.toString.apply(value) === '[object Array]';
+
+        // Make an array to hold the partial results of stringifying this object value.
+        var mind = gap;
+        gap += indent;
+        var eolMind = eol + mind;
+        var eolGap = eol + gap;
+        var prefix = noIndent || bracesSameLine ? '' : eolMind;
+        var partial = [];
+        var setsep;
+        // condense helpers:
+        var cpartial = condense ? [] : null;
+        var saveQuoteStrings = quoteStrings, saveMultiline = multiline;
+        var iseparator = separator ? '' : token.com[0];
+        var cwrapLen = 0;
+
+        var i, length; // loop
+        var k, v, vs; // key, value
+        var c, ca;
+        var res, cres;
+
+        if (isArray) {
+          // The value is an array. Stringify every element. Use null as a placeholder
+          // for non-JSON values.
+
+          for (i = 0, length = value.length; i < length; i++) {
+            setsep = i < length -1;
+            if (comments) {
+              c = comments.a[i]||[];
+              ca = commentOnThisLine(c[1]);
+              partial.push(makeComment(c[0], "\n") + eolGap);
+              if (cpartial && (c[0] || c[1] || ca)) cpartial = null;
+            }
+            else partial.push(eolGap);
+            wrapLen = 0;
+            v = value[i];
+            partial.push(str(v, comments ? ca : false, true) + (setsep ? separator : ''));
+            if (cpartial) {
+              // prepare the condensed version
+              switch (typeof v) {
+                case 'string':
+                  wrapLen = 0;
+                  quoteStrings = true; multiline = 0;
+                  cpartial.push(str(v, false, true) + (setsep ? token.com[0] : ''));
+                  quoteStrings = saveQuoteStrings; multiline = saveMultiline;
+                  break;
+                case 'object': if (v) { cpartial = null; break; } // falls through
+                default: cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : '')); break;
+              }
+              if (setsep) wrapLen += token.com[0].length - token.com[2];
+              cwrapLen += wrapLen;
+            }
+            if (comments && c[1]) partial.push(makeComment(c[1], ca ? " " : "\n", ca));
+          }
+
+          if (length === 0) {
+            // when empty
+            if (comments && comments.e) partial.push(makeComment(comments.e[0], "\n") + eolMind);
+          }
+          else partial.push(eolMind);
+
+          // Join all of the elements together, separated with newline, and wrap them in
+          // brackets.
+
+          if (partial.length === 0) res = wrap(token.arr, '');
+          else {
+            res = prefix + wrap(token.arr, partial.join(''));
+            // try if the condensed version can fit (parent key name is not included)
+            if (cpartial) {
+              cres = cpartial.join(' ');
+              if (cres.length - cwrapLen <= condense) res = wrap(token.arr, cres);
+            }
+          }
+        } else {
+          // Otherwise, iterate through all of the keys in the object.
+          var keys = comments ? comments.o.slice() : [];
+          for (k in value) {
+            if (Object.prototype.hasOwnProperty.call(value, k) && keys.indexOf(k) < 0)
+              keys.push(k);
+          }
+
+          for (i = 0, length = keys.length; i < length; i++) {
+            setsep = i < length - 1;
+            k = keys[i];
+            if (comments) {
+              c = comments.c[k]||[];
+              ca = commentOnThisLine(c[1]);
+              partial.push(makeComment(c[0], "\n") + eolGap);
+              if (cpartial && (c[0] || c[1] || ca)) cpartial = null;
+            }
+            else partial.push(eolGap);
+
+            wrapLen = 0;
+            v = value[k];
+            vs = str(v, comments && ca);
+            partial.push(quoteKey(k) + token.col[0] + (startsWithNL(vs) ? '' : ' ') + vs + (setsep ? separator : ''));
+            if (comments && c[1]) partial.push(makeComment(c[1], ca ? " " : "\n", ca));
+            if (cpartial) {
+              // prepare the condensed version
+              switch (typeof v) {
+                case 'string':
+                  wrapLen = 0;
+                  quoteStrings = true; multiline = 0;
+                  vs = str(v, false);
+                  quoteStrings = saveQuoteStrings; multiline = saveMultiline;
+                  cpartial.push(quoteKey(k) + token.col[0] + ' ' + vs + (setsep ? token.com[0] : ''));
+                  break;
+                case 'object': if (v) { cpartial = null; break; } // falls through
+                default: cpartial.push(partial[partial.length - 1] + (setsep ? iseparator : '')); break;
+              }
+              wrapLen += token.col[0].length - token.col[2];
+              if (setsep) wrapLen += token.com[0].length - token.com[2];
+              cwrapLen += wrapLen;
+            }
+          }
+          if (length === 0) {
+            // when empty
+            if (comments && comments.e) partial.push(makeComment(comments.e[0], "\n") + eolMind);
+          }
+          else partial.push(eolMind);
+
+          // Join all of the member texts together, separated with newlines
+          if (partial.length === 0) {
+            res = wrap(token.obj, '');
+          } else {
+            // and wrap them in braces
+            res = prefix + wrap(token.obj, partial.join(''));
+            // try if the condensed version can fit
+            if (cpartial) {
+              cres = cpartial.join(' ');
+              if (cres.length - cwrapLen <= condense) res = wrap(token.obj, cres);
+            }
+          }
+        }
+
+        gap = mind;
+        return res;
+    }
+  }
+
+
+  runDsf = dsf.loadDsf(dsfDef, 'stringify');
+
+  var res = "";
+  var comments = keepComments ? comments = (common.getComment(data) || {}).r : null;
+  if (comments && comments[0]) res = comments[0] + '\n';
+
+  // get the result of stringifying the data.
+  res += str(data, null, true, true);
+
+  if (comments) res += comments[1]||"";
+
+  return res;
+};
+
+},{"./hjson-common":2,"./hjson-dsf":3}],6:[function(require,module,exports){
+module.exports="3.1.1";
+
+},{}],7:[function(require,module,exports){
+/*!
+ * Hjson v3.1.1
+ * http://hjson.org
+ *
+ * Copyright 2014-2017 Christian Zangl, MIT license
+ * Details and documentation:
+ * https://github.com/hjson/hjson-js
+ *
+ * This code is based on the the JSON version by Douglas Crockford:
+ * https://github.com/douglascrockford/JSON-js (json_parse.js, json2.js)
+ */
+
+/*
+
+  This file creates a Hjson object:
+
+
+    Hjson.parse(text, options)
+
+      options {
+        keepWsc     boolean, keep white space and comments. This is useful
+                    if you want to edit an hjson file and save it while
+                    preserving comments (default false)
+
+        dsf         array of DSF (see Hjson.dsf)
+
+        legacyRoot  boolean, support omitting root braces (default true)
+      }
+
+      This method parses Hjson text to produce an object or array.
+      It can throw a SyntaxError exception.
+
+
+    Hjson.stringify(value, options)
+
+      value         any JavaScript value, usually an object or array.
+
+      options {     all options are
+
+        keepWsc     boolean, keep white space. See parse.
+
+        condense    integer, will try to fit objects/arrays onto one line
+                    when the output is shorter than condense characters
+                    and the fragment contains no comments. Default 0 (off).
+
+        bracesSameLine
+                    boolean, makes braces appear on the same line as the key
+                    name. Default false.
+
+        quotes      string, controls how strings are displayed.
+                    setting separator implies "strings"
+                    "min"     - no quotes whenever possible (default)
+                    "keys"    - use quotes around keys
+                    "strings" - use quotes around string values
+                    "all"     - use quotes around keys and string values
+
+        multiline   string, controls how multiline strings are displayed.
+                    setting quotes implies "off"
+                    "std"     - strings containing \n are shown in
+                                multiline format (default)
+                    "no-tabs" - like std but disallow tabs
+                    "off"     - show in JSON format
+
+        separator   boolean, output a comma separator between elements. Default false.
+
+        space       specifies the indentation of nested structures. If it is
+                    a number, it will specify the number of spaces to indent
+                    at each level. If it is a string (such as '\t' or '  '),
+                    it contains the characters used to indent at each level.
+
+        eol         specifies the EOL sequence (default is set by
+                    Hjson.setEndOfLine())
+
+        colors      boolean, output ascii color codes
+
+        dsf         array of DSF (see Hjson.dsf)
+
+        emitRootBraces
+                    obsolete: will always emit braces
+      }
+
+      This method produces Hjson text from a JavaScript value.
+
+      Values that do not have JSON representations, such as undefined or
+      functions, will not be serialized. Such values in objects will be
+      dropped; in arrays they will be replaced with null.
+      stringify(undefined) returns undefined.
+
+
+    Hjson.endOfLine()
+    Hjson.setEndOfLine(eol)
+
+      Gets or sets the stringify EOL sequence ('\n' or '\r\n').
+      When running with node.js this defaults to os.EOL.
+
+
+    Hjson.rt { parse, stringify }
+
+      This is a shortcut to roundtrip your comments when reading and updating
+      a config file. It is the same as specifying the keepWsc option for the
+      parse and stringify functions.
+
+
+    Hjson.version
+
+      The version of this library.
+
+
+    Hjson.dsf
+
+      Domain specific formats are extensions to the Hjson syntax (see
+      hjson.org). These formats will be parsed and made available to
+      the application in place of strings (e.g. enable math to allow
+      NaN values).
+
+      Hjson.dsf ontains standard DSFs that can be passed to parse
+      and stringify.
+
+
+    Hjson.dsf.math()
+
+      Enables support for Inf/inf, -Inf/-inf, Nan/naN and -0.
+      Will output as Inf, -Inf, NaN and -0.
+
+
+    Hjson.dsf.hex(options)
+
+      Parse hexadecimal numbers prefixed with 0x.
+      set options.out = true to stringify _all_ integers as hex.
+
+
+    Hjson.dsf.date(options)
+
+      support ISO dates
+
+
+  This is a reference implementation. You are free to copy, modify, or
+  redistribute.
+
+*/
+
+"use strict";
+
+var common = require("./hjson-common");
+var version = require("./hjson-version");
+var parse = require("./hjson-parse");
+var stringify = require("./hjson-stringify");
+var comments = require("./hjson-comments");
+var dsf = require("./hjson-dsf");
+
+module.exports={
+
+  parse: parse,
+  stringify: stringify,
+
+  endOfLine: function() { return common.EOL; },
+  setEndOfLine: function(eol) {
+    if (eol === '\n' || eol === '\r\n') common.EOL = eol;
+  },
+
+  version: version,
+
+  // round trip shortcut
+  rt: {
+    parse: function(text, options) {
+      (options=options||{}).keepWsc=true;
+      return parse(text, options);
+    },
+    stringify: function(value, options) {
+      (options=options||{}).keepWsc=true;
+      return stringify(value, options);
+    },
+  },
+
+  comments: comments,
+
+  dsf: dsf.std,
+
+};
+
+},{"./hjson-comments":1,"./hjson-common":2,"./hjson-dsf":3,"./hjson-parse":4,"./hjson-stringify":5,"./hjson-version":6}],8:[function(require,module,exports){
+
+},{}]},{},[7])(7)
+});
\ No newline at end of file
diff --git a/lib/browser/extensions/i18n-main.js b/lib/browser/extensions/i18n-main.js
new file mode 100755
index 000000000..a2cd49eb3
--- /dev/null
+++ b/lib/browser/extensions/i18n-main.js
@@ -0,0 +1,44 @@
+const {app, ipcMain} = require('electron')
+const fs = require('fs')
+const path = require('path')
+const {ipcFuncMain} = require('./util-main')
+const franc = require('./franc-min')
+
+const transLang = {eng:'en', dan:'da', dut:'nl', fin:'fi', fre:'fr', ger:'de', heb:'he', ita:'it', jpn:'ja', kor:'ko', nor:'nb', pol:'pl', por:'pt', rus:'ru', spa:'es', swe:'sv', chi:'zh', cze:'cs', gre:'el', ice:'is', lav:'lv', lit:'lt', rum:'ro', hun:'hu', est:'et', bul:'bg', scr:'hr', scc:'sr', gle:'ga', glg:'gl', tur:'tr', ukr:'uk', hin:'hi', mac:'mk', ben:'bn', ind:'id', lat:'la', may:'ms', mal:'ml', wel:'cy', nep:'ne', tel:'te', alb:'sq', tam:'ta', bel:'be', jav:'jw', oci:'oc', urd:'ur', bih:'bh', guj:'gu', tha:'th', ara:'ar', cat:'ca', epo:'eo', baq:'eu', ina:'ia', kan:'kn', pan:'pa', gla:'gd', swa:'sw', slv:'sl', mar:'mr', mlt:'mt', vie:'vi', fry:'fy', slo:'sk', fao:'fo', sun:'su', uzb:'uz', amh:'am', aze:'az', geo:'ka', tir:'ti', per:'fa', bos:'bs', sin:'si', nno:'nn', xho:'xh', zul:'zu', grn:'gn', sot:'st', tuk:'tk', kir:'ky', bre:'br', twi:'tw', yid:'yi', som:'so', uig:'ug', kur:'ku', mon:'mn', arm:'hy', lao:'lo', snd:'sd', roh:'rm', afr:'af', ltz:'lb', bur:'my', khm:'km', tib:'bo', div:'dv', ori:'or', asm:'as', cos:'co', ine:'ie', kaz:'kk', lin:'ln', mol:'mo', pus:'ps', que:'qu', sna:'sn', tgk:'tg', tat:'tt', tog:'to', yor:'yo', mao:'mi', wol:'wo', abk:'ab', aar:'aa', aym:'ay', bak:'ba', bis:'bi', dzo:'dz', fij:'fj', kal:'kl', hau:'ha', ipk:'ik', iku:'iu', kas:'ks', kin:'rw', mlg:'mg', nau:'na', orm:'om', run:'rn', smo:'sm', sag:'sg', san:'sa', ssw:'ss', tso:'ts', tsn:'tn', vol:'vo', zha:'za', lug:'lg', glv:'gv'}
+
+
+module.exports = function(manifest){
+
+  const getMessagesPath = (extensionId, language) => {
+    const metadata = manifest[extensionId]
+    const localesDirectory = path.join(metadata.srcDirectory, '_locales')
+    const defaultLocale = metadata.default_locale || 'en'
+    try {
+
+      const filename = path.join(localesDirectory, language, 'messages.json')
+      fs.accessSync(filename, fs.constants.R_OK)
+      return [path.join(localesDirectory, defaultLocale, 'messages.json'), filename]
+    } catch (err) {
+      return [path.join(localesDirectory, defaultLocale, 'messages.json')]
+    }
+  }
+
+  const getMessages = (extensionId, language) => {
+    try {
+      const messagesPaths = getMessagesPath(extensionId, language)
+      console.log(666222,messagesPaths)
+      if(messagesPaths.length == 1){
+        return JSON.parse(fs.readFileSync(messagesPaths[0])) || {}
+      }
+      else{
+        return Object.assign(JSON.parse(fs.readFileSync(messagesPaths[0])) || {}, JSON.parse(fs.readFileSync(messagesPaths[1])) || {})
+      }
+    } catch (error) {
+      return {}
+    }
+  }
+
+  ipcFuncMain('i18n','detectLanguage',(e, inputText) => transLang[franc(inputText)] || 'en')
+  ipcFuncMain('i18n','getAcceptLanguages',(e) => [app.getLocale()])
+  ipcMain.on('CHROME_I18N_GET_MESSAGES', (e, extensionId, language) => e.returnValue = getMessages(extensionId, language))
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/idle-main.js b/lib/browser/extensions/idle-main.js
new file mode 100755
index 000000000..c97f92b3f
--- /dev/null
+++ b/lib/browser/extensions/idle-main.js
@@ -0,0 +1,12 @@
+const {powerMonitor, ipcMain} = require('electron')
+const { ipcFuncMainCb } = require('./util-main')
+
+module.exports = function(manifestMap){
+
+  ipcFuncMainCb('idle','querySystemIdleState',(e, sec, cb)=>{
+    powerMonitor.querySystemIdleState(sec, idleState => {
+      cb(idleState)
+    })
+  })
+
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/lruCache.js b/lib/browser/extensions/lruCache.js
new file mode 100644
index 000000000..3ed3d0b82
--- /dev/null
+++ b/lib/browser/extensions/lruCache.js
@@ -0,0 +1,88 @@
+const LRUCache = function(capacity){
+  this.capacity = capacity
+  this.length = 0
+  this.map = {}
+  // save the head and tail so we can update it easily
+  this.head = null
+  this.tail = null
+}
+
+LRUCache.prototype.node = function(key,value){
+  this.key = key
+  this.val = value
+  this.newer = null
+  this.older = null
+}
+
+LRUCache.prototype.get = function(key){
+  if(this.map.hasOwnProperty(key)){
+    this.updateKey(key)
+    return this.map[key].val
+  }else{
+    return
+  }
+}
+LRUCache.prototype.updateKey = function(key){
+  var node = this.map[key]
+  // break the chain and reconnect with newer and older
+  if(node.newer){
+    node.newer.older= node.older
+  }else{
+    this.head = node.older
+  }
+
+  if(node.older){
+    node.older.newer = node.newer
+  }else{
+    this.tail = node.newer
+  }
+
+  // replace the node into head - newest
+  node.older = this.head
+  node.newer = null
+  if(this.head){
+    this.head.newer = node
+  }
+  this.head = node
+
+  // if no items in the bucket, set the tail to node too.
+  if(!this.tail){
+    this.tail = node
+  }
+}
+
+LRUCache.prototype.set = function(key,value){
+  var node = new this.node(key,value)
+  // update the value for exist entries
+  if(this.map.hasOwnProperty(key)){
+    this.map[key].val = value
+    this.updateKey(key)
+    return
+  }
+  if(this.length >= this.capacity){
+    // remove the least recently used item
+    var dKey = this.tail.key
+    this.tail = this.tail.newer
+    if(this.tail){
+      this.tail.older = null
+    }
+    delete this.map[dKey]
+    this.length --
+  }
+
+  // insert node into the head
+  node.older = this.head
+  // if have head, we need re-connect node with other nodes older than head
+  if(this.head){
+    this.head.newer = node
+  }
+  this.head = node
+  // if no tail which means first insert, set the tail to node too
+  if(!this.tail){
+    this.tail = node
+  }
+  this.map[key] = node
+  this.length ++
+}
+
+module.exports = LRUCache
\ No newline at end of file
diff --git a/lib/browser/extensions/management-main.js b/lib/browser/extensions/management-main.js
new file mode 100755
index 000000000..b56bb50b8
--- /dev/null
+++ b/lib/browser/extensions/management-main.js
@@ -0,0 +1,25 @@
+const {ipcFuncMain} = require('./util-main')
+const {ipcMain} = require('electron')
+
+module.exports = function(manifestMap){
+  ipcFuncMain('management', 'getAll', _=> Object.values(manifestMap).filter(x=>x.id).map(x=>{
+      x.type = 'extension'
+      x = {...x, ...x.manifest}
+      return x
+    })
+  )
+
+  ipcFuncMain('management', 'get', (e, id) => {
+    let x = manifestMap[id]
+    x.type = 'extension'
+    x = {...x, ...x.manifest}
+    return x
+  })
+
+  ipcMain.on('CHROME-MANAGEMENT-GETSYNC',(e,id)=>{
+    let x = manifestMap[id]
+    x.type = 'extension'
+    x = {...x, ...x.manifest}
+    e.returnValue = x
+  })
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/mime/index.js b/lib/browser/extensions/mime/index.js
new file mode 100755
index 000000000..e5acc561e
--- /dev/null
+++ b/lib/browser/extensions/mime/index.js
@@ -0,0 +1,90 @@
+'use strict';
+
+/**
+ * @param typeMap [Object] Map of MIME type -> Array[extensions]
+ * @param ...
+ */
+function Mime() {
+  this._types = Object.create(null);
+  this._extensions = Object.create(null);
+
+  for (var i = 0; i < arguments.length; i++) {
+    this.define(arguments[i]);
+  }
+}
+
+/**
+ * Define mimetype -> xtension mappings.  Each key is a mime-type that maps
+ * to an array of extensions associated with the type.  The first extension is
+ * used as the default extension for the type.
+ *
+ * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
+ *
+ * If a type declares an extension that has already been defined, an error will
+ * be thrown.  To suppress this error and force the extension to be associated
+ * with the new type, pass `force`=true.  Alternatively, you may prefix the
+ * extension with "*" to map the type to extension, without mapping the
+ * extension to the type.
+ *
+ * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
+ *
+ *
+ * @param map (Object) type definitions
+ * @param force (Boolean) if true, force overriding of existing definitions
+ */
+Mime.prototype.define = function(typeMap, force) {
+  for (var type in typeMap) {
+    var extensions = typeMap[type];
+    for (var i = 0; i < extensions.length; i++) {
+      var ext = extensions[i];
+
+      // '*' prefix = not the preferred type for this extension.  So fixup the
+      // extension, and skip it.
+      if (ext[0] == '*') {
+        continue;
+      }
+
+      if (!force && (ext in this._types)) {
+        throw new Error(
+          'Attempt to change mapping for "' + ext +
+          '" extension from "' + this._types[ext] + '" to "' + type +
+          '". Pass `force=true` to allow this, otherwise remove "' + ext +
+          '" from the list of extensions for "' + type + '".'
+        );
+      }
+
+      this._types[ext] = type;
+    }
+
+    // Use first extension as default
+    if (force || !this._extensions[type]) {
+      var ext = extensions[0];
+      this._extensions[type] = (ext[0] != '*') ? ext : ext.substr(1)
+    }
+  }
+};
+
+/**
+ * Lookup a mime type based on extension
+ */
+Mime.prototype.getType = function(path) {
+  path = String(path);
+  var last = path.replace(/^.*[/\\]/, '').toLowerCase();
+  var ext = last.replace(/^.*\./, '').toLowerCase();
+
+  var hasPath = last.length < path.length;
+  var hasDot = ext.length < last.length - 1;
+
+  return (hasDot || !hasPath) && this._types[ext] || null;
+};
+
+/**
+ * Return file extension associated with a mime type
+ */
+Mime.prototype.getExtension = function(type) {
+  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
+  return type && this._extensions[type.toLowerCase()] || null;
+};
+
+module.exports = new Mime({"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":["woff"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["*woff"],"font/woff2":["woff2"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/webp":["webp"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]},
+  {"application/prs.cww":["cww"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","*wmz","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]});
diff --git a/lib/browser/extensions/sessions-main.js b/lib/browser/extensions/sessions-main.js
new file mode 100755
index 000000000..e554bc094
--- /dev/null
+++ b/lib/browser/extensions/sessions-main.js
@@ -0,0 +1 @@
+module.exports = function(sendToBackgroundPages) {}
\ No newline at end of file
diff --git a/lib/browser/extensions/storage-main.js b/lib/browser/extensions/storage-main.js
new file mode 100755
index 000000000..c37f3baa3
--- /dev/null
+++ b/lib/browser/extensions/storage-main.js
@@ -0,0 +1,138 @@
+const path = require('path')
+const fs = require('fs')
+const {app, ipcMain} = require('electron')
+const { ipcFuncMainCb } = require('./util-main')
+
+module.exports = function(manifestMap){
+  let makeDir = false
+
+  let gData
+  const getChromeStoragePath = (storageType, extensionId) => {
+    return path.join(
+      app.getPath('userData'), `/Chrome Storage/${extensionId}-${storageType}.json`)
+  }
+
+  const mkdirp = (dir, callback) => {
+    fs.mkdir(dir, (error) => {
+      if (error && error.code === 'ENOENT') {
+        mkdirp(path.dirname(dir), (error) => {
+          if (!error) {
+            mkdirp(dir, callback)
+          }
+        })
+      } else if (error && error.code === 'EEXIST') {
+        callback(null)
+      } else {
+        callback(error)
+      }
+    })
+  }
+
+  const readChromeStorageFile = (storageType, extensionId, keys, cb) => {
+    if(!gData) {
+      const filePath = getChromeStoragePath(storageType, extensionId)
+      try {
+        gData = JSON.parse(fs.readFileSync(filePath, 'utf8'))
+      } catch (e) {
+        gData = {}
+        return cb({err: null, data: null})
+      }
+    }
+    let ret
+    console.log(keys)
+    if(keys){
+      ret = {}
+      for(let key of keys){
+        ret[key] = gData[key]
+      }
+    }
+    else{
+      ret = gData
+    }
+    return cb({err: null, data: ret})
+  }
+
+  let timeOutId, writting
+  const delayWrite = (storageType, extensionId)=>{
+    if(writting){
+      setTimeout(()=>delayWrite(storageType, extensionId),100)
+      return
+    }
+    writting = true
+    const filePath = getChromeStoragePath(storageType, extensionId)
+    if(!makeDir){
+      mkdirp(path.dirname(filePath), err => {
+        if (!err){
+          makeDir = true
+          fs.writeFile(filePath, JSON.stringify(gData), err => {
+            writting = false
+          })
+        }
+      })
+      makeDir = true
+    }
+    else{
+      fs.writeFile(filePath, JSON.stringify(gData), err => {
+        writting = false
+      })
+    }
+  }
+
+  const writeChromeStorageFile = (storageType, extensionId, type, data, cb) => {
+    if(type == 'clear'){
+      try {
+        const filePath = getChromeStoragePath(storageType, extensionId)
+        fs.writeFileSync(filePath, '{}')
+        gData = {}
+        cb({})
+      } catch (err) {
+        cb({err})
+      }
+    }
+    else{
+      if(!gData) {
+        const filePath = getChromeStoragePath(storageType, extensionId)
+        try {
+          gData = fs.readFileSync(filePath, 'utf8')
+        } catch (e) {
+          gData = {}
+        }
+      }
+
+      if(type == 'remove'){
+        const changeInfos = {}
+        for(let key of data){
+          if(gData[key]) changeInfos[key] = {oldValue: gData[key]}
+          delete gData[key]
+        }
+        cb({data: changeInfos})
+      }
+      else if(type == 'set'){
+        if(!data) return cb({data: {}})
+        const changeInfos = {}
+        Object.keys(data).forEach(function (name) {
+          if(gData[name] != data[name]){
+            if(gData[name]){
+              changeInfos[name] = {oldValue: gData[name], newValue: data[name]}
+            }
+            else{
+              changeInfos[name] = {newValue: data[name]}
+            }
+          }
+          gData[name] = data[name]
+        })
+        cb({data: changeInfos})
+      }
+    }
+    clearTimeout(timeOutId)
+    timeOutId = setTimeout(()=>delayWrite(storageType, extensionId), 5000)
+  }
+
+  ipcFuncMainCb('storage','read',(e,storageType, extensionId, keys, cb)=>{
+    readChromeStorageFile(storageType, extensionId, keys, cb)
+  })
+
+  ipcFuncMainCb('storage','write',(e,storageType, extensionId, type, data, cb)=>{
+    writeChromeStorageFile(storageType, extensionId, type, data, cb)
+  })
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/tabs-main.js b/lib/browser/extensions/tabs-main.js
new file mode 100755
index 000000000..ad232c057
--- /dev/null
+++ b/lib/browser/extensions/tabs-main.js
@@ -0,0 +1,405 @@
+const {ipcFuncMain, ipcFuncMainCb, getIpcNameFunc, shortId, getFocusedWebContents, getCurrentWindow} = require('./util-main')
+const {ipcMain, BrowserWindow, webContents, session} = require('electron')
+const fs = require('fs')
+const path = require('path')
+const franc = require('./franc-min')
+
+const transLang = {eng:'en', dan:'da', dut:'nl', fin:'fi', fre:'fr', ger:'de', heb:'he', ita:'it', jpn:'ja', kor:'ko', nor:'nb', pol:'pl', por:'pt', rus:'ru', spa:'es', swe:'sv', chi:'zh', cze:'cs', gre:'el', ice:'is', lav:'lv', lit:'lt', rum:'ro', hun:'hu', est:'et', bul:'bg', scr:'hr', scc:'sr', gle:'ga', glg:'gl', tur:'tr', ukr:'uk', hin:'hi', mac:'mk', ben:'bn', ind:'id', lat:'la', may:'ms', mal:'ml', wel:'cy', nep:'ne', tel:'te', alb:'sq', tam:'ta', bel:'be', jav:'jw', oci:'oc', urd:'ur', bih:'bh', guj:'gu', tha:'th', ara:'ar', cat:'ca', epo:'eo', baq:'eu', ina:'ia', kan:'kn', pan:'pa', gla:'gd', swa:'sw', slv:'sl', mar:'mr', mlt:'mt', vie:'vi', fry:'fy', slo:'sk', fao:'fo', sun:'su', uzb:'uz', amh:'am', aze:'az', geo:'ka', tir:'ti', per:'fa', bos:'bs', sin:'si', nno:'nn', xho:'xh', zul:'zu', grn:'gn', sot:'st', tuk:'tk', kir:'ky', bre:'br', twi:'tw', yid:'yi', som:'so', uig:'ug', kur:'ku', mon:'mn', arm:'hy', lao:'lo', snd:'sd', roh:'rm', afr:'af', ltz:'lb', bur:'my', khm:'km', tib:'bo', div:'dv', ori:'or', asm:'as', cos:'co', ine:'ie', kaz:'kk', lin:'ln', mol:'mo', pus:'ps', que:'qu', sna:'sn', tgk:'tg', tat:'tt', tog:'to', yor:'yo', mao:'mi', wol:'wo', abk:'ab', aar:'aa', aym:'ay', bak:'ba', bis:'bi', dzo:'dz', fij:'fj', kal:'kl', hau:'ha', ipk:'ik', iku:'iu', kas:'ks', kin:'rw', mlg:'mg', nau:'na', orm:'om', run:'rn', smo:'sm', sag:'sg', san:'sa', ssw:'ss', tso:'ts', tsn:'tn', vol:'vo', zha:'za', lug:'lg', glv:'gv'}
+
+const getIpcName = getIpcNameFunc('Tabs')
+
+const tabOpenerMap = {}
+ipcMain.on('set-tab-opener',(e,tabId,openerTabId)=>{
+  if(openerTabId) tabOpenerMap[tabId] = openerTabId
+})
+
+ipcMain.on('get-tab-opener',(e,tabId)=>{
+  ipcMain.emit(`get-tab-opener-reply_${tabId}`,null,tabOpenerMap[tabId])
+})
+
+ipcMain.on('get-tab-opener-sync',(e,tabId)=>{
+  e.returnValue = tabOpenerMap[tabId]
+})
+
+async function getTabValue(event, tabId){
+  const contents = tabId ? webContents.fromId(tabId) : (await getFocusedWebContents())
+  if (!contents) {
+    event.returnValue = null
+    return
+  }
+
+  const hostWebContents = contents.hostWebContents2
+  let window = hostWebContents && BrowserWindow.fromWebContents(hostWebContents)
+  if(!window) window = getCurrentWindow()
+
+  // console.log(hostWebContents)
+  // if(!hostWebContents){
+  //   event.returnValue = null
+  //   return
+  // }
+  // else{
+  //   console.log(BrowserWindow.fromWebContents(hostWebContents))
+  // }
+  const _tabValue = {
+    audible: false,
+    autoDiscardable: true,
+    discarded: false,
+    id: tabId,
+    mutedInfo: {muted: contents.isAudioMuted()},
+    status: contents.isLoading() ? 'loading' : 'complete',
+    title: contents.getTitle(),
+    url: contents.getURL(),
+    windowId: window.id,
+  }
+
+  if(tabOpenerMap[tabId]) _tabValue.openerTabId = tabOpenerMap[tabId]
+
+  if(!hostWebContents || hostWebContents.isDestroyed()){
+    event.returnValue = _tabValue
+    return event.returnValue
+  }
+
+  const requestId = shortId()
+  hostWebContents.send('CHROME_TABS_TAB_VALUE', requestId, tabId)
+
+  setTimeout(()=>{ //@TODO FIX
+    event.returnValue = _tabValue
+  },300)
+
+  return await new Promise(r=>{
+    ipcMain.once(`CHROME_TABS_TAB_VALUE_RESULT_${requestId}`,(event2, tabValue)=>{
+      event.returnValue = {..._tabValue, ...tabValue}
+      r(event.returnValue)
+    })
+  })
+}
+
+async function tabsQuery(queryInfo, cb){
+  const tabIds = []
+  for(let content of webContents.getAllWebContents()){
+    if(!content.hostWebContents2) continue
+    tabIds.push(content.id)
+  }
+
+  // convert current window identifier to the actual current window id
+  if (queryInfo.windowId === -2 || queryInfo.currentWindow === true) {
+    delete queryInfo.currentWindow
+    const focusedWindow = getCurrentWindow()
+    if (focusedWindow) {
+      queryInfo.windowId = focusedWindow.id
+    }
+  }
+
+  const queryKeys = Object.keys(queryInfo)
+  // get the values for all tabs
+  const tabValues = {}
+  for(let tabId of tabIds){
+    tabValues[tabId] = (await getTabValue({}, tabId)) || {}
+  }
+
+  // console.log(tabValues, queryInfo)
+  const result = []
+  tabIds.forEach((tabId) => {
+    // delete tab from the list if any key doesn't match
+    if (!queryKeys.map((queryKey) => (tabValues[tabId][queryKey] === queryInfo[queryKey])).includes(false)) {
+      result.push(tabValues[tabId])
+    }
+  })
+
+  cb(result.sort(function(a, b){ return a.index - b.index }))
+}
+
+function createTab(error, createProperties, ses, opener, cb) {
+  if (!error && createProperties.partition) {
+    // createProperties.partition always takes precendence
+    ses = session.fromPartition(createProperties.partition, {
+      parent_partition: createProperties.parent_partition
+    })
+    // don't pass the partition info through
+    delete createProperties.partition
+    delete createProperties.parent_partition
+  }
+
+  if (error) {
+    console.error(error)
+    return cb(null, error)
+  }
+
+  createProperties.userGesture = true
+
+  try {
+    // windowId
+    // index
+    // pinned
+    opener.emit('new-window', null, createProperties.url, null, createProperties.active ? 'foreground-tab' : 'background-tab')
+    ipcMain.once('CHROME_TABS_ONCREATED', (event, tab) => { //@TODO FIX
+      cb(tab)
+    })
+  } catch (e) {
+    console.error(e)
+    cb(null, 'An unexpected error occurred: ' + e.message)
+  }
+}
+
+function recurTabGet(win, cb, error, ses, createProperties, retry) {
+  const cont = win.webContents
+  const key = shortId()
+  cont.send('get-focused-webContent', key, void 0)
+  ipcMain.once(`get-focused-webContent-reply_${key}`, (e, tabId) => {
+    if (!tabId) {
+      if(retry > 10) return cb(null, error)
+      return setTimeout(()=>recurTabGet(win, cb, error, ses, createProperties, retry + 1) ,30)
+    }
+    const opener = webContents.fromId(tabId)
+    ses = opener && opener.session
+    createTab(error, createProperties, ses, opener, cb)
+  })
+};
+
+function tabMain(manifestMap, resultID, nextId){
+  ipcFuncMainCb('tabs', 'create', async (e, createProperties, cb2)=> {
+    const cb = (tab, error) => {
+      // if (!evt.sender.isDestroyed()) {
+      if(cb2) cb2(tab, error)
+      // }
+    }
+    try {
+      let windowId = createProperties.windowId || -2
+      let win = null
+      let error = null
+
+      if (windowId === -2) {
+        win = getCurrentWindow() || BrowserWindow.getAllWindows()[0]
+        if (!win) {
+          error = 'No current window'
+        }
+      } else {
+        win = BrowserWindow.fromId(windowId)
+        if (!win) {
+          error = 'Window not found'
+        }
+      }
+
+      let ses = session.defaultSession
+      let opener
+      if (!error && createProperties.openerTabId) {
+        opener = webContents.fromId(createProperties.openerTabId)
+        if (!opener) {
+          error = 'No tab found'
+        } else {
+          ses = opener.session
+        }
+      }
+
+      if(!createProperties.url){
+        createProperties.url = 'chrome://newtab/'
+      }
+      if(!opener /*!createProperties.openerTabId || createProperties.openerTabId == -1*/){
+        if(!win){
+          const focus = getCurrentWindow()
+          if(focus && focus.getTitle().includes('Sushi Browser')){
+            win = focus
+          }
+          else{
+            win = BrowserWindow.getAllWindows().find(w=>w.getTitle().includes('Sushi Browser'))
+          }
+        }
+        recurTabGet(win, cb, error, ses, createProperties, 0)
+      }
+      else{
+        createTab(error, createProperties, ses, opener, cb)
+      }
+    } catch (e) {
+      cb(null, e.message)
+    }
+  })
+
+  ipcFuncMainCb('tabs', 'query', (e, ...args) => tabsQuery(...args))
+
+  ipcFuncMainCb('tabs', 'update', async (e, tabId, updateProperties, cb)=> {
+    const contents = webContents.fromId(tabId)
+    contents.hostWebContents2.send('chrome-tabs-event', {tabId, changeInfo: updateProperties}, 'updated')
+    cb()
+  })
+
+  ipcFuncMainCb('tabs', 'reload', async (e, tabId, reloadProperties, cb)=> {
+    const contents = tabId ? webContents.fromId(tabId) :(await getFocusedWebContents())
+    reloadProperties ? contents.reloadIgnoringCache() : contents.reload()
+    cb()
+  })
+
+  ipcFuncMainCb('tabs', 'remove', async (e, tabIds, cb)=> {
+    for(let tabId of tabIds){
+      const contents = webContents.fromId(tabId)
+      contents.hostWebContents2.send('chrome-tabs-event', {tabId}, 'removed')
+    }
+    cb()
+  })
+
+  ipcFuncMainCb('tabs', 'detectLanguage', (e, tabId,cb)=> {
+    webContents.fromId(tabId).executeJavaScript(
+      `document.documentElement.innerText`,
+      (result) => cb(transLang[franc(result)] || 'en')
+    )
+  })
+
+  ipcFuncMainCb('tabs', 'captureVisibleTab', (e, tabId,options,cb)=>{
+    options = options || {}
+    const contents = webContents.fromId(tabId)
+    if(contents){
+      contents.capturePage(image=>{
+        if(options.format == 'png'){
+          cb(`data:image/png;base64,${image.toPNG().toString('base64')}`)
+        }
+        else{
+          cb(`data:image/jpeg;base64,${image.toJPEG(options.quality || 92).toString("base64")}`)
+        }
+      })
+    }
+  })
+
+  ipcFuncMainCb('tabs', 'insertCSS', async (e, extensionId, tabId, details, cb)=>{
+    const contents = tabId ? webContents.fromId(tabId) : (await getFocusedWebContents())
+    let cssText
+    if(details.code){
+      cssText = details.code
+    }
+    else if(details.file){
+      try{
+        cssText = String(fs.readFileSync(path.join(manifestMap[extensionId], details.file)))
+      }catch(e){
+        cb()
+        return
+      }
+    }
+    else{
+      cb()
+      return
+    }
+    if(contents){
+      cb(`;(function(){
+      const s = document.createElement('style');
+      s.setAttribute('type', 'text/css');
+      s.appendChild(document.createTextNode(\`${cssText}\`));
+      document.head.appendChild(s)
+      })()`)
+    }
+  })
+
+  ipcFuncMainCb('tabs', 'getZoom', async (e, tabId,cb)=>{
+    const contents = tabId ? webContents.fromId(tabId) : (await getFocusedWebContents())
+    contents.getZoomFactor(factor=>cb(factor))
+  })
+
+  ipcFuncMainCb('tabs', 'setZoom', async (e, tabId,zoomFactor,cb)=>{
+    const contents = tabId ? webContents.fromId(tabId) : (await getFocusedWebContents())
+    contents.setZoomFactor(parseFloat(zoomFactor))
+    cb()
+  })
+
+  ipcFuncMainCb('tabs', 'saveAsPDF', async (e, pageSettings,cb)=>{
+    const contents = (await getFocusedWebContents())
+    const filepath = dialog.showDialog(BrowserWindow.fromWebContents(cont.hostWebContents2),
+      {
+        defaultPath: path.join(app.getPath('downloads'), `${cont.getTitle()}.pdf`),
+        type: 'select-saveas-file',
+        extensions: [['pdf']]
+      },filepaths=>{
+        if (!filepaths || filepaths.length > 1) {
+          cb('canceled')
+          return
+        }
+        contents.printToPDF({landscape: pageSettings.orientation === 1}, (error, data) => {
+          if (error) {
+            cb('not_saved')
+            return
+          }
+          fs.writeFile(filepaths[0], data, (error) => {
+            if (error) {
+              cb('not_saved')
+              return
+            }
+            cb('saved')
+          })
+        })
+      })
+  })
+
+  ipcFuncMainCb('tabs' , 'getFocusedWebContents', async (e, cb)=>{
+    const contents = (await getFocusedWebContents())
+    cb(contents.id)
+  })
+
+  ipcMain.on('CHROME_TABS_TAB_VALUE', getTabValue)
+
+  ipcMain.on('CHROME_TABS_SEND_MESSAGE', function (event, tabId, extensionId, isBackgroundPage, message, originResultID, webContentsKey) {
+    const contents = webContents.fromId(tabId)
+    if (!contents) {
+      console.error(`Sending message to unknown tab ${tabId}`)
+      return
+    }
+
+    const senderTabId = isBackgroundPage ? null : event.sender.id
+
+    contents.sendToAll(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, senderTabId, message, resultID.val, webContentsKey)
+    ipcMain.once(`CHROME_RUNTIME_ONMESSAGE_RESULT_${resultID.val}`, (event2, result) => {
+      event.sender.send(`CHROME_TABS_SEND_MESSAGE_RESULT_${originResultID}`, result)
+    })
+    resultID.val++
+  })
+
+  ipcMain.on('CHROME_TABS_EXECUTESCRIPT', async function (event, requestId, tabId, extensionId, details) {
+    const contents = tabId ? webContents.fromId(tabId) : (await getFocusedWebContents())
+    if (!contents) {
+      console.error(`Sending message to unknown tab ${tabId}`)
+      return
+    }
+
+    let code, url
+    if (details.file) {
+      const manifest = manifestMap[extensionId]
+      code = String(fs.readFileSync(path.join(manifest.srcDirectory, details.file)))
+      url = `chrome-extension://${extensionId}${details.file}`
+    }
+    else {
+      code = details.code
+      url = `chrome-extension://${extensionId}/${String(Math.random()).substr(2, 8)}.js`
+    }
+
+    contents.send('CHROME_TABS_EXECUTESCRIPT', event.sender.id, requestId, extensionId, url, code)
+  })
+
+
+  ipcMain.on('CHROME_TABS_CONNECT', function (event, tabId, extensionId, connectInfo, webContentsKey) {
+    const tab = webContents.fromId(tabId)
+    if (!tab) {
+      console.error(`Cannot connect to ${tabId} ${extensionId}`)
+      event.returnValue = null
+      return
+    }
+
+    const portId = ++nextId.val
+    tab.send(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, event.sender.id, portId, connectInfo)
+    ipcMain.once(`CHROME_RUNTIME_ONCONNECT_RES_${extensionId}`, (e, canConnect) => {
+      // console.log(778833,`CHROME_RUNTIME_ONCONNECT_RES_${extensionId}`, event.sender.id, portId, connectInfo, canConnect)
+      if(canConnect){
+        event.returnValue = portId
+
+        event.sender.once('render-view-deleted', () => {
+          if (page.webContents.isDestroyed()) return
+          tab.send(`CHROME_PORT_DISCONNECT_${portId}`)
+        })
+      }
+      else{
+        event.returnValue = null
+      }
+    })
+
+  })
+}
+
+module.exports = {
+  tabMain,
+  tabsQuery,
+  getTabValue
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/util-main.js b/lib/browser/extensions/util-main.js
new file mode 100755
index 000000000..191a46f36
--- /dev/null
+++ b/lib/browser/extensions/util-main.js
@@ -0,0 +1,60 @@
+const {ipcMain} = require('electron')
+const {getIpcNameFunc, _shortId} = require('../../renderer/extensions/common-util')
+const {getCurrentWindow, getFocusedWebContents} = require('./window-util-main')
+
+module.exports = {
+  getIpcNameFunc,
+  shortId: _shortId(),
+  getCurrentWindow,
+  getFocusedWebContents,
+  eventRegist(ipcEventName) {
+    const registEventList = [], unregistEventList = [], extensionIds = {}
+
+    ipcMain.on(`${ipcEventName}_REGIST`, function (event, extensionId, eventId, ...args) {
+      if(!extensionIds[extensionId]) extensionIds[extensionId] = {}
+      extensionIds[extensionId][eventId] = args
+
+      for (let event of registEventList) {
+        event(extensionId, eventId, ...args)
+      }
+    })
+
+    ipcMain.on(`${ipcEventName}_UNREGIST`, function (event, extensionId, eventId) {
+      for (let event of unregistEventList) {
+        event(extensionId, eventId)
+      }
+    })
+
+    const regist = (event) => {
+      registEventList.push(event)
+        // for(let [extensionId, values] of Object.entries(extensionIds)){
+        //   for(let [eventId, args] of Object.entries(values)){
+        //     event(extensionId, eventId, ...args)
+        //   }
+        // }
+    }
+
+    const unregist = (event) => {
+      unregistEventList.push(event)
+    }
+
+    return {regist, unregist}
+  },
+  ipcFuncMain(className, method, callback){
+    const name = getIpcNameFunc(className)(method)
+    ipcMain.on(name, (event, requestId, ...args)=>{
+      console.log(name, event, requestId, ...args)
+      event.sender.send(`${name}_RESULT_${requestId}`, callback && callback(event, ...args))
+    })
+  },
+  ipcFuncMainCb(className, method, callback){
+    const name = getIpcNameFunc(className)(method)
+    ipcMain.on(name, (event, requestId, ...args)=>{
+      if(callback){
+        callback(event, ...args, (...args2)=>{
+          event.sender.send(`${name}_RESULT_${requestId}`, ...args2)
+        })
+      }
+    })
+  }
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/web-navigation-main.js b/lib/browser/extensions/web-navigation-main.js
new file mode 100755
index 000000000..c5ce18825
--- /dev/null
+++ b/lib/browser/extensions/web-navigation-main.js
@@ -0,0 +1,49 @@
+const {ipcFuncMain, getIpcNameFunc, eventRegist} = require('./util-main')
+const {ipcMain} = require('electron')
+const getIpcName = getIpcNameFunc('WebNavigation')
+
+const eventObj = {}
+for(let method of ['onBeforeNavigate', 'onCompleted', 'onDOMContentLoaded', 'onCommitted', 'onErrorOccurred', 'onCreatedNavigationTarget']){
+  eventObj[method] = eventRegist(getIpcName(method))
+}
+
+module.exports = function(webContents, sendToBackgroundPage){
+  const addEvent = (eventName, webContentsEventName) => {
+    let registEvent = {}
+    eventObj[eventName].regist((extensionId, eventId)=>{
+      registEvent[eventId] = (event, url) => {
+        if(!event.isMainFrame) return
+        sendToBackgroundPage(extensionId, getIpcName(eventName, extensionId), eventId, {
+          frameId: 0,
+          parentFrameId: -1,
+          processId: webContents.getProcessId(),
+          tabId: webContents.id,
+          timeStamp: Date.now(),
+          error: event.errorDescription,
+          url: url || webContents.getURL()
+        })
+      }
+      webContents.on(webContentsEventName, registEvent[eventId])
+    })
+    eventObj[eventName].unregist((extensionIds, eventId)=>{
+      webContents.removeListener(webContentsEventName, registEvent[eventId])
+    })
+  }
+  addEvent('onBeforeNavigate', 'will-navigate')
+  addEvent('onCompleted', 'did-navigate')
+  addEvent('onDOMContentLoaded', 'dom-ready')
+  addEvent('onCommitted', 'load-commit')
+  addEvent('onErrorOccurred', 'did-fail-load')
+
+
+  let onCreatedNavigationTargetEvent = {}
+  eventObj.onCreatedNavigationTarget.regist((extensionId, eventId)=>{
+    onCreatedNavigationTargetEvent[eventId] = (event, data) => {
+      sendToBackgroundPage(extensionId, getIpcName('onCreatedNavigationTarget'), data)
+    }
+    ipcMain.on('chrome-webNavigation-onCreatedNavigationTarget', onCreatedNavigationTargetEvent[eventId])
+  })
+  eventObj.onCreatedNavigationTarget.unregist((extensionIds, eventId)=>{
+    ipcMain.removeListener('chrome-webNavigation-onCreatedNavigationTarget', onCreatedNavigationTargetEvent[eventId])
+  })
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/web-request-main.js b/lib/browser/extensions/web-request-main.js
new file mode 100755
index 000000000..3abc0bf02
--- /dev/null
+++ b/lib/browser/extensions/web-request-main.js
@@ -0,0 +1,151 @@
+const {ipcMain, webContents} = require('electron')
+const {getIpcNameFunc, eventRegist, shortId} = require('./util-main')
+const getIpcName = getIpcNameFunc('WebRequest')
+const lruCache = require('./lruCache')
+
+const methods = [
+  // 'onAuthRequired',
+  'onBeforeRedirect',
+  'onBeforeRequest',
+  'onBeforeSendHeaders',
+  'onCompleted',
+  'onErrorOccurred',
+  'onHeadersReceived',
+  'onResponseStarted',
+  'onSendHeaders'
+]
+
+const eventObj = {}
+for(let method of methods){
+  eventObj[method] = eventRegist(getIpcName(method))
+}
+const matchesPattern = function (pattern, url) {
+  if (pattern === '<all_urls>') return true
+  const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+?.\\/\s]/g, '\\$&').replace(/\*/g, '.*')}$`)
+  return url.match(regexp)
+}
+
+const tabIdCache = new lruCache(200)
+module.exports = function(session, sendToBackgroundPage){
+
+  for(let method of methods){
+    let properties = {}, adblocks = []
+    const webRequestEvent = (details, cb) => {
+
+      if(method == 'onBeforeRequest' && details.resourceType == 'mainFrame' && !details.webContentsId){
+        const cont = webContents.getAllWebContents().find(x=> x.isLoading() && x.getURL() == details.url)
+        if(cont) tabIdCache.set(details.url, [Date.now(), cont.id])
+      }
+      else if(method == 'onHeadersReceived' && !details.webContentsId){
+        const data = tabIdCache.get(details.url)
+        if(data && Date.now() - data[0] < 3000){
+          details.webContentsId = data[1]
+        }
+      }
+
+      let requestHeaders, responseHeaders
+      if(Object.keys(properties).length){
+        if(details.requestHeaders !== void 0){
+          requestHeaders = []
+          for(let [name,value] of Object.entries(details.requestHeaders)){
+            requestHeaders.push({name, value: value[0]})
+          }
+        }
+        if(details.responseHeaders !== void 0){
+          responseHeaders = []
+          for(let [name,value] of Object.entries(details.responseHeaders)){
+            responseHeaders.push({name, value: value[0]})
+          }
+        }
+      }
+
+      const promises = []
+      for (let [extensionId, eventId, filter] of Object.values(properties)) {
+        if (filter) {
+          if ((filter.urls && !filter.urls.some(pattern => matchesPattern(pattern, details.url))) ||
+            (filter.types && !filter.types.some(t => t == details.resourceType.replace('Frame', '_frame'))) ||
+            (filter.tabId !== void 0 && details.webContentsId && details.webContentsId != filter.tabId)
+          ) continue
+
+        }
+
+        if(cb){
+          promises.push(new Promise(r=>{
+            ipcMain.once(`${getIpcName(method, extensionId)}_${eventId}_${details.id}_RESULT`, (e, result) =>{
+              r(result)
+            })
+          }))
+        }
+
+        sendToBackgroundPage(extensionId, getIpcName(method, extensionId), eventId, details.id, {
+          tabId: details.webContentsId || -1,
+          frameId: 0,
+          parentFrameId: -1,
+          type: details.resourceType.replace('Frame', '_frame'),
+          ...details,
+          requestHeaders,
+          responseHeaders
+        })
+
+        // console.log([method, extensionId, eventId].join("\t"))
+        const ret = {}
+      }
+      for(let func of adblocks){
+        promises.push(new Promise(r =>{
+          func(details, r)
+        }))
+      }
+      if(cb){
+        // console.log(22222234,promises.length)
+        Promise.all(promises).then(results => {
+          // console.log(22222235,results)
+          const finalResult = {}
+          for(let result of results){
+            result = result || {}
+            if(result.cancel !== void 0) finalResult.cancel = finalResult.cancel || result.cancel
+            if(result.statusLine !== void 0) finalResult.statusLine = result.statusLine
+            if(result.requestHeaders !== void 0){
+              if(typeof result.requestHeaders == "object"){
+                finalResult.requestHeaders = Object.assign(finalResult.requestHeaders || {}, result.requestHeaders)
+              }
+              else{
+                for(let o of result.requestHeaders) finalResult.requestHeaders[o.name] = [o.value]
+              }
+            }
+            if(result.responseHeaders !== void 0){
+              if(typeof result.responseHeaders == "object"){
+                finalResult.responseHeaders = Object.assign(finalResult.responseHeaders || {}, result.responseHeaders)
+              }
+              else{
+                for(let o of result.responseHeaders) finalResult.responseHeaders[o.name] = [o.value]
+              }
+            }
+         }
+         cb(finalResult)
+        })
+      }
+    }
+
+    eventObj[method].regist((extensionId, eventId, filter)=>{
+      if(method != 'onBeforeRequest' && method != 'onHeadersReceived' && !Object.keys(properties).length){
+        console.log(method,session)
+        session.webRequest[method](webRequestEvent)
+      }
+      properties[`${extensionId}${eventId}`] = [extensionId, eventId, filter]
+    })
+    eventObj[method].unregist((extensionId, eventId)=>{
+      delete properties[`${extensionId}${eventId}`]
+      if(method != 'onBeforeRequest' && method != 'onHeadersReceived' && !Object.keys(properties).length){
+        session.webRequest[method](null)
+      }
+    })
+
+    if(method == 'onBeforeRequest' || method == 'onHeadersReceived' || method == 'onBeforeSendHeaders'){
+      session.webRequest[method](webRequestEvent)
+      ipcMain.on(`add-${method}`, (func) =>{
+        adblocks.push(func)
+      })
+    }
+  }
+
+}
diff --git a/lib/browser/extensions/window-util-main.js b/lib/browser/extensions/window-util-main.js
new file mode 100755
index 000000000..aaab07af2
--- /dev/null
+++ b/lib/browser/extensions/window-util-main.js
@@ -0,0 +1,72 @@
+const { BrowserWindow, ipcMain, webContents } = require('electron')
+const {getIpcNameFunc, _shortId} = require('../../renderer/extensions/common-util')
+const shortId = _shortId()
+
+function getCurrentWindow(){
+  const focus = BrowserWindow.getFocusedWindow()
+  if(focus && focus.getTitle().includes('Sushi Browser')) return focus
+  return BrowserWindow.getAllWindows().find(w=>w.getTitle().includes('Sushi Browser'))
+}
+
+function getFocusedWebContents(needSelectedText,skipBuildInSearch,callback,retry=0){
+  let cont
+  if(!skipBuildInSearch){
+    const tmp = webContents.getFocusedWebContents()
+    if(tmp && !tmp.isDestroyed() /*&& !tmp.isBackgroundPage()*/ && !(/*tmp.tabValue().openerTabId == -1 && */ tmp.getURL().match(/^(chrome\-extension|chrome\-devtools)/))) { //@TODO ELECTRON
+      if(tmp.hostWebContents2){
+        return new Promise(resolve=>resolve(tmp))
+      }
+      else if(tmp.isRoot){
+        cont = tmp
+      }
+    }
+  }
+
+  if(!cont){
+    let win = getCurrentWindow()
+    if(!win){
+      if(callback){
+        return setTimeout(_=>getFocusedWebContents(needSelectedText,skipBuildInSearch,callback,++retry),300)
+      }
+      else{
+        return new Promise((resolve,reject)=>{
+          setTimeout(_=>getFocusedWebContents(needSelectedText,skipBuildInSearch,resolve,++retry),300)
+        })
+      }
+    }
+    cont = win.webContents
+  }
+  const key = shortId()
+
+  if(callback){
+    ipcMain.once(`get-focused-webContent-reply_${key}`,(e,tabId)=>{
+      if(tabId < 1){
+        setTimeout(_=>getFocusedWebContents(needSelectedText,skipBuildInSearch,callback,++retry),300)
+      }
+      else{
+        callback(webContents.fromId(tabId))
+      }
+    })
+    cont.send('get-focused-webContent',key,void 0,needSelectedText,void 0,retry)
+  }
+  else{
+    return new Promise((resolve,reject)=>{
+      ipcMain.once(`get-focused-webContent-reply_${key}`,(e,tabId)=>{
+        if(tabId < 1){
+          console.log('tabId',tabId,retry)
+          setTimeout(_=>getFocusedWebContents(needSelectedText,skipBuildInSearch,resolve,++retry),300)
+        }
+        else{
+          const cont = webContents.fromId(tabId)
+          resolve(cont)
+        }
+      })
+      cont.send('get-focused-webContent',key,void 0,needSelectedText,void 0,retry)
+    })
+  }
+}
+
+module.exports = {
+  getFocusedWebContents,
+  getCurrentWindow
+}
\ No newline at end of file
diff --git a/lib/browser/extensions/windows-main.js b/lib/browser/extensions/windows-main.js
new file mode 100755
index 000000000..d9c30262c
--- /dev/null
+++ b/lib/browser/extensions/windows-main.js
@@ -0,0 +1,172 @@
+const {ipcFuncMain, ipcFuncMainCb,getIpcNameFunc, getCurrentWindow} = require('./util-main')
+const {app, ipcMain, BrowserWindow} = require('electron')
+
+const getIpcName = getIpcNameFunc('Windows')
+
+
+async function windowInfo(win, populateTabs, tabsQuery) {
+  const  bounds = win.getBounds()
+  return {
+    incognito: false, //@TODO FIX
+    id: win.id,
+    focused: win.isFocused(),
+    state: win.isDestroyed() ? 'normal' : win.isMinimized() ? 'minimized' : win.isMaximized() ? 'maximized' : win.isFullScreen() ? 'fullscreen' : 'normal',
+    type: 'normal',
+    top: bounds.y,
+    left: bounds.x,
+    width: bounds.width,
+    height: bounds.height,
+    alwaysOnTop: win.isAlwaysOnTop(),
+    tabs: populateTabs ? (await new Promise(r=>tabsQuery({windowId: win.id}, r))) : null
+  }
+}
+
+module.exports = function(manifestMap, sendToBackgroundPages, tabsQuery){
+
+  app.on('browser-window-created', async (event, window)=>{
+    window.once('close', (event)=>{
+      sendToBackgroundPages('CHROME_WINDOWS_ONREMOVED', window.id)
+    })
+    sendToBackgroundPages('CHROME_WINDOWS_ONCREATED', await windowInfo(window, false, tabsQuery))
+  })
+
+  app.on('browser-window-blur', (event, window)=>{
+    sendToBackgroundPages('CHROME_WINDOWS_ONFOCUSCHANGED', window.id)
+  })
+
+  app.on('browser-window-focus', (event, window)=>{
+    sendToBackgroundPages('CHROME_WINDOWS_ONFOCUSCHANGED', window.id)
+  })
+
+  ipcFuncMainCb('windows','get', async (e, windowId, getInfo, cb) => {
+    // if (getInfo && getInfo.windowTypes) {
+    //   console.warn('getWindow with windowTypes not supported yet')
+    // }
+
+    const win = BrowserWindow.fromId(windowId)
+    if (getInfo && getInfo.populate) {
+      cb(await windowInfo(win, getInfo.populate, tabsQuery))
+    }
+    else {
+      cb(await windowInfo(win, false, tabsQuery))
+    }
+  })
+
+  ipcFuncMainCb('windows','getCurrent', async (e, getInfo, cb) => {
+    // if (getInfo && getInfo.windowTypes) {
+    //   console.warn('getWindow with windowTypes not supported yet')
+    // }
+
+    const win = getCurrentWindow()
+    if (getInfo && getInfo.populate) {
+      cb(await windowInfo(win, getInfo.populate, tabsQuery))
+    }
+    else {
+      cb(await windowInfo(win, false, tabsQuery))
+    }
+  })
+
+  ipcFuncMainCb('windows','getAll', async (e, getInfo, cb) => {
+    // if (getInfo && getInfo.windowTypes) {
+    //   console.warn('getWindow with windowTypes not supported yet')
+    // }
+
+    const wins = []
+    for(let win of BrowserWindow.getAllWindows()){
+      if (getInfo && getInfo.populate) {
+        wins.push(await windowInfo(win, getInfo.populate, tabsQuery))
+      }
+      else {
+        wins.push(await windowInfo(win, false, tabsQuery))
+      }
+    }
+    cb(wins)
+  })
+
+  ipcFuncMainCb('windows', 'create', (e, createData, cb) => {
+    if(createData.tabId){
+      const wins = BrowserWindow.getAllWindows()
+      if(!wins) return
+
+      for(let win of wins.filter(w=>w.getTitle().includes('Sushi Browser'))){
+        try {
+          if(!win.webContents.isDestroyed()){
+            win.webContents.send('chrome-windows-create-from-tabId',createData);
+          }
+        }catch(e){
+          // console.log(e)
+        }
+      }
+    }
+    else{
+      ipcMain.emit('browser-load', {}, {id:getCurrentWindow().id,x:createData.left,y:createData.top,
+        height:createData.height,width:createData.width,
+        tabParam:JSON.stringify({urls:[{url:createData.url,privateMode:false}],type:'new-win'})})
+      setTimeout(async ()=>{
+        let max = [-999]
+        for(let win of BrowserWindow.getAllWindows()){
+          if(win.id > max[0]) max = [win.id, win]
+        }
+        let win
+        for(let i=0;i<30;i++){
+          win = await windowInfo(max[1], true, tabsQuery)
+          if(win.tabs.length) break
+          await new Promise(r=>setTimeout(async ()=>{
+            win = await windowInfo(max[1], true, tabsQuery)
+            r()
+          },100))
+        }
+        cb(win)
+      },100)
+    }
+  })
+
+  ipcFuncMain('windows','remove',(e, windowId)=> {
+    const win = windowId ? BrowserWindow.fromId(windowId) : getCurrentWindow()
+    win && win.close()
+  })
+
+  ipcFuncMain('windows','getLastFocused',(e, windowId)=> {
+    const win = getCurrentWindow()
+    return win && win.id
+  })
+
+
+  ipcFuncMainCb('windows', 'update', async (e, windowId, updateInfo, cb)=> {
+    let win = BrowserWindow.fromId(windowId)
+
+    if (win) {
+      if (updateInfo.focused) {
+        win.focus()
+      }
+
+      if (updateInfo.left || updateInfo.top ||
+        updateInfo.width || updateInfo.height) {
+        let bounds = win.getBounds()
+        bounds.x = updateInfo.left || bounds.x
+        bounds.y = updateInfo.top || bounds.y
+        bounds.width = updateInfo.width || bounds.width
+        bounds.height = updateInfo.height || bounds.height
+        win.setBounds(bounds)
+      }
+
+      switch (updateInfo.state) {
+        case 'minimized':
+          win.minimize()
+          break
+        case 'maximized':
+          win.maximize()
+          break
+        case 'fullscreen':
+          win.setFullScreen(true)
+          break
+      }
+
+      cb(await windowInfo(win, false, tabsQuery))
+    } else {
+      console.warn('chrome.windows.update could not find windowId ' + windowId)
+      return {}
+    }
+  })
+
+}
\ No newline at end of file
diff --git a/lib/renderer/api/ipc-renderer.js b/lib/renderer/api/ipc-renderer.js
old mode 100644
new mode 100755
index 7705f9f9a..97c1de707
--- a/lib/renderer/api/ipc-renderer.js
+++ b/lib/renderer/api/ipc-renderer.js
@@ -12,7 +12,10 @@ ipcRenderer.send = function (...args) {
 }
 
 ipcRenderer.sendSync = function (...args) {
-  return binding.sendSync('ipc-message-sync', args)[0]
+  console.log(31111,...args)
+  const val = binding.sendSync('ipc-message-sync', args)[0]
+  console.log(31112,...args, val)
+  return val
 }
 
 ipcRenderer.sendToHost = function (...args) {
diff --git a/lib/renderer/chrome-api.js b/lib/renderer/chrome-api.js
old mode 100644
new mode 100755
index f34454c01..c31e98008
--- a/lib/renderer/chrome-api.js
+++ b/lib/renderer/chrome-api.js
@@ -1,194 +1,70 @@
-'use strict'
-
-const ipcRenderer = require('@electron/internal/renderer/ipc-renderer-internal')
-const Event = require('@electron/internal/renderer/extensions/event')
-const url = require('url')
-
-let nextId = 0
-
-class Tab {
-  constructor (tabId) {
-    this.id = tabId
-  }
-}
-
-class MessageSender {
-  constructor (tabId, extensionId) {
-    this.tab = tabId ? new Tab(tabId) : null
-    this.id = extensionId
-    this.url = `chrome-extension://${extensionId}`
-  }
-}
-
-class Port {
-  constructor (tabId, portId, extensionId, name) {
-    this.tabId = tabId
-    this.portId = portId
-    this.disconnected = false
-
-    this.name = name
-    this.onDisconnect = new Event()
-    this.onMessage = new Event()
-    this.sender = new MessageSender(tabId, extensionId)
-
-    ipcRenderer.once(`CHROME_PORT_DISCONNECT_${portId}`, () => {
-      this._onDisconnect()
-    })
-    ipcRenderer.on(`CHROME_PORT_POSTMESSAGE_${portId}`, (event, message) => {
-      const sendResponse = function () { console.error('sendResponse is not implemented') }
-      this.onMessage.emit(message, this.sender, sendResponse)
-    })
-  }
-
-  disconnect () {
-    if (this.disconnected) return
-
-    ipcRenderer.sendToAll(this.tabId, `CHROME_PORT_DISCONNECT_${this.portId}`)
-    this._onDisconnect()
-  }
-
-  postMessage (message) {
-    ipcRenderer.sendToAll(this.tabId, `CHROME_PORT_POSTMESSAGE_${this.portId}`, message)
-  }
-
-  _onDisconnect () {
-    this.disconnected = true
-    ipcRenderer.removeAllListeners(`CHROME_PORT_POSTMESSAGE_${this.portId}`)
-    this.onDisconnect.emit()
-  }
-}
+const {ipcRenderer} = require('electron')
+const {Event} = require('./extensions/event')
+const Tab = require('./extensions/tab')
+const Port = require('./extensions/port')
+const MessageSender = require('./extensions/message-sender')
+const {shortId} = require('./extensions/util')
 
 // Inject chrome API to the |context|
-exports.injectTo = function (extensionId, isBackgroundPage, context) {
+exports.injectTo = function (extensionId, isBackgroundPage, isExtensionPage, context) {
   const chrome = context.chrome = context.chrome || {}
-  let originResultID = 1
+  const manifest = ipcRenderer.sendSync('CHROME_I18N_MANIFEST', extensionId)
 
-  ipcRenderer.on(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, (event, tabId, portId, connectInfo) => {
+  const webContentsKey = shortId()
+
+  // console.log(`CHROME_RUNTIME_ONCONNECT0_${extensionId}`, isBackgroundPage, context)
+  ipcRenderer.on(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, (event, tabId, portId, connectInfo, _webContentsKey) => {
+    event.sender.send(`CHROME_RUNTIME_ONCONNECT_RES_${extensionId}`, webContentsKey !== _webContentsKey)
+    if(webContentsKey == _webContentsKey) return
+    console.log(`CHROME_RUNTIME_ONCONNECT_${extensionId}`, (event, tabId, portId, connectInfo))
     chrome.runtime.onConnect.emit(new Port(tabId, portId, extensionId, connectInfo.name))
   })
 
-  ipcRenderer.on(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, (event, tabId, message, resultID) => {
+  ipcRenderer.on(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, (event, tabId, message, resultID, _webContentsKey) => {
+    if(webContentsKey == _webContentsKey) return
+    // console.log(`CHROME_RUNTIME_ONMESSAGE_${extensionId}`, (event, tabId, message, resultID))
     chrome.runtime.onMessage.emit(message, new MessageSender(tabId, extensionId), (messageResult) => {
       ipcRenderer.send(`CHROME_RUNTIME_ONMESSAGE_RESULT_${resultID}`, messageResult)
     })
   })
 
-  ipcRenderer.on('CHROME_TABS_ONCREATED', (event, tabId) => {
-    chrome.tabs.onCreated.emit(new Tab(tabId))
-  })
-
-  ipcRenderer.on('CHROME_TABS_ONREMOVED', (event, tabId) => {
-    chrome.tabs.onRemoved.emit(tabId)
-  })
-
-  chrome.runtime = {
-    id: extensionId,
-
-    getURL: function (path) {
-      return url.format({
-        protocol: 'chrome-extension',
-        slashes: true,
-        hostname: extensionId,
-        pathname: path
-      })
-    },
-
-    connect (...args) {
-      if (isBackgroundPage) {
-        console.error('chrome.runtime.connect is not supported in background page')
-        return
-      }
-
-      // Parse the optional args.
-      let targetExtensionId = extensionId
-      let connectInfo = { name: '' }
-      if (args.length === 1) {
-        connectInfo = args[0]
-      } else if (args.length === 2) {
-        [targetExtensionId, connectInfo] = args
-      }
-
-      const { tabId, portId } = ipcRenderer.sendSync('CHROME_RUNTIME_CONNECT', targetExtensionId, connectInfo)
-      return new Port(tabId, portId, extensionId, connectInfo.name)
-    },
-
-    sendMessage (...args) {
-      if (isBackgroundPage) {
-        console.error('chrome.runtime.sendMessage is not supported in background page')
-        return
-      }
-
-      // Parse the optional args.
-      let targetExtensionId = extensionId
-      let message
-      if (args.length === 1) {
-        message = args[0]
-      } else if (args.length === 2) {
-        // A case of not provide extension-id: (message, responseCallback)
-        if (typeof args[1] === 'function') {
-          ipcRenderer.on(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`, (event, result) => args[1](result))
-          message = args[0]
-        } else {
-          [targetExtensionId, message] = args
-        }
-      } else {
-        console.error('options is not supported')
-        ipcRenderer.on(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`, (event, result) => args[2](result))
-      }
-
-      ipcRenderer.send('CHROME_RUNTIME_SENDMESSAGE', targetExtensionId, message, originResultID)
-      originResultID++
-    },
-
-    onConnect: new Event(),
-    onMessage: new Event(),
-    onInstalled: new Event()
-  }
-
-  chrome.tabs = {
-    executeScript (tabId, details, callback) {
-      const requestId = ++nextId
-      ipcRenderer.once(`CHROME_TABS_EXECUTESCRIPT_RESULT_${requestId}`, (event, result) => {
-        // Disabled due to false positive in StandardJS
-        // eslint-disable-next-line standard/no-callback-literal
-        callback([event.result])
-      })
-      ipcRenderer.send('CHROME_TABS_EXECUTESCRIPT', requestId, tabId, extensionId, details)
-    },
-
-    sendMessage (tabId, message, options, responseCallback) {
-      if (responseCallback) {
-        ipcRenderer.on(`CHROME_TABS_SEND_MESSAGE_RESULT_${originResultID}`, (event, result) => responseCallback(result))
-      }
-      ipcRenderer.send('CHROME_TABS_SEND_MESSAGE', tabId, extensionId, isBackgroundPage, message, originResultID)
-      originResultID++
-    },
-
-    onUpdated: new Event(),
-    onCreated: new Event(),
-    onRemoved: new Event()
-  }
-
-  chrome.extension = {
-    getURL: chrome.runtime.getURL,
-    connect: chrome.runtime.connect,
-    onConnect: chrome.runtime.onConnect,
-    sendMessage: chrome.runtime.sendMessage,
-    onMessage: chrome.runtime.onMessage
-  }
-
-  chrome.storage = require('@electron/internal/renderer/extensions/storage').setup(extensionId)
-
-  chrome.pageAction = {
-    show () {},
-    hide () {},
-    setTitle () {},
-    getTitle () {},
-    setIcon () {},
-    setPopup () {},
-    getPopup () {}
+  if(manifest.admin) chrome.ipcRenderer = ipcRenderer
+
+  chrome.csi = _=>({})
+  chrome.app = require('./extensions/app').setup(manifest)
+  chrome.runtime = require('./extensions/runtime').setup(extensionId, manifest, isBackgroundPage, isExtensionPage, chrome, webContentsKey);
+  chrome.extension = require('./extensions/extension').setup(chrome)
+  chrome.storage = require('./extensions/storage').setup(extensionId)
+  chrome.i18n = require('./extensions/i18n').setup(extensionId)
+  chrome.contentSettings = require('./extensions/content-settings').setup(extensionId)
+
+  if(isExtensionPage){
+    chrome.tabs = require('./extensions/tabs').setup(extensionId, manifest, isBackgroundPage, chrome, webContentsKey)
+    chrome.windows = require('./extensions/windows').setup(extensionId)
+    chrome.permissions = require('./extensions/permissions').setup()
+    chrome.management = require('./extensions/management').setup(extensionId)
+    chrome.browserAction = require('./extensions/browser-action').setup(extensionId)
+    chrome.commands = require('./extensions/commands').setup(extensionId, manifest)
+    chrome.pageAction = chrome.browserAction
+
+    const permissions = {}
+    for(let permission of manifest.permissions) permissions[permission] = true
+
+    if(permissions.cookies) chrome.cookies = require('./extensions/cookies').setup(extensionId, chrome)
+    if(permissions.sessions) chrome.sessions = require('./extensions/sessions').setup(extensionId, chrome)
+    if(permissions.contextMenus) chrome.contextMenus = require('./extensions/context-menus').setup(extensionId)
+    if(permissions.webNavigation) chrome.webNavigation = require('./extensions/web-navigation').setup(extensionId)
+    if(permissions.webRequest) chrome.webRequest = require('./extensions/web-request').setup(extensionId)
+    if(permissions.idle) chrome.idle = require('./extensions/idle').setup()
+    if(permissions.notifications) chrome.notifications = require('./extensions/notifications').setup()
+    if(permissions.browsingData) chrome.browsingData = require('./extensions/browsing-data').setup()
+    if(permissions.topSites) chrome.topSites = require('./extensions/top-sites').setup()
+    if(permissions.bookmarks) chrome.bookmarks = require('./extensions/bookmarks').setup(chrome)
+    if(permissions.downloads) chrome.downloads = require('./extensions/downloads').setup()
+    if(permissions.history) chrome.history = require('./extensions/history').setup()
+    if(permissions.proxy) chrome.proxy = require('./extensions/proxy').setup()
+    if(permissions.privacy) chrome.privacy = require('./extensions/privacy').setup()
+    if(permissions.alarms) chrome.alarms = require('./extensions/alarms').setup(extensionId)
   }
 
-  chrome.i18n = require('@electron/internal/renderer/extensions/i18n').setup(extensionId)
-  chrome.webNavigation = require('@electron/internal/renderer/extensions/web-navigation').setup()
 }
diff --git a/lib/renderer/content-scripts-injector-build.js b/lib/renderer/content-scripts-injector-build.js
new file mode 100755
index 000000000..8e6d232b3
--- /dev/null
+++ b/lib/renderer/content-scripts-injector-build.js
@@ -0,0 +1,170 @@
+'use strict'
+
+const {ipcRenderer,webFrame} = require('electron')
+ipcRenderer.setMaxListeners(0)
+
+function exe(isExtensionPage){
+  window.close = () => ipcRenderer.send('send-to-host', 'window-close', {})
+
+// Check whether pattern matches.
+// https://developer.chrome.com/extensions/match_patterns
+  const matchesPattern = function (pattern) {
+    if (pattern === '<all_urls>') return true
+    const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+?.\\/\s]/g, '\\$&').replace(/\*/g, '.*')}$`)
+    // console.log('matchesPattern',pattern,regexp)
+    const url = `${location.protocol}//${location.host}${location.pathname}`
+    return url.match(regexp)
+  }
+
+  const matchesGlob = function (pattern) {
+    if (pattern === '<all_urls>') return true
+    const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+.\\/\s]/g, '\\$&').replace(/\*/g, '.*').replace(/\?/g, '.?')}$`)
+    // console.log('matchesGlob',pattern,regexp)
+    const url = `${location.protocol}//${location.host}${location.pathname}`
+    return url.match(regexp)
+  }
+
+// Run the code with chrome API integrated.
+  let seq = 0, seqMap = {}
+  const runContentScript = async function (extensionId, name, url, code) {
+    console.log('runContentScript')
+    const context = {}
+    require('./chrome-api').injectTo(extensionId, false, isExtensionPage, context)
+    let worldId = seqMap[extensionId]
+    if(!worldId){
+      worldId = ++seq
+      seqMap[extensionId] = worldId
+      webFrame.setIsolatedWorldHumanReadableName(worldId, name)
+      await new Promise(r=>{
+        webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: `;\n((chrome) => { window.chrome = chrome });\n`}], false, compiledWrapper => {
+          compiledWrapper.call(this, context.chrome)
+          r()
+        })
+      })
+    }
+
+    return function(){
+      return new Promise(r=>{
+        webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: `;\n${code};\n`}], false, r)
+      })
+    }
+
+    // const compiledWrapper = runInThisContext(wrapper, {
+    //   filename: url,
+    //   lineOffset: 1,
+    //   displayErrors: true
+    // })
+    // return compiledWrapper.call(this, context.chrome)
+  }
+
+  const runAllContentScript = function (scripts, extensionId, name) {
+    let _url, _code = []
+    for (const { url, code } of scripts) {
+      _url = url
+      _code.push(code)
+    }
+    return runContentScript.call(window, extensionId, name, _url, _code.join("\n;\n"))
+  }
+
+  const runStylesheet = function (extensionId, name, url, code) {
+    const wrapper = `((code) => {
+    function init() {
+      const styleElement = document.createElement('style');
+      styleElement.textContent = code;
+      document.head.append(styleElement);
+    }
+    document.addEventListener('DOMContentLoaded', init);
+  })`
+
+    let worldId = seqMap[extensionId]
+    if(!worldId){
+      worldId = ++seq
+      seqMap[extensionId] = worldId
+      webFrame.setIsolatedWorldHumanReadableName(worldId, name)
+    }
+
+    return function(){
+      webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: wrapper}], false, compiledWrapper => {
+        compiledWrapper.call(this, code)
+      })
+    }
+  }
+
+  const runAllStylesheet = function (css, extensionId, name) {
+    for (const { url, code } of css) {
+      return runStylesheet.call(window, extensionId, name, url, code)
+    }
+  }
+
+// Run injected scripts.
+// https://developer.chrome.com/extensions/content_scripts
+  const injectContentScript = async function (extensionId, name, script) {
+    console.log('injectContentScript')
+    if (!script.matches.some(matchesPattern)) return
+    if (script.include_globs && !script.include_globs.some(matchesGlob)) return
+    if (script.exclude_matches && script.exclude_matches.some(matchesPattern)) return
+    if (script.exclude_globs && script.exclude_globs.some(matchesGlob)) return
+
+    if (script.js) {
+      const fire = (await runAllContentScript.bind(window, script.js, extensionId, name)())
+      if (script.runAt === 'document_start') {
+        const id = setInterval(()=>{
+          if(document.documentElement){
+            clearInterval(id)
+            fire()
+          }
+        },1)
+      } else if (script.runAt === 'document_end') {
+        document.addEventListener('DOMContentLoaded', ()=>setTimeout(fire,0))
+        // process.once('document-end', fire)
+      } else {
+        window.addEventListener('load', ()=>setTimeout(fire,0))
+      }
+    }
+
+    if (script.css) {
+      const fire = runAllStylesheet.bind(window, script.css, extensionId, name)()
+      if(!fire){}
+      else if (script.runAt === 'document_start') {
+        // setTimeout(fire,0)
+        const id = setInterval(()=>{
+          if(document.documentElement){
+            clearInterval(id)
+            fire()
+          }
+        },1)
+        // document.addEventListener('readystatechange', () => document.readyState == 'interactive' && fire())
+        // process.once('document-start', fire)
+      } else if (script.runAt === 'document_end') {
+        // process.once('document-end', fire)
+        document.addEventListener('DOMContentLoaded', ()=>setTimeout(fire,0))
+      } else {
+        window.addEventListener('load', ()=>setTimeout(fire,0))
+      }
+    }
+  }
+
+// Handle the request of chrome.tabs.executeJavaScript.
+  ipcRenderer.on('CHROME_TABS_EXECUTESCRIPT', async function (event, senderWebContentsId, requestId, extensionId, url, code) {
+    console.log('CHROME_TABS_EXECUTESCRIPT', url, code)
+    const result = await (await runContentScript.call(window, extensionId, 'execute script', url, code))()
+    ipcRenderer.sendToAll(senderWebContentsId, `CHROME_TABS_EXECUTESCRIPT_RESULT_${requestId}`, result)
+  })
+
+// Read the renderer process preferences.
+  const preferences = ipcRenderer.sendSync('get-render-process-preferences')
+  if (preferences) {
+    for (const pref of preferences) {
+      if (pref.contentScripts) {
+        for (const script of pref.contentScripts) {
+          console.log(pref.extensionId, isExtensionPage, window.location.href, script)
+          if(isExtensionPage && !pref.admin) continue
+          injectContentScript(pref.extensionId, pref.name, script)
+        }
+      }
+    }
+  }
+
+}
+
+exe(location.href.startsWith('chrome-extension'))
\ No newline at end of file
diff --git a/lib/renderer/content-scripts-injector.js b/lib/renderer/content-scripts-injector.js
old mode 100644
new mode 100755
index 5091d84f6..fbf9d65ff
--- a/lib/renderer/content-scripts-injector.js
+++ b/lib/renderer/content-scripts-injector.js
@@ -1,38 +1,74 @@
 'use strict'
 
-const ipcRenderer = require('@electron/internal/renderer/ipc-renderer-internal')
-const { runInThisContext } = require('vm')
+const {ipcRenderer,webFrame} = require('electron')
+ipcRenderer.setMaxListeners(0)
 
+module.exports = function(isExtensionPage, isBackgroundPage){
+
+  window.close = () => ipcRenderer.send('send-to-host', 'window-close', {})
 // Check whether pattern matches.
 // https://developer.chrome.com/extensions/match_patterns
-const matchesPattern = function (pattern) {
-  if (pattern === '<all_urls>') return true
-  const regexp = new RegExp(`^${pattern.replace(/\*/g, '.*')}$`)
-  const url = `${location.protocol}//${location.host}${location.pathname}`
-  return url.match(regexp)
-}
+  const matchesPattern = function (pattern) {
+    if (pattern === '<all_urls>') return true
+    const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+?.\\/\s]/g, '\\$&').replace(/\*/g, '.*')}$`)
+    // console.log('matchesPattern',pattern,regexp)
+    const url = `${location.protocol}//${location.host}${location.pathname}`
+    return url.match(regexp)
+  }
+
+  const matchesGlob = function (pattern) {
+    if (pattern === '<all_urls>') return true
+    const regexp = new RegExp(`^${pattern.replace(/[-[\]{}()^$|+.\\/\s]/g, '\\$&').replace(/\*/g, '.*').replace(/\?/g, '.?')}$`)
+    // console.log('matchesGlob',pattern,regexp)
+    const url = `${location.protocol}//${location.host}${location.pathname}`
+    return url.match(regexp)
+  }
 
 // Run the code with chrome API integrated.
-const runContentScript = function (extensionId, url, code) {
-  const context = {}
-  require('@electron/internal/renderer/chrome-api').injectTo(extensionId, false, context)
-  const wrapper = `((chrome) => {\n  ${code}\n  })`
-  const compiledWrapper = runInThisContext(wrapper, {
-    filename: url,
-    lineOffset: 1,
-    displayErrors: true
-  })
-  return compiledWrapper.call(this, context.chrome)
-}
+  let seq = 0, seqMap = {}
+  const runContentScript = async function (extensionId, name, url, code) {
+    const context = {}
+    require('@electron/internal/renderer/chrome-api').injectTo(extensionId, false, isExtensionPage, context)
+    const wrapper = `((chrome) => { console.log(1);window.chrome = chrome;\n ${code}\n  })`
+    let worldId = seqMap[extensionId]
+    if(!worldId){
+      worldId = ++seq
+      seqMap[extensionId] = worldId
+      webFrame.setIsolatedWorldHumanReadableName(worldId, name)
+      await new Promise(r=>{
+        webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: `;\n((chrome) => { window.chrome = chrome });\n`}], false, compiledWrapper => {
+          compiledWrapper.call(this, context.chrome)
+          r()
+        })
+      })
+    }
+
 
-const runAllContentScript = function (scripts, extensionId) {
-  for (const { url, code } of scripts) {
-    runContentScript.call(window, extensionId, url, code)
+    return function(){
+      return new Promise(r=>{
+        webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: `;\n${code};\n`}], false, r)
+      })
+    }
+
+    // const compiledWrapper = runInThisContext(wrapper, {
+    //   filename: url,
+    //   lineOffset: 1,
+    //   displayErrors: true
+    // })
+    // return compiledWrapper.call(this, context.chrome)
+  }
+
+  const runAllContentScript = function (scripts, extensionId, name) {
+    let _url, _code = []
+    for (const { url, code } of scripts) {
+      _url = url
+      _code.push(code)
+    }
+    return runContentScript.call(window, extensionId, name, _url, _code.join("\n;\n"))
   }
-}
 
-const runStylesheet = function (url, code) {
-  const wrapper = `((code) => {
+  const runStylesheet = function (extensionId, name, url, code) {
+    const wrapper = `((code) => {
     function init() {
       const styleElement = document.createElement('style');
       styleElement.textContent = code;
@@ -40,62 +76,81 @@ const runStylesheet = function (url, code) {
     }
     document.addEventListener('DOMContentLoaded', init);
   })`
-  const compiledWrapper = runInThisContext(wrapper, {
-    filename: url,
-    lineOffset: 1,
-    displayErrors: true
-  })
-  return compiledWrapper.call(this, code)
-}
 
-const runAllStylesheet = function (css) {
-  for (const { url, code } of css) {
-    runStylesheet.call(window, url, code)
+    let worldId = seqMap[extensionId]
+    if(!worldId){
+      worldId = ++seq
+      seqMap[extensionId] = worldId
+      webFrame.setIsolatedWorldHumanReadableName(worldId, name)
+    }
+
+    return function(){
+      webFrame.executeJavaScriptInIsolatedWorld(worldId, [{code: wrapper}], false, compiledWrapper => {
+        compiledWrapper.call(this, code)
+      })
+    }
+  }
+
+  const runAllStylesheet = function (css, extensionId, name) {
+    for (const { url, code } of css) {
+      return runStylesheet.call(window, extensionId, name, url, code)
+    }
   }
-}
 
 // Run injected scripts.
 // https://developer.chrome.com/extensions/content_scripts
-const injectContentScript = function (extensionId, script) {
-  if (!script.matches.some(matchesPattern)) return
-
-  if (script.js) {
-    const fire = runAllContentScript.bind(window, script.js, extensionId)
-    if (script.runAt === 'document_start') {
-      process.once('document-start', fire)
-    } else if (script.runAt === 'document_end') {
-      process.once('document-end', fire)
-    } else {
-      document.addEventListener('DOMContentLoaded', fire)
+  const injectContentScript = async function (extensionId, name, script) {
+    console.log('injectContentScript')
+    if (!script.matches.some(matchesPattern)) return
+    if (script.include_globs && !script.include_globs.some(matchesGlob)) return
+    if (script.exclude_matches && script.exclude_matches.some(matchesPattern)) return
+    if (script.exclude_globs && script.exclude_globs.some(matchesGlob)) return
+
+    if (script.js) {
+      const fire = (await runAllContentScript.bind(window, script.js, extensionId, name)())
+      if (script.runAt === 'document_start') {
+        process.once('document-start', fire)
+      } else if (script.runAt === 'document_end') {
+        process.once('document-end', fire)
+      } else {
+        window.addEventListener('load', ()=>setTimeout(fire,0))
+      }
     }
-  }
 
-  if (script.css) {
-    const fire = runAllStylesheet.bind(window, script.css)
-    if (script.runAt === 'document_start') {
-      process.once('document-start', fire)
-    } else if (script.runAt === 'document_end') {
-      process.once('document-end', fire)
-    } else {
-      document.addEventListener('DOMContentLoaded', fire)
+    if (script.css) {
+      const fire = runAllStylesheet.bind(window, script.css, extensionId, name)()
+      if(!fire){}
+      else if (script.runAt === 'document_start') {
+        process.once('document-start', fire)
+      } else if (script.runAt === 'document_end') {
+        process.once('document-end', fire)
+      } else {
+        window.addEventListener('load', ()=>setTimeout(fire,0))
+      }
     }
   }
-}
 
 // Handle the request of chrome.tabs.executeJavaScript.
-ipcRenderer.on('CHROME_TABS_EXECUTESCRIPT', function (event, senderWebContentsId, requestId, extensionId, url, code) {
-  const result = runContentScript.call(window, extensionId, url, code)
-  ipcRenderer.sendToAll(senderWebContentsId, `CHROME_TABS_EXECUTESCRIPT_RESULT_${requestId}`, result)
-})
+  ipcRenderer.on('CHROME_TABS_EXECUTESCRIPT', async function (event, senderWebContentsId, requestId, extensionId, url, code) {
+    console.log('CHROME_TABS_EXECUTESCRIPT', url, code)
+    const result = await (await runContentScript.call(window, extensionId, 'execute script', url, code))()
+    ipcRenderer.sendToAll(senderWebContentsId, `CHROME_TABS_EXECUTESCRIPT_RESULT_${requestId}`, result)
+  })
 
 // Read the renderer process preferences.
-const preferences = process.getRenderProcessPreferences()
-if (preferences) {
-  for (const pref of preferences) {
-    if (pref.contentScripts) {
-      for (const script of pref.contentScripts) {
-        injectContentScript(pref.extensionId, script)
+  const preferences = ipcRenderer.sendSync('get-render-process-preferences')
+  if (preferences) {
+    for (const pref of preferences) {
+      if (pref.contentScripts) {
+        for (const script of pref.contentScripts) {
+          console.log(pref.extensionId, isExtensionPage, window.location.href, script)
+          if(isExtensionPage && !pref.admin) continue
+          // if((isExtensionPage && !pref.admin) ||
+          //   (isBackgroundPage && !window.location.href.startsWith(`chrome-extension://${pref.extensionId}`))) continue
+          injectContentScript(pref.extensionId, pref.name, script)
+        }
       }
     }
   }
-}
+
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/alarms.js b/lib/renderer/extensions/alarms.js
new file mode 100755
index 000000000..89a4264d5
--- /dev/null
+++ b/lib/renderer/extensions/alarms.js
@@ -0,0 +1,40 @@
+const {Event} = require('./event')
+const {ipcFuncRenderer} = require('./util')
+const {ipcRenderer} = require('electron')
+
+class Alarms {
+  constructor(extensionId) {
+    this._extensionId = extensionId
+    this.onAlarm = new Event()
+
+    ipcRenderer.on('CHROME_ALARMS_ONALARM', (e, wasCleared) => {
+      this.onAlarm.emit(wasCleared)
+    })
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  create(name, alarmInfo){
+    ipcFuncRenderer(this.constructor.name, 'create', void 0, this._extensionId, name, alarmInfo)
+  }
+
+  get(name, callback){
+    ipcFuncRenderer(this.constructor.name, 'get', callback, this._extensionId, name)
+  }
+
+  getAll(callback){
+    ipcFuncRenderer(this.constructor.name, 'getAll', callback, this._extensionId)
+  }
+
+  clear(name, callback){
+    ipcFuncRenderer(this.constructor.name, 'clear', callback, this._extensionId, name)
+  }
+
+  clearAll(callback){
+    ipcFuncRenderer(this.constructor.name, 'clearAll', callback, this._extensionId)
+  }
+}
+
+exports.setup = (...args) => {
+  return new Alarms(...args)
+}
diff --git a/lib/renderer/extensions/app.js b/lib/renderer/extensions/app.js
new file mode 100755
index 000000000..16b9cb906
--- /dev/null
+++ b/lib/renderer/extensions/app.js
@@ -0,0 +1,10 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = (manifest)=>{
+  return {
+    getDetails(){ return manifest },
+    getIsInstalled(){ return false },
+    installState(){},
+    isInstalled: false
+  }
+}
diff --git a/lib/renderer/extensions/bookmarks.js b/lib/renderer/extensions/bookmarks.js
new file mode 100755
index 000000000..31a3f62c5
--- /dev/null
+++ b/lib/renderer/extensions/bookmarks.js
@@ -0,0 +1,53 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = (chrome) => {
+  return {
+    get(idOrIdList, callback){
+      simpleIpcFunc('get', callback, idOrIdList)
+    },
+    getChildren(id, callback){
+      simpleIpcFunc('getChildren', callback, id)
+    },
+    getRecent(numberOfItems, callback){
+      simpleIpcFunc('getRecent', callback, numberOfItems)
+    },
+    getTree(callback){
+      simpleIpcFunc('chrome-bookmarks-getTree', ret=>{
+        if(chrome.runtime.getBrowserInfo){
+          ret[0].children = [
+            { id:"menu________", title:"Bookmark Menu", index:0, dateAdded:1528599737256, type:"folder", parentId:"0", dateGroupModified:1528599737854, children:[] },
+            { id:"toolbar_____", title:"Bookmark Toolbar", index:0, dateAdded:1528599737256, type:"folder", parentId:"0", dateGroupModified:1528599737854, children:ret[0].children },
+            { id:"unfiled_____", title:"Bookmark Unfiled", index:0, dateAdded:1528599737256, type:"folder", parentId:"0", dateGroupModified:1528599737854, children:[] },
+            { id:"mobile______", title:"Bookmark Mobile", index:0, dateAdded:1528599737256, type:"folder", parentId:"0", dateGroupModified:1528599737854, children:[] },
+            { id:"menu________", title:"Bookmark Menu", index:0, dateAdded:1528599737256, type:"folder", parentId:"0", dateGroupModified:1528599737854, children:[] },
+          ]
+        }
+        callback(ret)
+      })
+    },
+    getSubTree(id, callback){
+      simpleIpcFunc('getSubTree', callback, id)
+    },
+    search(query, callback){
+      simpleIpcFunc('search', callback, query)
+    },
+    create(bookmark, callback){
+      simpleIpcFunc('create', callback, bookmark)
+    },
+    move(id, destination, callback){
+      simpleIpcFunc('move', callback, id, destination)
+    },
+    update(id, changes, callback){
+      simpleIpcFunc('update', callback, id, changes)
+    },
+    remove(id, callback){
+      simpleIpcFunc('remove', callback, id)
+    },
+    removeTree(id, callback){
+      simpleIpcFunc('removeTree', callback, id)
+    },
+    bookmarkManagerPrivate: {
+      onMetaInfoChanged:{set(){},get(){return true},clear(){},addListener(){},removeListener(){},hasListener(){},hasListeners(){}}
+    }
+  }
+}
diff --git a/lib/renderer/extensions/browser-action.js b/lib/renderer/extensions/browser-action.js
new file mode 100755
index 000000000..ade8e3a29
--- /dev/null
+++ b/lib/renderer/extensions/browser-action.js
@@ -0,0 +1,68 @@
+const {Event} = require('./event')
+const {ipcFuncRenderer} = require('./util')
+const {ipcRenderer} = require('electron')
+
+class BrowserAction {
+  constructor(extensionId) {
+    this._extensionId = extensionId
+    this.onClicked = new Event()
+
+    ipcRenderer.on('CHROME_BROWSERACTION_ONCLICKED',(e, tab)=>{
+      this.onClicked.emit(tab)
+    })
+
+    this.show = this.enable
+    this.hide = this.disable
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  setTitle(details, callback){
+    ipcRenderer.send('chrome-browser-action-set-title', this._extensionId, details)
+  }
+
+  getTitle(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'getInfo', callback, this._extensionId, details, 'title')
+  }
+
+  setIcon(details, callback){
+    ipcRenderer.send('chrome-browser-action-set-icon', this._extensionId, details)
+  }
+
+  setPopup(details, callback){
+    ipcRenderer.send('chrome-browser-action-set-popup', this._extensionId, details)
+  }
+
+  getPopup(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'getInfo', callback, this._extensionId, details, 'popup')
+  }
+
+  setBadgeText(details, callback){
+    ipcRenderer.send('chrome-browser-action-set-badge-text', this._extensionId, details)
+  }
+
+  getBadgeText(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'getInfo', callback, this._extensionId, details, 'text')
+  }
+
+  setBadgeBackgroundColor(details, callback){
+    ipcRenderer.send('chrome-browser-action-set-badge-background-color', this._extensionId, details)
+  }
+
+  getBadgeBackgroundColor(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'getInfo', callback, this._extensionId, details, 'color')
+  }
+
+  enable(tabId, callback){
+    ipcFuncRenderer(this.constructor.name, 'enable', callback, this._extensionId, tabId, true)
+  }
+
+  disable(tabId, callback){
+    ipcFuncRenderer(this.constructor.name, 'enable', callback, this._extensionId, tabId, false)
+  }
+
+}
+
+exports.setup = (...args) => {
+  return new BrowserAction(...args)
+}
diff --git a/lib/renderer/extensions/browsing-data.js b/lib/renderer/extensions/browsing-data.js
new file mode 100755
index 000000000..9ce67d569
--- /dev/null
+++ b/lib/renderer/extensions/browsing-data.js
@@ -0,0 +1,24 @@
+const {ipcFuncRenderer} = require('./util')
+
+class BrowsingData {
+  constructor () {
+    this.types = {appcache : true, cache : true, cookies : true, downloads : true, fileSystems : true, formData : true, history : true, indexedDB : true, localStorage : true, serverBoundCertificates : false, passwords : true, pluginData : false, serviceWorkers : true, webSQL : true}
+    for(let key of Object.keys(this.types)){
+      this[`remove${key.charAt(0).toUpperCase()}${key.slice(1)}`] = (options,callback) => this.remove(options,{[key]: true},callback)
+    }
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  settings(callback){
+    callback({options:{},dataToRemove:types,DataTypeSet:types})
+  }
+
+  remove(options,dataToRemove,callback){
+    ipcFuncRenderer(this.constructor.name, 'remove', callback,options,dataToRemove)
+  }
+}
+
+exports.setup = (...args) => {
+  return new BrowsingData(...args)
+}
diff --git a/lib/renderer/extensions/commands.js b/lib/renderer/extensions/commands.js
new file mode 100755
index 000000000..62850410d
--- /dev/null
+++ b/lib/renderer/extensions/commands.js
@@ -0,0 +1,36 @@
+const {Event2} = require('./event')
+const {getIpcNameFunc, simpleIpcFunc} = require('./util')
+const {ipcRenderer} = require('electron')
+
+class Commands {
+  constructor (extensionId, manifest) {
+    const getIpcName = getIpcNameFunc(this.constructor.name)
+    this.onCommand = new Event2(this.constructor.name, 'onCommand', extensionId)
+    this._manifest = manifest
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  getAll(callback){
+    const results = []
+    const commands = this._manifest.commands
+    if(commands){
+      const process = ipcRenderer.sendSync('get-process-info')
+      const plat = process.platform == 'win32' ? 'windows' : process.platform == 'darwin' ? 'mac' : 'linux'
+      for(let [command,val] of Object.entries(commands)){
+        if(val.suggested_key){
+          results.push({
+            name:command,
+            shortcut:val.suggested_key[plat] || val.suggested_key.default,
+            description: val.description
+          })
+        }
+      }
+      callback(results)
+    }
+  }
+}
+
+exports.setup = (...args) => {
+  return new Commands(...args)
+}
diff --git a/lib/renderer/extensions/common-util.js b/lib/renderer/extensions/common-util.js
new file mode 100755
index 000000000..b246ca84f
--- /dev/null
+++ b/lib/renderer/extensions/common-util.js
@@ -0,0 +1,41 @@
+module.exports = {
+  getIpcNameFunc(className){
+    return function(method, extensionId){
+      if(extensionId){
+        return `CHROME_${className.toUpperCase()}_${method.toUpperCase()}_${extensionId}`
+      }
+      else{
+        return `CHROME_${className.toUpperCase()}_${method.toUpperCase()}`
+      }
+    }
+  },
+  _shortId() {
+    const self = this
+    const uuidLength = 8
+
+    this.DICT_RANGES = { digits: [48, 58], lowerCase: [97, 123], upperCase: [65, 91] }
+    this.dict = [];
+    this.dictIndex = this._i = 0
+
+    let rangeType
+    for (rangeType in self.DICT_RANGES) {
+      self.dictRange = self.DICT_RANGES[rangeType]
+      self.lowerBound = self.dictRange[0], self.upperBound = self.dictRange[1]
+      for (this.dictIndex = this._i = this.lowerBound; this.lowerBound <= this.upperBound ? this._i < this.upperBound : this._i > this.upperBound; this.dictIndex = this.lowerBound <= this.upperBound ? ++this._i : --this._i) {
+        self.dict.push(String.fromCharCode(self.dictIndex))
+      }
+    }
+
+    this.dict = this.dict.sort(() => Math.random() <= 0.5)
+    this.dictLength = this.dict.length
+
+    return function(){
+      let id = '', randomPartIdx, _j, idIndex
+      for (idIndex = _j = 0; 0 <= uuidLength ? _j < uuidLength : _j > uuidLength; idIndex = 0 <= uuidLength ? ++_j : --_j) {
+        randomPartIdx = parseInt(Math.random() * self.dictLength) % self.dictLength
+        id += self.dict[randomPartIdx]
+      }
+      return id
+    }
+  }
+}
diff --git a/lib/renderer/extensions/content-settings.js b/lib/renderer/extensions/content-settings.js
new file mode 100755
index 000000000..c67118088
--- /dev/null
+++ b/lib/renderer/extensions/content-settings.js
@@ -0,0 +1,19 @@
+const {ipcFuncRenderer} = require('./util')
+
+exports.setup = (extensionId) => {
+  const contentSettings = {}
+  for(let type of ['cookies','images','javascript','location','plugins','popups','notifications','fullscreen','mouselock','microphone','camera','unsandboxedPlugins','automaticDownloads','canvasFingerprinting']){
+    contentSettings[type] = {
+      get(details,callback){
+        ipcFuncRenderer('contentSettings','get',callback,details,extensionId,type)
+      },
+      set(details,callback){
+        ipcFuncRenderer('contentSettings','set',callback,details,extensionId,type)
+      },
+      clear(details,callback){
+        ipcFuncRenderer('contentSettings','clear',callback,details,extensionId,type)
+      }
+    }
+  }
+  return contentSettings
+}
diff --git a/lib/renderer/extensions/context-menus.js b/lib/renderer/extensions/context-menus.js
new file mode 100755
index 000000000..818bd9a84
--- /dev/null
+++ b/lib/renderer/extensions/context-menus.js
@@ -0,0 +1,51 @@
+const {Event} = require('./event')
+const {getIpcNameFunc, ipcFuncRenderer, shortId} = require('./util')
+const {ipcRenderer} = require('electron')
+
+class ContextMenus {
+  constructor(extensionId) {
+    this._extensionId = extensionId
+    this.onClicked = new Event()
+    this.onClickEvents = {}
+
+    ipcRenderer.on('CHROME_CONTEXTMENUS_ONCLICKED',(e, info, tab)=>{
+      this.onClicked.emit(info, tab)
+      const onClick = this.onClickEvents[info.menuItemId]
+      if(onClick) onClick(info, tab)
+    })
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  create(createProperties, callback) {
+    if(!createProperties.id) createProperties.id = shortId()
+    if(createProperties.onclick){
+      // this.onClicked.addListener(createProperties.onclick)
+      this.onClickEvents[createProperties.id] = createProperties.onclick
+      delete createProperties.onclick
+    }
+    ipcFuncRenderer(this.constructor.name, 'create', callback, this._extensionId, createProperties)
+  }
+
+  update(id, updateProperties, callback) {
+    if(updateProperties.onclick){
+      // if(this.onClickEvents[id]) this.onClicked.removeListener(this.onClickEvents[id])
+      // this.onClicked.addListener(updateProperties.onclick)
+      this.onClickEvents[id] = updateProperties.onclick
+      delete updateProperties.onclick
+    }
+    ipcFuncRenderer(this.constructor.name, 'update', callback, this._extensionId, id, updateProperties)
+  }
+
+  remove(menuItemId, callback){
+    ipcFuncRenderer(this.constructor.name, 'remove', callback, this._extensionId, menuItemId)
+  }
+
+  removeAll(callback) {
+    ipcFuncRenderer(this.constructor.name, 'removeAll', callback, this._extensionId)
+  }
+}
+
+exports.setup = (...args) => {
+  return new ContextMenus(...args)
+}
diff --git a/lib/renderer/extensions/cookies.js b/lib/renderer/extensions/cookies.js
new file mode 100755
index 000000000..cf30f37a4
--- /dev/null
+++ b/lib/renderer/extensions/cookies.js
@@ -0,0 +1,52 @@
+const {Event} = require('./event')
+const {ipcFuncRenderer} = require('./util')
+const {ipcRenderer} = require('electron')
+
+
+class Cookies {
+  constructor (extensionId, chrome) {
+    this._extensionId = extensionId
+    this._chrome = chrome
+
+    this.initEvents()
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  initEvents(){
+    this.onChanged = new Event()
+
+    ipcRenderer.on('CHROME_COOKIES_ONCHANGED', (event, changeInfo) => {
+      this.onChanged.emit(changeInfo)
+    })
+  }
+
+  get(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'get', callback, details)
+  }
+
+  getAll(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'getAll', callback, details)
+  }
+
+  set(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'set', callback, details)
+  }
+
+  remove(details, callback){
+    ipcFuncRenderer(this.constructor.name, 'remove', callback, details)
+  }
+
+  getAllCookieStores(callback){
+    this._chrome.windows.getAll({populate:true},wins=>{
+      const tabIds = []
+      for(let win of wins) tabIds.push(...win.tabs.map(t=>t.id))
+      callback([{id:"0", tabIds}])
+    })
+  }
+  
+}
+
+exports.setup = (...args) => {
+  return new Cookies(...args)
+}
diff --git a/lib/renderer/extensions/deep-equal.js b/lib/renderer/extensions/deep-equal.js
new file mode 100755
index 000000000..bd88862b9
--- /dev/null
+++ b/lib/renderer/extensions/deep-equal.js
@@ -0,0 +1,21 @@
+module.exports = function deepEqual(x, y){
+  if (typeof x !== typeof y) {
+    return false
+  }
+  if (typeof x !== 'object') {
+    return x === y
+  }
+  const xKeys = Object.keys(x)
+  const yKeys = Object.keys(y)
+  if (xKeys.length !== yKeys.length) {
+    return false
+  }
+  for (let prop in x) {
+    if (x.hasOwnProperty(prop)) {
+      if (!deepEqual(x[prop], y[prop])) {
+        return false
+      }
+    }
+  }
+  return true
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/downloads.js b/lib/renderer/extensions/downloads.js
new file mode 100755
index 000000000..c97fdf222
--- /dev/null
+++ b/lib/renderer/extensions/downloads.js
@@ -0,0 +1,41 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = () => {
+  return {
+    download(options, callback){
+      simpleIpcFunc('download',callback,options)
+    },
+    pause(downloadId, callback){
+      simpleIpcFunc('pause',callback,downloadId)
+    },
+    resume(downloadId, callback){
+      simpleIpcFunc('resume',callback,downloadId)
+    },
+    cancel(downloadId, callback){
+      simpleIpcFunc('cancel',callback,downloadId)
+    },
+    open(downloadId){
+      simpleIpcFunc('open',_=>_,downloadId)
+    },
+    show(downloadId){
+      simpleIpcFunc('show',_=>_,downloadId)
+    },
+    showDefaultFolder(){
+      simpleIpcFunc('showDefaultFolder',_=>_)
+    },
+    search(query, callback) {
+      simpleIpcFunc('chrome-downloads-search', _ => {
+        console.log(query, _)
+        callback(_)
+      }, query)
+    },
+    erase(query, callback){
+      simpleIpcFunc('erase',callback,query)
+    },
+    //@TODO
+    getFileIcon(downloadId, options, callback){
+      callback('data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==')
+    }
+
+  }
+}
diff --git a/lib/renderer/extensions/event.js b/lib/renderer/extensions/event.js
old mode 100644
new mode 100755
index 93f5ad2f7..335ac627d
--- a/lib/renderer/extensions/event.js
+++ b/lib/renderer/extensions/event.js
@@ -1,11 +1,21 @@
-'use strict'
+const {getIpcNameFunc} = require('./util')
+const {ipcRenderer} = require('electron')
 
 class Event {
-  constructor () {
+  constructor (firstExecuteCallback) {
     this.listeners = []
+    this.firstExecuteCallback = firstExecuteCallback
+    this.first = false
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
   }
 
   addListener (callback) {
+    console.log('addListener', this)
+    if(this.first){
+      this.firstExecuteCallback && this.firstExecuteCallback()
+      this.first = true
+    }
     this.listeners.push(callback)
   }
 
@@ -16,6 +26,14 @@ class Event {
     }
   }
 
+  hasListener (callback) {
+    return this.listeners.some(ele => ele == callback)
+  }
+
+  hasListeners () {
+    return !!this.listeners.length
+  }
+
   emit (...args) {
     for (const listener of this.listeners) {
       listener(...args)
@@ -23,4 +41,63 @@ class Event {
   }
 }
 
-module.exports = Event
+class Event2 {
+  constructor (name, method, extensionId, needReturn) {
+    this.listeners = new Map()
+    this.name = name
+    this.method = method
+    this.extensionId = extensionId
+    this.needReturn = needReturn
+    this.ipcName = getIpcNameFunc(name)(method, extensionId)
+    ipcRenderer.on(this.ipcName, (event, ...args) => this.emit(...args))
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  addListener (callback, ...args) {
+    const eventId = Math.random().toString()
+    console.log('addListener',this.name,this.method,this.extensionId,callback,eventId)
+    this.listeners.set(eventId, callback)
+    ipcRenderer.send(`${getIpcNameFunc(this.name)(this.method)}_REGIST`, this.extensionId, eventId, ...args)
+  }
+
+  removeListener (callback) {
+    for(let [eventId, _callback] of this.listeners){
+      if(_callback == callback){
+        this.listeners.delete(eventId)
+        ipcRenderer.send(`${getIpcNameFunc(this.name)(this.method)}_UNREGIST`, this.extensionId, eventId)
+        break
+      }
+    }
+  }
+
+  hasListener (callback) {
+    for(let [eventId, _callback] of this.listeners){
+      if(_callback == callback){
+        return true
+      }
+    }
+    return false
+  }
+
+  hasListeners () {
+    return !!this.listeners.size
+  }
+
+  emit (eventId, key, ...args) {
+    // console.log('emit', this.name,this.method,this.extensionId,eventId, ...args)
+    try{
+      if(this.needReturn){
+        const result = this.listeners.get(eventId)(...args)
+        ipcRenderer.send(`${this.ipcName}_${eventId}_${key}_RESULT`, result)
+      }
+      else{
+        const result = this.listeners.get(eventId)(key, ...args)
+      }
+    }catch(e){
+      console.log(e, 'emit', this.name,this.method,this.extensionId,eventId,key, ...args)
+    }
+  }
+}
+
+module.exports = {Event, Event2}
diff --git a/lib/renderer/extensions/extension.js b/lib/renderer/extensions/extension.js
new file mode 100755
index 000000000..7dfae52b1
--- /dev/null
+++ b/lib/renderer/extensions/extension.js
@@ -0,0 +1,22 @@
+const {Event} = require('./event')
+
+exports.setup = (chrome) => {
+  return {
+    getURL: chrome.runtime.getURL.bind(chrome.runtime),
+    connect: chrome.runtime.connect.bind(chrome.runtime),
+    onConnect: chrome.runtime.onConnect,
+    sendMessage: chrome.runtime.sendMessage.bind(chrome.runtime),
+    onMessage: chrome.runtime.onMessage,
+    sendRequest: chrome.runtime.sendMessage.bind(chrome.runtime), //@TODO FIX
+    onRequest: chrome.runtime.onMessage, //@TODO FIX
+    getBackgroundPage: chrome.runtime.getBackgroundPage.bind(chrome.runtime),
+    getViews(){return []}, //@TODO NOOP
+    isAllowedFileSchemeAccess(callback){callback(true)}, //@TODO FIX
+    isAllowedIncognitoAccess(callback){callback(true)}, //@TODO FIX
+    setUpdateUrlData(data){}, //@TODO NOOP
+    inIncognitoContext: false, //@TODO FIX
+    onRequestExternal: new Event(), //@TODO FIX
+    onConnectExternal: new Event(), //@TODO FIX
+    onMessageExternal: new Event(), //@TODO FIX
+  }
+}
diff --git a/lib/renderer/extensions/history.js b/lib/renderer/extensions/history.js
new file mode 100755
index 000000000..a424a0f47
--- /dev/null
+++ b/lib/renderer/extensions/history.js
@@ -0,0 +1,24 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = () => {
+  return {
+    search(query,callback){
+      simpleIpcFunc('search',callback,query)
+    },
+    addUrl(details,callback){
+      simpleIpcFunc('addUrl',callback,details)
+    },
+    getVisits(details,callback){
+      simpleIpcFunc('getVisits',callback,details)
+    },
+    deleteUrl(details,callback){
+      simpleIpcFunc('deleteUrl',callback,details)
+    },
+    deleteRange(details,callback){
+      simpleIpcFunc('deleteRange',callback,details)
+    },
+    deleteAll(callback){
+      simpleIpcFunc('deleteAll',callback)
+    }
+  }
+}
diff --git a/lib/renderer/extensions/i18n.js b/lib/renderer/extensions/i18n.js
old mode 100644
new mode 100755
index 661b26449..1c3b729f8
--- a/lib/renderer/extensions/i18n.js
+++ b/lib/renderer/extensions/i18n.js
@@ -1,44 +1,19 @@
-'use strict'
-
 // Implementation of chrome.i18n.getMessage
 // https://developer.chrome.com/extensions/i18n#method-getMessage
 //
 // Does not implement predefined messages:
 // https://developer.chrome.com/extensions/i18n#overview-predefined
 
-const ipcRenderer = require('@electron/internal/renderer/ipc-renderer-internal')
-const fs = require('fs')
-const path = require('path')
-
-let metadata
+const {ipcRenderer} = require('electron')
+const {ipcFuncRenderer} = require('./util')
 
-const getExtensionMetadata = (extensionId) => {
-  if (!metadata) {
-    metadata = ipcRenderer.sendSync('CHROME_I18N_MANIFEST', extensionId)
-  }
-  return metadata
-}
-
-const getMessagesPath = (extensionId, language) => {
-  const metadata = getExtensionMetadata(extensionId)
-  const localesDirectory = path.join(metadata.srcDirectory, '_locales')
-  try {
-    const filename = path.join(localesDirectory, language, 'messages.json')
-    fs.accessSync(filename, fs.constants.R_OK)
-    return filename
-  } catch (err) {
-    const defaultLocale = metadata.default_locale || 'en'
-    return path.join(localesDirectory, defaultLocale, 'messages.json')
-  }
-}
+let messages
 
 const getMessages = (extensionId, language) => {
-  try {
-    const messagesPath = getMessagesPath(extensionId, language)
-    return JSON.parse(fs.readFileSync(messagesPath)) || {}
-  } catch (error) {
-    return {}
+  if(!messages){
+    messages = ipcRenderer.sendSync('CHROME_I18N_GET_MESSAGES', extensionId, language)
   }
+  return messages
 }
 
 const getLanguage = () => {
@@ -62,7 +37,7 @@ const replacePlaceholders = (message, placeholders, substitutions) => {
 
   if (placeholders) {
     Object.keys(placeholders).forEach((name) => {
-      let { content } = placeholders[name]
+      let {content} = placeholders[name]
       content = replaceNumberedSubstitutions(content, substitutions)
       message = message.replace(new RegExp(`\\$${name}\\$`, 'gi'), content)
     })
@@ -74,7 +49,7 @@ const replacePlaceholders = (message, placeholders, substitutions) => {
 const getMessage = (extensionId, messageName, substitutions) => {
   const messages = getMessages(extensionId, getLanguage())
   if (messages.hasOwnProperty(messageName)) {
-    const { message, placeholders } = messages[messageName]
+    const {message, placeholders} = messages[messageName]
     return replacePlaceholders(message, placeholders, substitutions)
   }
 }
@@ -82,7 +57,16 @@ const getMessage = (extensionId, messageName, substitutions) => {
 exports.setup = (extensionId) => {
   return {
     getMessage (messageName, substitutions) {
-      return getMessage(extensionId, messageName, substitutions)
-    }
+      return getMessage(extensionId, messageName, substitutions) || ''
+    },
+    getAcceptLanguages(callback){
+      ipcFuncRenderer('i18n', 'getAcceptLanguages', callback)
+    },
+    getUILanguage(){
+      return navigator.languages[0] || navigator.language
+    },
+    detectLanguage(inputText, callback){
+      ipcFuncRenderer('i18n','detectLanguage',callback,inputText)
+    },
   }
 }
diff --git a/lib/renderer/extensions/idle.js b/lib/renderer/extensions/idle.js
new file mode 100755
index 000000000..6938fca72
--- /dev/null
+++ b/lib/renderer/extensions/idle.js
@@ -0,0 +1,42 @@
+const {Event} = require('./event')
+const {ipcFuncRenderer} = require('./util')
+
+class Idle {
+  constructor () {
+    this._intervalInSeconds = 60
+
+    this.onStateChanged = new Event(()=>{
+      ipcFuncRenderer('idle','querySystemIdleState', idleState => {
+        let prevState = idleState
+        this.intervalFunc = () => {
+          ipcFuncRenderer('idle','querySystemIdleState', idleState => {
+            if(prevState != idleState){
+              this.onStateChanged.emit(idleState)
+              prevState = idleState
+            }
+          } ,5)
+        }
+        this.intervalId = setInterval(this.intervalFunc, this._intervalInSeconds)
+      }, 5)
+    })
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+
+  }
+
+  queryState(detectionIntervalInSeconds, callback){
+    ipcFuncRenderer('idle','querySystemIdleState', idleState => {
+      callback(idleState == 'unknown' ? 'active' : idleState)
+    }, 5)
+  }
+
+  setDetectionInterval(intervalInSeconds){
+    this._intervalInSeconds = intervalInSeconds
+    clearInterval(this.intervalId)
+    setInterval(this.intervalFunc, this._intervalInSeconds)
+  }
+}
+
+exports.setup = (...args) => {
+  return new Idle(...args)
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/management.js b/lib/renderer/extensions/management.js
new file mode 100755
index 000000000..131b2e3f6
--- /dev/null
+++ b/lib/renderer/extensions/management.js
@@ -0,0 +1,15 @@
+const {ipcFuncRenderer} = require('./util')
+
+exports.setup = (extensionId) => {
+  return {
+    getAll(callback){
+      ipcFuncRenderer('management', 'getAll', callback)
+    },
+    get(id,callback){
+      ipcFuncRenderer('management', 'get', callback, id)
+    },
+    getSelf(callback){
+      ipcFuncRenderer('management', 'get', callback, extensionId)
+    }
+  }
+}
diff --git a/lib/renderer/extensions/message-sender.js b/lib/renderer/extensions/message-sender.js
new file mode 100755
index 000000000..f0fd04f9b
--- /dev/null
+++ b/lib/renderer/extensions/message-sender.js
@@ -0,0 +1,12 @@
+const { ipcRenderer } = require('electron')
+
+module.exports = function(tabId, extensionId){
+  const contents = tabId && (ipcRenderer.sendSync('get-message-sender-info', tabId))
+  this.tab = contents ? Object.assign({
+    audible: false,
+    autoDiscardable: true,
+    discarded: false,
+    id: tabId }, contents) : null
+  this.id = extensionId
+  this.url = (contents && contents.url) || `chrome-extension://${extensionId}`
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/notifications.js b/lib/renderer/extensions/notifications.js
new file mode 100755
index 000000000..100c72044
--- /dev/null
+++ b/lib/renderer/extensions/notifications.js
@@ -0,0 +1,109 @@
+class Notifications {
+  constructor () {
+    this.notifications = {}
+    this.onClosedEvents = new Set()
+    this.onClickedEvent = new Set()
+    const self = this
+
+    this.onClosed = {
+      addListener(cb) {
+        self.onClosedEvents.add(cb)
+      },
+      removeListener(cb){
+        self.onClosedEvents.delete(cb)
+      },
+      hasListener(cb){
+        return self.onClosedEvents.has(cb)
+      },
+      hasListeners(){
+        return !!self.onClosedEvents.length
+      }
+    }
+
+    this.onClicked = {
+      addListener(cb) {
+        self.onClickedEvent.add(cb)
+      },
+      removeListener(cb){
+        self.onClickedEvent.delete(cb)
+      },
+      hasListener(cb){
+        return self.onClickedEvent.has(cb)
+      },
+      hasListeners(){
+        return !!self.onClickedEvent.length
+      }
+    }
+
+
+    this.onButtonClicked = {
+      addListener(cb) {},
+      removeListener(cb){},
+      hasListener(cb){},
+      hasListeners(){}
+    }
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  create(notificationId, options, callback){
+    if(typeof notificationId !== "string" && notificationId !== null && notificationId !== void 0 ){
+      [notificationId,options,callback] = [Math.random().toString(),notificationId,options]
+    }
+    const params = {}
+    if(options.imageUrl) params.icon = options.imageUrl.includes(':') ? options.imageUrl : `chrome-extension://${chrome.runtime.id}/${options.imageUrl}`
+    if(options.iconUrl) params.icon = options.iconUrl.includes(':') ? options.iconUrl : `chrome-extension://${chrome.runtime.id}/${options.iconUrl}`
+    if(options.message) params.body = options.message
+    if(options.contextMessage){
+      if(params.body){
+        params.body += `\n${options.contextMessage}`
+      }
+      else{
+        params.body = options.contextMessage
+      }
+    }
+    const n = new Notification(options.title||"",params)
+    this.notifications[notificationId] = [n,options]
+
+    n.onclose = ()=>{
+      for(let method of this.onClosedEvents){
+        method(notificationId,true)
+      }
+    }
+    n.onclick = ()=>{
+      for(let method of this.onClickedEvent){
+        method(notificationId)
+      }
+    }
+    if(callback) callback(notificationId)
+  }
+
+  update(notificationId, options, callback){
+    const [n,oldOptions] = this.notifications[notificationId]
+    n.close()
+
+    options = Object.merge(oldOptions,options)
+    this.create = (notificationId, options, callback && (_=>callback(true)))
+  }
+
+  clear(notificationId, callback){
+    if(this.notifications[notificationId]){
+      const [n,options] = this.notifications[notificationId]
+      delete this.notifications[notificationId]
+      n.close()
+    }
+  }
+
+  getAll(callback){
+    const ret = []
+    for(let [id,val] of this.notifications){
+      ret.push(Object.assign({id,notificationId:id}, val))
+    }
+    callback(ret)
+  }
+
+}
+
+exports.setup = (...args) => {
+  return new Notifications(...args)
+}
diff --git a/lib/renderer/extensions/permissions.js b/lib/renderer/extensions/permissions.js
new file mode 100755
index 000000000..b4482654d
--- /dev/null
+++ b/lib/renderer/extensions/permissions.js
@@ -0,0 +1,8 @@
+exports.setup = ()=>{
+  return {
+    getAll(permissions,callback){callback([])}, //@TODO
+    contains(permissions,callback){callback(true)}, //@TODO
+    request(permissions,callback){callback(true)}, //@TODO
+    remove(permissions,callback){callback(true)}, //@TODO
+  }
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/port.js b/lib/renderer/extensions/port.js
new file mode 100755
index 000000000..3b52d87bf
--- /dev/null
+++ b/lib/renderer/extensions/port.js
@@ -0,0 +1,45 @@
+const {ipcRenderer} = require('electron')
+const {Event} = require('./event')
+const Tab = require('./tab')
+const MessageSender = require('./message-sender')
+
+module.exports = class Port {
+  constructor (tabId, portId, extensionId, name) {
+    this.tabId = tabId
+    this.portId = portId
+    this.disconnected = false
+
+    this.name = name
+    this.onDisconnect = new Event()
+    this.onMessage = new Event()
+    this.sender = new MessageSender(tabId, extensionId)
+
+    ipcRenderer.once(`CHROME_PORT_DISCONNECT_${portId}`, () => {
+      this._onDisconnect()
+    })
+    ipcRenderer.on(`CHROME_PORT_POSTMESSAGE_${portId}`, (event, message) => {
+      const sendResponse = function () { console.error('sendResponse is not implemented') }
+      this.onMessage.emit(message, this)
+    })
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  disconnect () {
+    if (this.disconnected) return
+
+    ipcRenderer.sendToAll(this.tabId, `CHROME_PORT_DISCONNECT_${this.portId}`)
+    this._onDisconnect()
+  }
+
+  postMessage (message) {
+    console.log('postMessage',message)
+    ipcRenderer.sendToAll(this.tabId, `CHROME_PORT_POSTMESSAGE_${this.portId}`, message)
+  }
+
+  _onDisconnect () {
+    this.disconnected = true
+    ipcRenderer.removeAllListeners(`CHROME_PORT_POSTMESSAGE_${this.portId}`)
+    this.onDisconnect.emit()
+  }
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/privacy.js b/lib/renderer/extensions/privacy.js
new file mode 100755
index 000000000..1024f6f77
--- /dev/null
+++ b/lib/renderer/extensions/privacy.js
@@ -0,0 +1,23 @@
+exports.setup = () => {
+  const settingObj = {set(){},get(){return true},clear(){},onChange:{addListener(){},removeListener(){},hasListener(){},hasListeners(){}}}
+
+  return {
+    network: {
+      networkPredictionEnabled: settingObj
+    },
+    services: {
+      alternateErrorPagesEnabled: settingObj,
+      instantEnabled: settingObj,
+      safeBrowsingEnabled: settingObj,
+      searchSuggestEnabled: settingObj,
+      spellingServiceEnabled: settingObj,
+      translationServiceEnabled: settingObj
+    },
+    websites: {
+      thirdPartyCookiesAllowed: settingObj,
+      hyperlinkAuditingEnabled: settingObj,
+      referrersEnabled: settingObj,
+      protectedContentEnabled: settingObj
+    }
+  }
+}
diff --git a/lib/renderer/extensions/proxy.js b/lib/renderer/extensions/proxy.js
new file mode 100755
index 000000000..e3728fb90
--- /dev/null
+++ b/lib/renderer/extensions/proxy.js
@@ -0,0 +1,22 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = () => {
+  let data = {}
+  return {
+    get(details, callback) {
+      callback(data)
+    },
+    set(details, callback) {
+      data = details
+      simpleIpcFunc('chrome-proxy-settings-set', (...args) => {
+        callback(...args)
+      }, details)
+    },
+    clear(details, callback) {
+      data = {}
+      simpleIpcFunc('chrome-proxy-settings-set', (...args) => {
+        callback(...args)
+      }, {})
+    }
+  }
+}
diff --git a/lib/renderer/extensions/runtime.js b/lib/renderer/extensions/runtime.js
new file mode 100755
index 000000000..0f90fef6b
--- /dev/null
+++ b/lib/renderer/extensions/runtime.js
@@ -0,0 +1,303 @@
+const {getIpcNameFunc, shortId} = require('./util')
+const {Event} = require('./event')
+const getIpcName = getIpcNameFunc('WebRequest')
+const {ipcRenderer} = require('electron')
+const Port = require('./port')
+const url = require('url')
+
+
+class Runtime {
+  constructor(extensionId, manifest, isBackgroundPage, isExtensionPage, chrome, webContentsKey) {
+    this.id = extensionId
+    this._manifest = manifest
+    this._isBackgroundPage = isBackgroundPage
+    this._isExtensionPage = isExtensionPage
+    this._chrome = chrome
+    this._webContentsKey = webContentsKey
+    this.onConnect = new Event()
+    this.onMessage = new Event()
+
+    this.onRequestExternal = new Event() //@TODO FIX
+    this.onConnectExternal = new Event() //@TODO FIX
+    this.onMessageExternal = new Event() //@TODO FIX
+
+    this.onStartup = new Event() //@TODO NOOP
+    this.onInstalled = new Event() //@TODO NOOP
+    this.onSuspend = new Event() //@TODO NOOP
+    this.onSuspendCanceled = new Event() //@TODO NOOP
+    this.onUpdateAvailable = new Event() //@TODO NOOP
+    this.onBrowserUpdateAvailable = new Event() //@TODO NOOP
+
+    this.PlatformOs = {MAC: 'mac', WIN: 'win', ANDROID: 'android', CROS: 'cros', LINUX: 'linux', OPENBSD: 'openbsd'}
+    this.PlatformArch = {ARM: 'arm', X86_32: 'x86-32', X86_64: 'x86-64'}
+    this.PlatformNaclArch = {ARM: 'arm', X86_32: 'x86-32', X86_64: 'x86-64'}
+    this.RequestUpdateCheckStatus = {THROTTLED: 'throttled', NO_UPDATE: 'no_update', UPDATE_AVAILABLE: 'update_available'}
+    this.OnInstalledReason = {INSTALL: 'install', UPDATE: 'update', CHROME_UPDATE: 'chrome_update', SHARED_MODULE_UPDATE: 'shared_module_update'}
+    this.OnRestartRequiredReason = {APP_UPDATE: 'app_update', OS_UPDATE: 'os_update', PERIODIC: 'periodic'}
+
+    this._map = {}
+    this.noProxy = new Set(['boolean', 'number', 'string', 'symbol', 'undefined'])
+
+    if (!this._isExtensionPage) {
+      delete this.getBackgroundPage
+      delete this.openOptionsPage
+      delete this.setUninstallURL
+      delete this.reload
+      delete this.requestUpdateCheck
+      delete this.restart
+      delete this.getPlatformInfo
+      delete this.getPackageDirectoryEntry
+    }
+
+    const map = this._map
+    const self = this
+    const noProxy = this.noProxy
+    if(this._isBackgroundPage){
+      ipcRenderer.on('get-background-data', (e, rendererId, key, dataKey, type, name, data) => {
+        console.log('get-background-data', rendererId, key, dataKey, type, name, data)
+        let result = null
+        try{
+          let o = map[dataKey] === void 0 ? window : map[dataKey]
+
+          if(type == 'get'){
+            result = o[name]
+            if(typeof result == 'function') result = result.bind(o)
+            map[key] = result
+          }
+          else if(type == 'set'){
+            data = this._makeRemoteFunc(data, rendererId)
+            o[name] = data
+          }
+          else if(type == 'defineProperty'){
+            data = this._makeRemoteFunc(data, rendererId)
+            result = Object.defineProperty(o, name, data)
+            map[key] = result
+          }
+          else if(type == 'apply'){
+            data = data.map(d => this._makeRemoteFunc(d, rendererId))
+            result = o(...data)
+            map[key] = result
+          }
+        }catch(e){ console.log(e)}
+        ipcRenderer.send(`get-background-data-reply_${key}`, result,
+          typeof result == 'function' ? 'function' : self._checkProxy(result))
+      })
+    }
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  _makeRemoteFunc(data, rendererId){
+    if(data != null && data.__function_){
+      return (...args) =>{
+        return ipcRenderer.send('send-args-renderer', data.__function_, rendererId, args)
+      }
+    }
+    return data
+  }
+
+  _checkProxy(data){
+    if(Array.isArray(data)){
+      for(let v of data){
+        if(this._checkProxy(v) == 'proxy') return 'proxy'
+      }
+    }
+    else if(data != null && data.constructor.name == 'Object'){
+      for(let v of Object.values(data)){
+        if(this._checkProxy(v) == 'proxy') return 'proxy'
+      }
+    }
+    else{
+      if(!data || this.noProxy.has(typeof data)){
+        return 'no-proxy'
+      }
+      else{
+        return 'proxy'
+      }
+    }
+  }
+
+  _buildProxyValue(data){
+    if(typeof data == 'function'){
+      const key = shortId()
+      const func = (e, args) => data(...args)
+      ipcRenderer.once(`send-args-renderer_${key}`,func)
+      setTimeout(()=>ipcRenderer.removeListener(`send-args-renderer_${key}`,func),3000)
+      return {__function_: key}
+    }
+    return data
+  }
+
+
+  _makeProxy(key2, type2){
+    const self = this
+    return new Proxy(type2 == 'function' ? ()=>{} : {}, {
+      get(target, property, receiver){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, key2, 'get', self._buildProxyValue(property))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      },
+      set(target, property, value, receiver){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, key2, 'set', property, self._buildProxyValue(value))
+        return value
+      },
+      apply(target, thisArg, argumentsList){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, key2, 'apply', void 0, argumentsList.map(x=> self._buildProxyValue(x)))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      },
+      defineProperty(target, property, descriptor) {
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, key2, 'defineProperty', property, self._buildProxyValue(descriptor))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      }
+    })
+  }
+
+  getBackgroundPage(callback){
+    if(this._isBackgroundPage){
+      return callback ? callback(window) : window
+    }
+    // else{
+    //   return window.open(`chrome-extension://${this.id}/${this._manifest.background.page}`)
+    // }
+
+    const self = this
+    const bgWindow = new Proxy({}, {
+      get(target, property, receiver){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, null, 'get', self._buildProxyValue(property))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      },
+      set(target, property, value, receiver){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, null, 'set', property, self._buildProxyValue(value))
+        return value
+      },
+      apply(target, thisArg, argumentsList){
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, null, 'apply', void 0, argumentsList.map(x=> self._buildProxyValue(x)))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      },
+      defineProperty(target, property, descriptor) {
+        const {key, result, type} = ipcRenderer.sendSync('background-data', self.id, null, 'defineProperty', property, self._buildProxyValue(descriptor))
+        return type == 'no-proxy' ? result : self._makeProxy(key, type)
+      }
+    })
+    return callback ? callback(bgWindow) : bgWindow
+
+  }
+
+  openOptionsPage(callback){
+    const optionPage = this._manifest.options_page || (this._manifest.options_ui && this._manifest.options_ui.page)
+    console.error('optionPage')//@TODO
+  }
+
+  getManifest(){
+    return this._manifest
+  }
+
+  setUninstallURL(url, callback){} //@TODO NOOP
+
+  reload(){
+    location.reload()
+  }
+
+  requestUpdateCheck(callback){
+    callback('no_update') //@TODO FIX
+  }
+
+  restart(){
+    console.error('Function available only for ChromeOS kiosk mode.')
+  }
+
+  restartAfterDelay(){
+    console.error('Function available only for ChromeOS kiosk mode.')
+  }
+
+  getPlatformInfo(callback){
+    const process = ipcRenderer.sendSync('get-process-info')
+    const arch = process.arch
+    const platform = process.platform
+    callback({arch: arch == 'x64' ? this.PlatformArch.X86_64 : this.PlatformArch.X86_32,
+      nacl_arch: arch == 'x64' ? this.PlatformNaclArch.X86_64 : this.PlatformNaclArch.X86_32,
+      os: platform == 'win32' ? this.PlatformOs.WIN :
+        platform == 'darwin' ? this.PlatformOs.MAC : this.PlatformOs.LINUX})
+  }
+
+  getPackageDirectoryEntry(){
+    return {} //@TODO NOOP
+  }
+
+  getURL(path) {
+    return url.resolve(`https://${this.id}/`, path || '').replace(/^https/, 'chrome-extension')
+  }
+
+  connect(...args) {
+    console.log(`connect`, ...args)
+    // if (this._isBackgroundPage) {
+    //   console.error('chrome.runtime.connect is not supported in background page')
+    //   return
+    // }
+
+    // Parse the optional args.
+    let targetExtensionId = this.id
+    let connectInfo = {name: ''}
+    if (args.length === 1) {
+      connectInfo = args[0]
+    } else if (args.length === 2) {
+      [targetExtensionId, connectInfo] = args
+    }
+
+    const {tabId, portId} = ipcRenderer.sendSync('CHROME_RUNTIME_CONNECT', targetExtensionId, connectInfo, this._webContentsKey)
+    return new Port(tabId, portId, this.id, connectInfo.name)
+  }
+
+
+  sendMessage(extensionId, message, options, responseCallback) {
+    if((extensionId != null && typeof extensionId != 'string') ||
+      (typeof extensionId == 'string' && (message == null || typeof message == 'function'))){
+      [extensionId, message, options, responseCallback] = [void 0, extensionId, message, options]
+    }
+
+    if(typeof options == 'function'){
+      [options, responseCallback] = [void 0, options]
+    }
+
+    console.log(`sendMessage`, extensionId, message, options)
+    // if (this._isBackgroundPage) {
+    //   console.log('chrome.runtime.sendMessage is not supported in background page')
+    //   return
+    // }
+
+    const originResultID = shortId()
+    // Parse the optional args.
+    let targetExtensionId = extensionId || this.id
+
+    if(responseCallback){
+      let isResponsed
+      ipcRenderer.once(`CHROME_RUNTIME_SENDMESSAGE_RESULT_${originResultID}`, (event, result) =>{
+        isResponsed = true
+        responseCallback(result)
+      })
+      setTimeout(()=>{
+        if(!isResponsed){
+          console.error(`sendMessageError`, extensionId, message, options)
+          responseCallback(null)
+        }
+      },2000)
+    }
+    ipcRenderer.send('CHROME_RUNTIME_SENDMESSAGE', targetExtensionId, message, originResultID, this._webContentsKey)
+  }
+
+  back(){
+    ipcRenderer.send('send-to-host','history','back',Date.now())
+  }
+
+  forward(){
+    ipcRenderer.send('send-to-host','history','forward',Date.now())
+  }
+
+  go(ind){
+    ipcRenderer.send('send-to-host','history','go',Date.now(),ind)
+  }
+}
+
+
+exports.setup = (...args) => {
+  return new Runtime(...args)
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/sessions.js b/lib/renderer/extensions/sessions.js
new file mode 100755
index 000000000..1df5e481a
--- /dev/null
+++ b/lib/renderer/extensions/sessions.js
@@ -0,0 +1,45 @@
+const {Event} = require('./event')
+const {ipcFuncRenderer, simpleIpcFunc} = require('./util')
+const {ipcRenderer} = require('electron')
+
+
+class Sessions {
+  constructor (extensionId, chrome) {
+    this._extensionId = extensionId
+    this._chrome = chrome
+
+    this.initEvents()
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  initEvents(){
+    this.onChanged = new Event()
+
+    ipcRenderer.on('CHROME_SESSIONS_ONCHANGED', (event, changeInfo) => {
+      this.onChanged.emit(changeInfo)
+    })
+  }
+
+  getRecentlyClosed(filter, callback){
+    if(typeof filter === 'function') [filter,callback] = [null,filter]
+    simpleIpcFunc('chrome-sessions-getRecentlyClosed',callback,filter)
+  }
+
+  restore(sessionId, callback){
+    if(typeof sessionId === 'function') [sessionId,callback] = [null,sessionId]
+    simpleIpcFunc('chrome-sessions-restore',(type,tabId)=>{
+      if(type == "tab"){
+        this._chrome.tabs.get(tabId,tab=>callback({lastModified:Date.now(),tab}))
+      }
+      else{
+        callback({lastModified:Date.now(),window:{}}) //@TODO
+      }
+    },sessionId)
+  }
+  
+}
+
+exports.setup = (...args) => {
+  return new Sessions(...args)
+}
diff --git a/lib/renderer/extensions/storage.js b/lib/renderer/extensions/storage.js
old mode 100644
new mode 100755
index 8afaac765..f80704fc0
--- a/lib/renderer/extensions/storage.js
+++ b/lib/renderer/extensions/storage.js
@@ -1,80 +1,36 @@
-'use strict'
+const { ipcRenderer } = require('electron')
+const {ipcFuncRenderer} = require('./util')
+const {Event} = require('./event')
 
-const fs = require('fs')
-const path = require('path')
-const { remote } = require('electron')
-const { app } = remote
 
-const getChromeStoragePath = (storageType, extensionId) => {
-  return path.join(
-    app.getPath('userData'), `/Chrome Storage/${extensionId}-${storageType}.json`)
-}
-
-const mkdirp = (dir, callback) => {
-  fs.mkdir(dir, (error) => {
-    if (error && error.code === 'ENOENT') {
-      mkdirp(path.dirname(dir), (error) => {
-        if (!error) {
-          mkdirp(dir, callback)
-        }
-      })
-    } else if (error && error.code === 'EEXIST') {
-      callback(null)
-    } else {
-      callback(error)
-    }
-  })
-}
-
-const readChromeStorageFile = (storageType, extensionId, cb) => {
-  const filePath = getChromeStoragePath(storageType, extensionId)
-  fs.readFile(filePath, 'utf8', (err, data) => {
-    if (err && err.code === 'ENOENT') {
-      return cb(null, null)
-    }
-    cb(err, data)
-  })
-}
-
-const writeChromeStorageFile = (storageType, extensionId, data, cb) => {
-  const filePath = getChromeStoragePath(storageType, extensionId)
-
-  mkdirp(path.dirname(filePath), err => {
-    if (err) { /* we just ignore the errors of mkdir or mkdirp */ }
-    fs.writeFile(filePath, data, cb)
-  })
-}
-
-const getStorage = (storageType, extensionId, cb) => {
-  readChromeStorageFile(storageType, extensionId, (err, data) => {
+const getData = (storageType, extensionId, keys, cb) => {
+  ipcFuncRenderer('storage', 'read', ({err, data}) => {
     if (err) throw err
     if (!cb) throw new TypeError('No callback provided')
 
     if (data !== null) {
-      cb(JSON.parse(data))
+      cb(data)
     } else {
       // Disabled due to false positive in StandardJS
       // eslint-disable-next-line standard/no-callback-literal
       cb({})
     }
-  })
+  }, storageType, extensionId, keys)
 }
 
-const setStorage = (storageType, extensionId, storage, cb) => {
-  const json = JSON.stringify(storage)
-  writeChromeStorageFile(storageType, extensionId, json, err => {
+const setStorage = (storageType, extensionId, type, data, cb) => {
+  ipcFuncRenderer('storage', 'write', ({err,data}) => {
     if (err) throw err
-    if (cb) cb()
-  })
+    if (cb) cb(data)
+  }, storageType, extensionId, type, data)
 }
 
-const getStorageManager = (storageType, extensionId) => {
+const getStorageManager = (storageType, extensionId, onChanged) => {
   return {
     get (keys, callback) {
-      getStorage(storageType, extensionId, storage => {
-        if (keys == null) return callback(storage)
-
-        let defaults = {}
+      let defaults = {}
+      if(typeof keys === 'function') [keys,callback] = [null,keys]
+      if(keys != null){
         switch (typeof keys) {
           case 'string':
             keys = [keys]
@@ -86,53 +42,59 @@ const getStorageManager = (storageType, extensionId) => {
             }
             break
         }
+      }
+      getData(storageType, extensionId, keys,  data => {
+        if (keys == null) return callback(data)
 
         // Disabled due to false positive in StandardJS
         // eslint-disable-next-line standard/no-callback-literal
         if (keys.length === 0) return callback({})
 
-        const items = {}
+        let items = {}
         keys.forEach(function (key) {
-          let value = storage[key]
+          var value = data[key]
           if (value == null) value = defaults[key]
-          items[key] = value
+          if (value != null) items[key] = value
         })
         callback(items)
       })
     },
 
     set (items, callback) {
-      getStorage(storageType, extensionId, storage => {
-        Object.keys(items).forEach(function (name) {
-          storage[name] = items[name]
-        })
-
-        setStorage(storageType, extensionId, storage, callback)
+      if(!items) return callback && callback()
+      const changeInfos = {}
+      if(Object.keys(changeInfos).length) onChanged.emit(changeInfos, storageType)
+      setStorage(storageType, extensionId, 'set', items, changeInfos => {
+        if(callback) callback()
+        if(Object.keys(changeInfos).length) onChanged.emit(changeInfos, storageType)
       })
     },
 
     remove (keys, callback) {
-      getStorage(storageType, extensionId, storage => {
-        if (!Array.isArray(keys)) {
-          keys = [keys]
-        }
-        keys.forEach(function (key) {
-          delete storage[key]
-        })
+      if (!Array.isArray(keys)) {
+        keys = [keys]
+      }
 
-        setStorage(storageType, extensionId, storage, callback)
+      setStorage(storageType, extensionId, 'remove', keys, changeInfos => {
+        if(callback) callback()
+        if(Object.keys(changeInfos).length) onChanged.emit(changeInfos, storageType)
       })
     },
 
     clear (callback) {
-      setStorage(storageType, extensionId, {}, callback)
+      setStorage(storageType, extensionId, 'clear', callback)
     }
   }
 }
 
 module.exports = {
-  setup: extensionId => ({
-    sync: getStorageManager('sync', extensionId),
-    local: getStorageManager('local', extensionId)
-  })
+  setup: extensionId => {
+    const onChanged = new Event()
+    return {
+      sync: getStorageManager('sync', extensionId, onChanged),
+      local: getStorageManager('local', extensionId, onChanged),
+      managed: getStorageManager('managed', extensionId, onChanged), //@TODO FIX
+      onChanged
+    }
+  }
 }
diff --git a/lib/renderer/extensions/tab.js b/lib/renderer/extensions/tab.js
new file mode 100755
index 000000000..c7037b68f
--- /dev/null
+++ b/lib/renderer/extensions/tab.js
@@ -0,0 +1,5 @@
+const {ipcRenderer} = require('electron')
+
+module.exports= function(tabId){
+  return ipcRenderer.sendSync('CHROME_TABS_TAB_VALUE', tabId)
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/tabs.js b/lib/renderer/extensions/tabs.js
new file mode 100755
index 000000000..ef9977c33
--- /dev/null
+++ b/lib/renderer/extensions/tabs.js
@@ -0,0 +1,385 @@
+const {Event} = require('./event')
+const {getIpcNameFunc, ipcFuncRenderer, shortId, simpleIpcFunc, deepEqual} = require('./util')
+const {ipcRenderer} = require('electron')
+const Tab = require('./tab')
+const Port = require('./port')
+
+let nextId = 0
+
+const convertUrlMap = {
+  'chrome://bookmarks/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/favorite.html',
+  'chrome://history/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/history.html',
+  'about:blank': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/blank.html',
+  'chrome://bookmarks-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/favorite_sidebar.html',
+  'chrome://tab-history-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/tab_history_sidebar.html',
+  'chrome://tab-trash-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/tab_trash_sidebar.html',
+  'chrome://download-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/download_sidebar.html',
+  'chrome://note-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/note_sidebar.html',
+  'chrome://note/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/note.html',
+  'chrome://session-manager-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/saved_state_sidebar.html',
+  'chrome://history-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/history_sidebar.html',
+  'chrome://explorer/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/explorer.html',
+  'chrome://explorer-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/explorer_sidebar.html',
+  'chrome://download/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/download.html',
+  'chrome://terminal/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/terminal.html',
+  'chrome://converter/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/converter.html',
+  'chrome://automation/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/automation.html',
+  'chrome://settings/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html',
+  'chrome://settings#general': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#general',
+  'chrome://settings#search': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#search',
+  'chrome://settings#tabs': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#tabs',
+  'chrome://settings#keyboard': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#keyboard',
+  'chrome://settings#extensions': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#extensions',
+}
+
+class Tabs {
+  constructor (extensionId, manifest, isBackgroundPage, chrome, webContentsKey) {
+    this._extensionId = extensionId
+    this._manifest = manifest
+    this._isBackgroundPage = isBackgroundPage
+    this._webContentsKey = webContentsKey
+    this._chrome = chrome
+    this.tabValues = {}
+
+    this.MutedInfoReason = {USER: "user", CAPTURE: "capture", EXTENSION: "extension"}
+    this.ZoomSettingsMode = {AUTOMATIC: "automatic", MANUAL: "manual", DISABLED: "disabled"}
+    this.ZoomSettingsScope = {PER_ORIGIN: "per-origin", PER_TAB: "per-tab"}
+    this.TabStatus = {LOADING: "loading", COMPLETE: "complete"}
+    this.WindowType = {NORMAL: "normal", POPUP: "popup", PANEL: "panel", APP: "app", DEVTOOLS: "devtools"}
+
+    this.initEvents()
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  initEvents(){
+    for(let event of [
+      'onUpdated',
+      'onCreated',
+      'onRemoved',
+      'onSelectionChanged',
+      'onActiveChanged',
+      'onActivated',
+      'onHighlightChanged',
+      'onHighlighted',
+
+      'onReplaced',
+      'onZoomChange'
+    ]){
+      this[event] = new Event()
+    }
+
+    for(let method of ['onMoved','onDetached','onAttached']){
+      const name = `chrome-tabs-${method}`
+      const ipcEvents = {}
+      this[method] = {
+        addListener(cb) {
+          ipcEvents[cb] = (e, tabId, info) => cb(tabId, info)
+          ipcRenderer.send(`regist-${name}`)
+          ipcRenderer.on(name, ipcEvents[cb])
+        },
+        removeListener(cb){
+          ipcRenderer.send(`unregist-${name}`)
+          ipcRenderer.removeListener(name, ipcEvents[cb])
+        },
+        hasListener(cb){
+          return !!ipcEvents[cb]
+        },
+        hasListeners(){
+          return !!Object.keys(ipcEvents).length
+        }
+      }
+    }
+    // onReplaced
+    // onZoomChange
+
+    ipcRenderer.on('CHROME_TABS_ONCREATED', (event, tabId) => {
+      console.log('CHROME_TABS_ONCREATED', tabId)
+      const tab = Tab(tabId)
+      console.log('CHROME_TABS_ONCREATED2')
+      this.tabValues[tabId] = tab
+      ipcRenderer.send('CHROME_TABS_ONCREATED', tab)
+      this.onCreated.emit(tab)
+      console.log(444,tabId, {status:'loading'}, tab)
+      this.onUpdated.emit(tabId, {status:'loading'}, tab)
+    })
+
+    ipcRenderer.on('CHROME_TABS_ONREMOVED', (event, tabId) => {
+      this.onRemoved.emit(tabId)
+    })
+
+    ipcRenderer.on('CHROME_TABS_ONUPDATED', (event, tabId) => {
+      const tabValue = Tab(tabId)
+      const oldTabInfo = this.tabValues[tabId] || {}
+      let changeInfo = {}
+
+      for (const key in tabValue) {
+        if (!deepEqual(tabValue[key], oldTabInfo[key])) {
+          changeInfo[key] = tabValue[key]
+        }
+      }
+
+      if (Object.keys(changeInfo).length > 0) {
+        const tab = Tab(tabId)
+        this.tabValues[tabId] = tab
+        console.log('CHROME_TABS_ONUPDATED',changeInfo,tab)
+        if(changeInfo.active){
+          for(let event of ['onSelectionChanged',
+            'onActiveChanged',
+            'onActivated',
+            'onHighlightChanged',
+            'onHighlighted']){
+            if(this[event].listeners.length){
+              this[event].emit({windowId: ipcRenderer.sendSync('get-browser-window-from-web-contents', tabId)})
+            }
+          }
+        }
+        delete changeInfo.active
+        this.onUpdated.emit(tabId, changeInfo, tab)
+      }
+    })
+  }
+
+  get(tabId, callback){
+    setTimeout(()=>callback(Tab(tabId)),0)
+  }
+
+  getCurrent(callback){
+    ipcFuncRenderer('tabs', 'getFocusedWebContents',tabId=>{
+      callback(Tab(tabId))
+    })
+  }
+
+  sendRequest(tabId, request, responseCallback){
+    this.sendMessage(tabId, request, responseCallback)
+  }
+
+  getSelected(windowId, callback){
+    if (!Number.isFinite(windowId) && windowId !== null && windowId !== void 0) {
+      [windowId,callback] = [null,windowId]
+    }
+    this.query(windowId ? {active: true,windowId} : {active: true},tabs=>callback(tabs && tabs[0]))
+  }
+
+  getAllInWindow(windowId, callback){
+    if(typeof windowId === 'function') [windowId,callback] = [null,windowId]
+    this.query(windowId ? {windowId} : {}, callback)
+  }
+
+  create(createProperties, callback){
+    if(createProperties){
+      if(createProperties.url) {
+        if(!createProperties.url.includes("://")) {
+          createProperties.url = `chrome-extension://${chrome.runtime.id}/${createProperties.url.split("/").filter(x => x).join("/")}`
+        }
+        createProperties.url = convertUrlMap[createProperties.url] || createProperties.url
+      }
+      if(createProperties.selected !== void 0) {
+        createProperties.active = createProperties.selected
+      }
+      if(createProperties.highlighted !== void 0) {
+        createProperties.active = createProperties.highlighted
+      }
+    }
+    ipcFuncRenderer(this.constructor.name, 'create', callback, createProperties)
+  }
+
+  duplicate(tabId, callback){
+    const key = shortId()
+    ipcRenderer.send('chrome-tabs-duplicate', key, tabId)
+    ipcRenderer.once(`chrome-tabs-duplicate-reply_${key}`, (e, newTabId) => {
+      callback && callback(Tab(newTabId))
+    })
+  }
+
+  query(queryInfo, callback){
+    if(queryInfo.lastFocusedWindow !== void 0){
+      delete queryInfo.lastFocusedWindow
+    }
+    if(queryInfo.windowType !== void 0){
+      delete queryInfo.windowType
+    }
+    if(queryInfo.currentWindow == false){
+      delete queryInfo.currentWindow
+    }
+    ipcFuncRenderer(this.constructor.name, 'query', callback, queryInfo)
+  }
+
+  highlight(highlightInfo, callback){
+    let tabIds = highlightInfo.tabs
+    if(Number.isFinite(tabIds)){
+      tabIds = [tabIds]
+    }
+    for(let tabId of tabIds){
+      this.update(tabId, {active: true}, ()=>callback && callback([])) //@TODO FIX
+    }
+  }
+
+  update(tabId, updateProperties, callback){
+    const func = (tabId, updateProperties, callback)=>{
+      if(updateProperties.muted !== void 0){
+        ipcRenderer.send('set-audio-muted',tabId,updateProperties.muted,true)
+      }
+      updateProperties.active = updateProperties.active || updateProperties.highlighted ||updateProperties.selected
+      ipcFuncRenderer(this.constructor.name, 'update', ()=>callback && callback(Tab(tabId)), tabId, updateProperties)
+    }
+
+    if(!Number.isFinite(tabId) && tabId !== null && tabId !== void 0){
+      [tabId,updateProperties,callback] = [null,tabId,updateProperties]
+      simpleIpcFunc('chrome-tabs-current-tabId',tabId=>{
+        func(tabId, updateProperties, callback)
+      })
+    }
+    else if(!tabId){
+      simpleIpcFunc('chrome-tabs-current-tabId',tabId=>{
+        func(tabId, updateProperties, callback)
+      })
+    }
+    else{
+      func(tabId, updateProperties, callback)
+    }
+  }
+
+  move(tabIds, moveProperties, callback){
+    if(Number.isFinite(tabIds)){
+      tabIds = [tabIds]
+    }
+    simpleIpcFunc('chrome-tabs-move',winIds=>{
+      this._chrome.windows.getAll({populate:true},windows=>{
+        const tabs = []
+        for(let win of windows){
+          if(!winIds.includes(win.id)) continue
+          for(let tab of win.tabs){
+            if(tabIds.includes(tab.id)) tabs.push(tab)
+          }
+        }
+        if(callback) callback(tabs)
+      })
+    },tabIds, moveProperties)
+  }
+
+  reload(tabId, reloadProperties, callback){
+    if(!Number.isFinite(tabId)){
+      if(Object.prototype.toString.call(tabId)=="[object Object]" && tabId !== null && tabId !== void 0){
+        [tabId,reloadProperties,callback] = [null,tabId,reloadProperties]
+      }
+      else if(typeof tabId === 'function'){
+        [tabId,reloadProperties,callback] = [null,null,tabId]
+      }
+    }
+    if(typeof tabId === 'function'){
+      [reloadProperties,callback] = [null,reloadProperties]
+    }
+    ipcFuncRenderer(this.constructor.name, 'reload', callback, tabId, reloadProperties)
+  }
+
+  remove(tabIds, callback){
+    if(Number.isFinite(tabIds)){
+      tabIds = [tabIds]
+    }
+    ipcFuncRenderer(this.constructor.name, 'remove', callback, tabIds)
+  }
+
+  detectLanguage(tabId, callback){
+    if(typeof tabId === 'function') [tabId,callback] = [null,tabId]
+
+    this.get(tabId, tab=>{
+      ipcFuncRenderer(this.constructor.name, 'detectLanguage', callback, tabId)
+    })
+  }
+
+  captureVisibleTab(windowId, options, callback){
+    if(!Number.isFinite(windowId)){
+      if(Object.prototype.toString.call(windowId)=="[object Object]"){
+        [windowId,options,callback] = [null,windowId,options]
+      }
+      else if(typeof windowId === 'function'){
+        [windowId,options,callback] = [null,null,windowId]
+      }
+    }
+    if(typeof windowId === 'function'){
+      [options,callback] = [null,options]
+    }
+    this.query(windowId ? {windowId} : {},tabs=>{
+      if(tabs && tabs.length){
+        for(let tab of tabs){
+          if(tab.active){
+            ipcFuncRenderer(this.constructor.name, 'captureVisibleTab',callback,tab.id,options)
+            return
+          }
+        }
+      }
+    })
+  }
+
+  insertCSS(tabId, details, callback){
+    if(!Number.isFinite(tabId)){
+      if(Object.prototype.toString.call(tabId)=="[object Object]"){
+        [tabId,details,callback] = [null,tabId,details]
+      }
+    }
+    ipcFuncRenderer('tabs', 'insertCSS',code=>{
+      this.executeScript(tabId,{code},callback)
+    },this._extensionId,tabId,details)
+  }
+
+  setZoom(tabId, zoomFactor, callback){
+    ipcFuncRenderer('tabs', 'setZoom', callback, tabId, zoomFactor)
+  }
+
+  getZoom(tabId, callback){
+    ipcFuncRenderer('tabs', 'getZoom', callback, tabId)
+  }
+
+  // setZoomSettings(tabId, zoomSettings, callback){} //@TODO NOOP
+  // getZoomSettings(tabId, callback){} //@TODO NOOP
+  // discard(tabId, callback){} //@TODO NOOP
+
+  connect(tabId, connectInfo){
+    const portId = ipcRenderer.sendSync('CHROME_TABS_CONNECT', tabId, this._extensionId, connectInfo, this._webContentsKey)
+    return new Port(tabId, portId, this.id, connectInfo.name)
+  }
+
+  saveAsPDF(pageSettings,callback){
+    ipcFuncRenderer('tabs', 'saveAsPDF', callback, pageSettings)
+  }
+
+  executeScript (tabId, details, callback) {
+    if (!Number.isFinite(tabId) && tabId !== null && tabId !== void 0) {
+      [tabId,details,callback] = [null,tabId,details]
+    }
+
+    const requestId = ++nextId
+    ipcRenderer.once(`CHROME_TABS_EXECUTESCRIPT_RESULT_${requestId}`, (event, result) => {
+      // Disabled due to false positive in StandardJS
+      // eslint-disable-next-line standard/no-callback-literal
+      if(callback) callback([result])
+    })
+    ipcRenderer.send('CHROME_TABS_EXECUTESCRIPT', requestId, tabId, this._extensionId, details)
+  }
+
+  sendMessage (tabId, message, options, responseCallback) {
+    if(typeof options == 'function'){
+      responseCallback = options
+    }
+    const originResultID = shortId()
+    let isResponsed
+    if (responseCallback) {
+      ipcRenderer.once(`CHROME_TABS_SEND_MESSAGE_RESULT_${originResultID}`, (event, result) => {
+        isResponsed = true
+        responseCallback(result)
+      })
+      setTimeout(()=>{
+        if(!isResponsed){
+          // console.error(`sendMessageTimeout`, message, options)
+          responseCallback(null)
+        }
+      },300)
+    }
+    ipcRenderer.send('CHROME_TABS_SEND_MESSAGE', tabId, this._extensionId, this._isBackgroundPage, message, originResultID, this._webContentsKey)
+  }
+}
+
+exports.setup = (...args) => {
+  return new Tabs(...args)
+}
diff --git a/lib/renderer/extensions/top-sites.js b/lib/renderer/extensions/top-sites.js
new file mode 100755
index 000000000..67e1f8fe5
--- /dev/null
+++ b/lib/renderer/extensions/top-sites.js
@@ -0,0 +1,9 @@
+const {simpleIpcFunc} = require('./util')
+
+exports.setup = ()=>{
+  return {
+    get(callback){
+      simpleIpcFunc('chrome-topSites-get',callback)
+    }
+  }
+}
diff --git a/lib/renderer/extensions/util.js b/lib/renderer/extensions/util.js
new file mode 100755
index 000000000..6f3100a8f
--- /dev/null
+++ b/lib/renderer/extensions/util.js
@@ -0,0 +1,43 @@
+const {ipcRenderer} = require('electron')
+const {getIpcNameFunc, _shortId} = require('./common-util')
+const deepEqual = require('./deep-equal')
+const shortId = _shortId()
+
+module.exports = {
+  getIpcNameFunc,
+  shortId,
+  ipcFuncRenderer(className,method,callback,...args){
+    const requestId = shortId()
+    const name = getIpcNameFunc(className)(method)
+    let success
+    const id = setTimeout(()=>{
+      success = true
+      console.log(`${name}_RESULT_ERROR_${requestId}`, {}, null)
+      if(callback) callback({})
+    },2000)
+
+    ipcRenderer.once(`${name}_RESULT_${requestId}`, (event,...results)=>{
+      if(success) return
+      clearTimeout(id)
+      console.log(`${name}_RESULT_${requestId}`, event,...results)
+      if(callback) callback(...results)
+    })
+    ipcRenderer.send(name, requestId, ...args)
+  },
+  simpleIpcFunc(name,callback,...args){
+    const key = shortId()
+    let success
+    const id = setTimeout(()=>{
+      success = true
+      console.log(`${name}-reply_ERROR_${key}`, {}, null)
+      if(callback) callback(null)
+    },2000)
+    ipcRenderer.once(`${name}-reply_${key}`,(event,...results)=>{
+      if(success) return
+      clearTimeout(id)
+      if(callback) callback(...results)
+    })
+    ipcRenderer.send(name,key,...args)
+  },
+  deepEqual
+}
diff --git a/lib/renderer/extensions/web-navigation.js b/lib/renderer/extensions/web-navigation.js
old mode 100644
new mode 100755
index 9c3f3f04e..050104364
--- a/lib/renderer/extensions/web-navigation.js
+++ b/lib/renderer/extensions/web-navigation.js
@@ -1,23 +1,34 @@
-'use strict'
-
-const Event = require('@electron/internal/renderer/extensions/event')
-const ipcRenderer = require('@electron/internal/renderer/ipc-renderer-internal')
+const {Event2} = require('./event')
+const {getIpcNameFunc, simpleIpcFunc} = require('./util')
+const {ipcRenderer} = require('electron')
 
 class WebNavigation {
-  constructor () {
-    this.onBeforeNavigate = new Event()
-    this.onCompleted = new Event()
+  constructor (extensionId) {
+    const getIpcName = getIpcNameFunc(this.constructor.name)
 
-    ipcRenderer.on('CHROME_WEBNAVIGATION_ONBEFORENAVIGATE', (event, details) => {
-      this.onBeforeNavigate.emit(details)
-    })
+    for(let method of ['onBeforeNavigate', 'onCompleted', 'onDOMContentLoaded', 'onCommitted', 'onErrorOccurred', 'onCreatedNavigationTarget']){
+      this[method] = new Event2(this.constructor.name, method, extensionId)
+    }
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
 
-    ipcRenderer.on('CHROME_WEBNAVIGATION_ONCOMPLETED', (event, details) => {
-      this.onCompleted.emit(details)
+  getFrame(details, callback){
+    this.getAllFrames(details, (results) =>{
+      for(let result of results){
+        if(details.frameId == result.frameId && (!details.processId || details.processId == result.processId)){
+          callback(result)
+          return
+        }
+      }
     })
   }
+
+  getAllFrames(details, callback){
+    simpleIpcFunc('chrome-webNavigation-getAllFrames',callback,details)
+  }
 }
 
-exports.setup = () => {
-  return new WebNavigation()
+exports.setup = (...args) => {
+  return new WebNavigation(...args)
 }
diff --git a/lib/renderer/extensions/web-request.js b/lib/renderer/extensions/web-request.js
new file mode 100755
index 000000000..9ea21088e
--- /dev/null
+++ b/lib/renderer/extensions/web-request.js
@@ -0,0 +1,27 @@
+const {Event2} = require('./event')
+const {getIpcNameFunc} = require('./util')
+const {ipcRenderer} = require('electron')
+
+class WebRequest {
+  constructor (extensionId) {
+    const getIpcName = getIpcNameFunc(this.constructor.name)
+
+    for(let method of [
+      'onAuthRequired',
+      'onBeforeRedirect',
+      'onBeforeRequest',
+      'onBeforeSendHeaders',
+      'onCompleted',
+      'onErrorOccurred',
+      'onHeadersReceived',
+      'onResponseStarted',
+      'onSendHeaders'
+    ]){
+      this[method] = new Event2(this.constructor.name, method, extensionId, true)
+    }
+ }
+}
+
+exports.setup = (...args) => {
+  return new WebRequest(...args)
+}
diff --git a/lib/renderer/extensions/window.js b/lib/renderer/extensions/window.js
new file mode 100755
index 000000000..9a251380e
--- /dev/null
+++ b/lib/renderer/extensions/window.js
@@ -0,0 +1,17 @@
+const {ipcRenderer} = require('electron')
+
+module.exports= function(win, populateTabs){
+  const bounds = win.getBounds()
+  return {
+    // create psuedo-windows to handle this
+    incognito: false, // TODO(bridiver)
+    id: win.id,
+    focused: win.isFocused(),
+    top: bounds.y,
+    left: bounds.x,
+    width: bounds.width,
+    height: bounds.height,
+    alwaysOnTop: win.isAlwaysOnTop(),
+    tabs: populateTabs ? getTabsForWindow(win.id) : null
+  }
+}
\ No newline at end of file
diff --git a/lib/renderer/extensions/windows.js b/lib/renderer/extensions/windows.js
new file mode 100755
index 000000000..81606d048
--- /dev/null
+++ b/lib/renderer/extensions/windows.js
@@ -0,0 +1,110 @@
+const {Event} = require('./event')
+const {getIpcNameFunc, ipcFuncRenderer, shortId, simpleIpcFunc, deepEqual} = require('./util')
+const {ipcRenderer} = require('electron')
+const Window = require('./window')
+
+
+const convertUrlMap = {
+  'chrome://bookmarks/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/favorite.html',
+  'chrome://history/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/history.html',
+  'about:blank': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/blank.html',
+  'chrome://bookmarks-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/favorite_sidebar.html',
+  'chrome://tab-history-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/tab_history_sidebar.html',
+  'chrome://tab-trash-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/tab_trash_sidebar.html',
+  'chrome://download-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/download_sidebar.html',
+  'chrome://note-sidebar/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/note_sidebar.html',
+  'chrome://note/':'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/note.html',
+  'chrome://session-manager-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/saved_state_sidebar.html',
+  'chrome://history-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/history_sidebar.html',
+  'chrome://explorer/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/explorer.html',
+  'chrome://explorer-sidebar/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/explorer_sidebar.html',
+  'chrome://download/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/download.html',
+  'chrome://terminal/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/terminal.html',
+  'chrome://converter/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/converter.html',
+  'chrome://automation/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/automation.html',
+  'chrome://settings/': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html',
+  'chrome://settings#general': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#general',
+  'chrome://settings#search': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#search',
+  'chrome://settings#tabs': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#tabs',
+  'chrome://settings#keyboard': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#keyboard',
+  'chrome://settings#extensions': 'chrome-extension://dckpbojndfoinamcdamhkjhnjnmjkfjd/settings.html#extensions',
+}
+
+class Windows {
+  constructor (extensionId) {
+    this._extensionId = extensionId
+
+    this.initEvents()
+
+    for(let name of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) this[name] = name == 'constructor' ? this[name] : this[name].bind(this)
+  }
+
+  initEvents(){
+    for(let event of ['onCreated', 'onRemoved', 'onFocusChanged']){
+      this[event] = new Event()
+    }
+
+    ipcRenderer.on('CHROME_WINDOWS_ONCREATED', (event, window) => {
+      this.onCreated.emit(window)
+    })
+    ipcRenderer.on('CHROME_WINDOWS_ONREMOVED', (event, windowId) => {
+      this.onRemoved.emit(windowId)
+    })
+    ipcRenderer.on('CHROME_WINDOWS_ONFOCUSCHANGED', (event, windowId) => {
+      this.onFocusChanged.emit(windowId)
+    })
+  }
+
+  get(windowId, getInfo, callback){
+    if(typeof getInfo === 'function') [getInfo,callback] = [null,getInfo]
+    ipcFuncRenderer(this.constructor.name, 'get', callback, windowId, getInfo)
+  }
+
+  getCurrent(getInfo, callback){
+    if(typeof getInfo === 'function') [getInfo,callback] = [null,getInfo]
+    ipcFuncRenderer(this.constructor.name, 'getCurrent', callback, getInfo)
+  }
+
+  getLastFocused(getInfo, callback){
+    ipcFuncRenderer(this.constructor.name, 'getLastFocused', (windowId)=>{
+      this.get(windowId, getInfo, callback)
+    })
+  }
+
+  getAll(getInfo, callback){
+    if(typeof getInfo === 'function') [getInfo,callback] = [null,getInfo]
+    getInfo = getInfo || {}
+
+    ipcFuncRenderer(this.constructor.name, 'getAll', callback, getInfo)
+  }
+
+  create(createData, callback){
+    if (typeof createData === 'function') [createData, callback] = [null, createData]
+    console.log(2224, createData)
+    if (createData && createData.url){
+      if (!createData.url.includes("://")) {
+        createData.url = `chrome-extension://${this._extensionId}/${createData.url.split("/").filter(x => x).join("/")}`
+      }
+      createData.url = convertUrlMap[createData.url] || createData.url
+    }
+    ipcFuncRenderer(this.constructor.name, 'create', callback, createData)
+  }
+
+  update(windowId, updateInfo, callback){
+    ipcFuncRenderer(this.constructor.name, 'update', callback, windowId, updateInfo)
+
+  }
+
+  remove(windowId, callback){
+    ipcFuncRenderer(this.constructor.name, 'remove', callback, windowId)
+  }
+
+  hostClose(){
+    ipcRenderer.send('send-to-host', 'window-close', {})
+  }
+
+}
+
+exports.setup = (...args) => {
+  return new Windows(...args)
+}
diff --git a/lib/renderer/init.js b/lib/renderer/init.js
old mode 100644
new mode 100755
index c65c6066b..c50cbb6c9
--- a/lib/renderer/init.js
+++ b/lib/renderer/init.js
@@ -37,6 +37,7 @@ let preloadScript = null
 let preloadScripts = []
 let isBackgroundPage = false
 let appPath = null
+console.log(process.argv)
 for (const arg of process.argv) {
   if (arg.indexOf('--guest-instance-id=') === 0) {
     // This is a guest web view.
@@ -70,7 +71,8 @@ if (window.location.protocol === 'chrome-devtools:') {
   nodeIntegration = false
 } else if (window.location.protocol === 'chrome-extension:') {
   // Add implementations of chrome API.
-  require('@electron/internal/renderer/chrome-api').injectTo(window.location.hostname, isBackgroundPage, window)
+  require('@electron/internal/renderer/chrome-api').injectTo(window.location.hostname, isBackgroundPage, true, window)
+  if(!isBackgroundPage) require('@electron/internal/renderer/content-scripts-injector')(true)
   nodeIntegration = false
 } else if (window.location.protocol === 'chrome:') {
   // Disable node integration for chrome UI scheme.
@@ -79,8 +81,10 @@ if (window.location.protocol === 'chrome-devtools:') {
   // Override default web functions.
   require('@electron/internal/renderer/override')
 
-  // Inject content scripts.
-  require('@electron/internal/renderer/content-scripts-injector')
+  if(!nodeIntegration){
+    // Inject content scripts.
+    require('@electron/internal/renderer/content-scripts-injector')(false)
+  }
 
   // Load webview tag implementation.
   if (webviewTag && process.guestInstanceId == null) {
diff --git a/lib/renderer/security-warnings.js b/lib/renderer/security-warnings.js
old mode 100644
new mode 100755
index 9d68ee0f2..c5b9b96bc
--- a/lib/renderer/security-warnings.js
+++ b/lib/renderer/security-warnings.js
@@ -24,10 +24,10 @@ const shouldLogSecurityWarnings = function () {
       break
     case 'freebsd':
     case 'linux':
-      shouldLog = execPath.endsWith('/electron')
+      shouldLog = execPath && execPath.endsWith('/electron')
       break
     case 'win32':
-      shouldLog = execPath.endsWith('\\electron.exe')
+      shouldLog = execPath && execPath.endsWith('\\electron.exe')
       break
     default:
       shouldLog = false
diff --git a/lib/sandboxed_renderer/api/module-list.js b/lib/sandboxed_renderer/api/module-list.js
index 9831fdfa2..39dd8c6e4 100644
--- a/lib/sandboxed_renderer/api/module-list.js
+++ b/lib/sandboxed_renderer/api/module-list.js
@@ -9,8 +9,8 @@ module.exports = [
   },
   {
     name: 'desktopCapturer',
-    load: () => require('@electron/internal/renderer/api/desktop-capturer'),
-    enabled: features.isDesktopCapturerEnabled()
+    load: () => require('@electron/internal/renderer/api/desktop-capturer')
+    // enabled: features.isDesktopCapturerEnabled()
   },
   {
     name: 'ipcRenderer',
diff --git a/lib/sandboxed_renderer/init.js b/lib/sandboxed_renderer/init.js
index 0512cf535..a16128fcd 100644
--- a/lib/sandboxed_renderer/init.js
+++ b/lib/sandboxed_renderer/init.js
@@ -111,8 +111,8 @@ switch (window.location.protocol) {
   }
   case 'chrome-extension:': {
     // Inject the chrome.* APIs that chrome extensions require
-    const isBackgroundPage = preloadProcess.argv.includes('--background-page')
-    require('@electron/internal/renderer/chrome-api').injectTo(window.location.hostname, isBackgroundPage, window)
+    require('@electron/internal/renderer/chrome-api').injectTo(window.location.hostname, false, true, window)
+    // require('@electron/internal/renderer/content-scripts-injector')(true)
     break
   }
 }
