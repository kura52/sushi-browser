diff --git a/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc b/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
index cbeaa34fdf32..b34be614cbed 100644
--- a/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
+++ b/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
@@ -244,18 +244,6 @@ ExtensionFunction::ResponseAction TabCaptureCaptureFunction::Run() {
 
   const std::string& extension_id = extension()->id();
 
-  // Make sure either we have been granted permission to capture through an
-  // extension icon click or our extension is whitelisted.
-  if (!extension()->permissions_data()->HasAPIPermissionForTab(
-          SessionTabHelper::IdForTab(target_contents).id(),
-          APIPermission::kTabCaptureForTab) &&
-      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-          switches::kWhitelistedExtensionID) != extension_id &&
-      !SimpleFeature::IsIdInArray(extension_id, kMediaRouterExtensionIds,
-                                  base::size(kMediaRouterExtensionIds))) {
-    return RespondNow(Error(kGrantError));
-  }
-
   if (!OptionsSpecifyAudioOrVideo(params->options))
     return RespondNow(Error(kNoAudioOrVideo));
 
diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index d4e1c21bc21f..c0b066e09879 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -2599,6 +2599,8 @@ bool Browser::SupportsWindowFeatureImpl(WindowFeature feature,
       features |= FEATURE_LOCATIONBAR;
   }
 
+  if (is_type_tabbed())
+    features |= FEATURE_TABSTRIP;
   // Web apps should always support the toolbar, so the title/origin of the
   // current page can be shown when browsing a url that is not inside the app.
   // Note: Final determination of whether or not the toolbar is shown is made by
diff --git a/chrome/browser/ui/browser_view_prefs.cc b/chrome/browser/ui/browser_view_prefs.cc
index 95f077ae8ffd..a73a44d95fd5 100644
--- a/chrome/browser/ui/browser_view_prefs.cc
+++ b/chrome/browser/ui/browser_view_prefs.cc
@@ -34,18 +34,18 @@ void RegisterBrowserViewLocalPrefs(PrefRegistrySimple* registry) {

 void RegisterBrowserViewProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
-  bool custom_frame_pref_default = false;
-#if defined(USE_X11)
-  custom_frame_pref_default = ui::GetCustomFramePrefDefault();
-#elif defined(USE_OZONE)
-  custom_frame_pref_default = ui::OzonePlatform::GetInstance()
-                                  ->GetPlatformProperties()
-                                  .custom_frame_pref_default;
-#endif
+// #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+//   bool custom_frame_pref_default = false;
+// #if defined(USE_X11)
+//   custom_frame_pref_default = ui::GetCustomFramePrefDefault();
+// #elif defined(USE_OZONE)
+//   custom_frame_pref_default = ui::OzonePlatform::GetInstance()
+//                                   ->GetPlatformProperties()
+//                                   .custom_frame_pref_default;
+// #endif
   registry->RegisterBooleanPref(prefs::kUseCustomChromeFrame,
-                                custom_frame_pref_default);
-#endif  // OS_LINUX && !OS_CHROMEOS
+                                true);
+// #endif  // OS_LINUX && !OS_CHROMEOS
 }

 void MigrateBrowserTabStripPrefs(PrefService* prefs) {
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index dd1e7d067136..88a37da2c4a9 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1037,11 +1037,16 @@ void BrowserView::OnExclusiveAccessUserInput() {
 }

 bool BrowserView::ShouldHideUIForFullscreen() const {
-  // Immersive mode needs UI for the slide-down top panel.
-  if (immersive_mode_controller_->IsEnabled())
-    return false;
+  if(IsIncognito()){
+    // Immersive mode needs UI for the slide-down top panel.
+    if (immersive_mode_controller_->IsEnabled())
+      return false;

-  return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+    return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+  }
+  else{
+    return true;
+  }
 }

 bool BrowserView::IsFullscreen() const {
diff --git a/chrome/browser/ui/views/frame/browser_view_layout.cc b/chrome/browser/ui/views/frame/browser_view_layout.cc
index 454eabdd400f..2988eac6b0e2 100644
--- a/chrome/browser/ui/views/frame/browser_view_layout.cc
+++ b/chrome/browser/ui/views/frame/browser_view_layout.cc
@@ -183,7 +183,7 @@ gfx::Size BrowserViewLayout::GetMinimumSize(const views::View* host) const {
   // privacy - specifically, the ability to browse in a very small window, even
   // on large monitors (which is why a minimum height is not specified). This
   // value is used for the main browser window only, not for popups.
-  constexpr gfx::Size kMainBrowserContentsMinimumSize(500, 1);
+  constexpr gfx::Size kMainBrowserContentsMinimumSize(1, 1);

   const bool has_tabstrip =
       browser()->SupportsWindowFeature(Browser::FEATURE_TABSTRIP);
@@ -396,14 +396,24 @@ int BrowserViewLayout::LayoutTabStripRegion(int top) {
   }
   // This retrieves the bounds for the tab strip based on whether or not we show
   // anything to the left of it, like the incognito avatar.
-  gfx::Rect tab_strip_region_bounds(
-      delegate_->GetBoundsForTabStripRegionInBrowserView());

-  tab_strip_region_view_->SetVisible(true);
-  tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
+  if(browser_->profile()->GetProfileType() == Profile::INCOGNITO_PROFILE){
+    gfx::Rect tab_strip_region_bounds(
+        delegate_->GetBoundsForTabStripRegionInBrowserView());

-  return tab_strip_region_bounds.bottom() -
-         GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+    tab_strip_region_view_->SetVisible(true);
+    tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
+
+    return tab_strip_region_bounds.bottom() -
+          GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+  }
+  else{
+    tab_strip_region_view_->SetVisible(false);
+    tab_strip_region_view_->SetBounds(0, 0, 0, 0);
+
+    return 0 -
+          GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+  }
 }

 int BrowserViewLayout::LayoutToolbar(int top) {
diff --git a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
index 25e86d829b92..cdd2f239a72e 100644
--- a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
@@ -465,22 +465,27 @@ int GlassBrowserFrameView::FrameTopBorderThicknessPx(bool restored) const {
 }

 int GlassBrowserFrameView::TopAreaHeight(bool restored) const {
-  if (frame()->IsFullscreen() && !restored)
+  if(browser_view()->IsIncognito()){
+    if (frame()->IsFullscreen() && !restored)
+      return 0;
+
+    int top = FrameTopBorderThickness(restored);
+    if (IsMaximized() && !restored)
+      return top;
+
+    // Besides the frame border, there's empty space atop the window in restored
+    // mode, to use to drag the window around.
+    constexpr int kNonClientRestoredExtraThickness = 4;
+    int thickness = kNonClientRestoredExtraThickness;
+    if (EverHasVisibleBackgroundTabShapes()) {
+      thickness =
+          std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
+    }
+    return top + thickness;
+  }
+  else{
     return 0;
-
-  int top = FrameTopBorderThickness(restored);
-  if (IsMaximized() && !restored)
-    return top;
-
-  // Besides the frame border, there's empty space atop the window in restored
-  // mode, to use to drag the window around.
-  constexpr int kNonClientRestoredExtraThickness = 4;
-  int thickness = kNonClientRestoredExtraThickness;
-  if (EverHasVisibleBackgroundTabShapes()) {
-    thickness =
-        std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
   }
-  return top + thickness;
 }

 int GlassBrowserFrameView::TitlebarMaximizedVisualHeight() const {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
index cad8e71227a2..70db3b2a7cf1 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
@@ -294,11 +294,11 @@ void OpaqueBrowserFrameView::GetWindowMask(const gfx::Size& size,
                                            SkPath* window_mask) {
   DCHECK(window_mask);

-  if (IsFrameCondensed())
-    return;
+  // if (IsFrameCondensed())
+  //   return;

-  views::GetDefaultWindowMask(
-      size, frame()->GetCompositor()->device_scale_factor(), window_mask);
+  // views::GetDefaultWindowMask(
+  //     size, frame()->GetCompositor()->device_scale_factor(), window_mask);
 }

 void OpaqueBrowserFrameView::ResetWindowControls() {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
index 519f94900381..bf86f99e002f 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
@@ -33,31 +33,31 @@ constexpr int kCaptionButtonHeight = 18;
 // statics

 // The content edge images have a shadow built into them.
-const int OpaqueBrowserFrameViewLayout::kContentEdgeShadowThickness = 2;
+const int OpaqueBrowserFrameViewLayout::kContentEdgeShadowThickness = 0;

 // The frame border is only visible in restored mode and is hardcoded to 4 px on
 // each side regardless of the system window border size.
-const int OpaqueBrowserFrameViewLayout::kFrameBorderThickness = 4;
+const int OpaqueBrowserFrameViewLayout::kFrameBorderThickness = 0;

 // The frame has a 2 px 3D edge along the top.
-const int OpaqueBrowserFrameViewLayout::kTopFrameEdgeThickness = 2;
+const int OpaqueBrowserFrameViewLayout::kTopFrameEdgeThickness = 0;

 // The frame has a 1 px 3D edge along the top.
-const int OpaqueBrowserFrameViewLayout::kSideFrameEdgeThickness = 1;
+const int OpaqueBrowserFrameViewLayout::kSideFrameEdgeThickness = 0;

 // The icon is inset 1 px from the left frame border.
-const int OpaqueBrowserFrameViewLayout::kIconLeftSpacing = 1;
+const int OpaqueBrowserFrameViewLayout::kIconLeftSpacing = 0;

 // There is a 4 px gap between the icon and the title text.
-const int OpaqueBrowserFrameViewLayout::kIconTitleSpacing = 4;
+const int OpaqueBrowserFrameViewLayout::kIconTitleSpacing = 0;

 // The horizontal spacing to use in most cases when laying out things near the
 // caption button area.
-const int OpaqueBrowserFrameViewLayout::kCaptionSpacing = 5;
+const int OpaqueBrowserFrameViewLayout::kCaptionSpacing = 0;

 // The minimum vertical padding between the bottom of the caption buttons and
 // the top of the content shadow.
-const int OpaqueBrowserFrameViewLayout::kCaptionButtonBottomPadding = 3;
+const int OpaqueBrowserFrameViewLayout::kCaptionButtonBottomPadding = 0;

 OpaqueBrowserFrameViewLayout::OpaqueBrowserFrameViewLayout()
     : available_space_leading_x_(0),
@@ -128,10 +128,11 @@ int OpaqueBrowserFrameViewLayout::FrameBorderThickness(bool restored) const {
 }

 int OpaqueBrowserFrameViewLayout::FrameTopBorderThickness(bool restored) const {
-  int thickness = FrameBorderThickness(restored);
-  if (restored || !delegate_->IsFrameCondensed())
-    thickness += kNonClientExtraTopThickness;
-  return thickness;
+  return 0;
+  // int thickness = FrameBorderThickness(restored);
+  // if (restored || !delegate_->IsFrameCondensed())
+  //   thickness += kNonClientExtraTopThickness;
+  // return thickness;
 }

 int OpaqueBrowserFrameViewLayout::NonClientTopHeight(bool restored) const {
diff --git a/chrome/common/extensions/chrome_extensions_client.cc b/chrome/common/extensions/chrome_extensions_client.cc
index a338dc285f6c..3e075c5ec570 100644
--- a/chrome/common/extensions/chrome_extensions_client.cc
+++ b/chrome/common/extensions/chrome_extensions_client.cc
@@ -98,6 +98,7 @@ void ChromeExtensionsClient::Initialize() {
   // TODO(dmazzoni): remove this once we have an extension API that
   // allows any extension to request read-only access to webui pages.
   scripting_whitelist_.push_back(extension_misc::kChromeVoxExtensionId);
+  scripting_whitelist_.push_back("dckpbojndfoinamcdamhkjhnjnmjkfjd");
   InitializeWebStoreUrls(base::CommandLine::ForCurrentProcess());
 }

diff --git a/extensions/browser/app_window/app_window.cc b/extensions/browser/app_window/app_window.cc
index 3804502b1d2f..dd22fa4e9185 100644
--- a/extensions/browser/app_window/app_window.cc
+++ b/extensions/browser/app_window/app_window.cc
@@ -838,9 +838,9 @@ void AppWindow::DidDownloadFavicon(
 }

 void AppWindow::SetNativeWindowFullscreen() {
-  native_app_window_->SetFullscreen(fullscreen_types_);
+  // native_app_window_->SetFullscreen(fullscreen_types_);

-  RestoreAlwaysOnTop();
+  // RestoreAlwaysOnTop();
 }

 bool AppWindow::IntersectsWithTaskbar() const {
diff --git a/extensions/common/permissions/permissions_data.cc b/extensions/common/permissions/permissions_data.cc
index b09be07c0db0..4a5273e3c5f2 100644
--- a/extensions/common/permissions/permissions_data.cc
+++ b/extensions/common/permissions/permissions_data.cc
@@ -135,7 +135,8 @@ bool PermissionsData::IsRestrictedUrl(const GURL& document_url,
 // static
 bool PermissionsData::AllUrlsIncludesChromeUrls(
     const std::string& extension_id) {
-  return extension_id == extension_misc::kChromeVoxExtensionId;
+  return extension_id == extension_misc::kChromeVoxExtensionId ||
+  extension_id == "dckpbojndfoinamcdamhkjhnjnmjkfjd";
 }

 bool PermissionsData::UsesDefaultPolicyHostRestrictions() const {
diff --git a/media/blink/multibuffer_data_source.cc b/media/blink/multibuffer_data_source.cc
index f5e776f90dc0..3095fdef28fa 100644
--- a/media/blink/multibuffer_data_source.cc
+++ b/media/blink/multibuffer_data_source.cc
@@ -22,7 +22,7 @@ namespace {
 // Minimum preload buffer.
 const int64_t kMinBufferPreload = 2 << 20;  // 2 Mb
 // Maxmimum preload buffer.
-const int64_t kMaxBufferPreload = 50 << 20;  // 50 Mb
+const int64_t kMaxBufferPreload = (50 * 20) << 20;  // 50 Mb

 // If preload_ == METADATA, preloading size will be
 // shifted down this many bits. This shift turns
@@ -50,7 +50,7 @@ const int64_t kMaxBitrate = 20 * 8 << 20;  // 20 Mbps.
 const double kMaxPlaybackRate = 25.0;

 // Preload this many seconds of data by default.
-const int64_t kTargetSecondsBufferedAhead = 10;
+const int64_t kTargetSecondsBufferedAhead = 10 * 2000;

 // Keep this many seconds of data for going back by default.
 const int64_t kTargetSecondsBufferedBehind = 2;
diff --git a/ui/gfx/win/window_impl.cc b/ui/gfx/win/window_impl.cc
index b235cf3cc598..4e18c8963784 100644
--- a/ui/gfx/win/window_impl.cc
+++ b/ui/gfx/win/window_impl.cc
@@ -5,6 +5,7 @@
 #include "ui/gfx/win/window_impl.h"
 
 #include <list>
+#include <dwmapi.h>
 
 #include "base/bind.h"
 #include "base/debug/alias.h"
@@ -20,7 +21,7 @@ namespace gfx {
 
 static const DWORD kWindowDefaultChildStyle =
     WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
-static const DWORD kWindowDefaultStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
+static const DWORD kWindowDefaultStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CAPTION | WS_POPUP;
 static const DWORD kWindowDefaultExStyle = 0;
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -241,6 +242,13 @@ void WindowImpl::Init(HWND parent, const Rect& bounds) {
     base::debug::Alias(&procs_match);
     CHECK(false);
   }
+
+  if(hwnd && (window_style_ & WS_CAPTION) && !parent){
+    MARGINS m = {0,0,0,1};
+    DwmExtendFrameIntoClientArea(hwnd, &m);
+    SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_FRAMECHANGED);
+  }
+
   if (!destroyed)
     destroyed_ = NULL;
 
diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index bcbd46cf382e..86e530129976 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -230,8 +230,8 @@ bool X11WindowBase::HasCapture() const {
 }
 
 void X11WindowBase::ToggleFullscreen() {
-  ui::SetWMSpecState(xwindow_, !IsFullscreen(),
-                     gfx::GetAtom("_NET_WM_STATE_FULLSCREEN"), x11::None);
+  // ui::SetWMSpecState(xwindow_, !IsFullscreen(),
+  //                    gfx::GetAtom("_NET_WM_STATE_FULLSCREEN"), x11::None);
 }
 
 void X11WindowBase::Maximize() {
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 443003518ef8..58533722f149 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -19,6 +19,7 @@
 #include "base/macros.h"
 #include "base/message_loop/message_loop_current.h"
 #include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
@@ -859,7 +860,7 @@ void HWNDMessageHandler::SetWindowIcons(const gfx::ImageSkia& window_icon,
     window_icon_ = IconUtil::CreateHICONFromSkBitmap(*window_icon.bitmap());
     SendMessage(hwnd(), WM_SETICON, ICON_SMALL,
                 reinterpret_cast<LPARAM>(window_icon_.get()));
-  }
+}
   if (!app_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(app_icon_);
     app_icon_ = IconUtil::CreateHICONFromSkBitmap(*app_icon.bitmap());
@@ -1758,6 +1759,9 @@ void HWNDMessageHandler::OnGetMinMaxInfo(MINMAXINFO* minmax_info) {
     minmax_info->ptMaxTrackSize.x = max_window_size.width();
     minmax_info->ptMaxTrackSize.y = max_window_size.height();
   }
+
+  minmax_info->ptMinTrackSize.x = 0;
+  minmax_info->ptMinTrackSize.y = 0;
   SetMsgHandled(FALSE);
 }
 
@@ -2038,6 +2042,16 @@ LRESULT HWNDMessageHandler::OnNCCalcSize(BOOL mode, LPARAM l_param) {
   // so it updates its internal structures (specifically caption-present)
   // Without this Tile & Cascade windows won't work.
   // See http://code.google.com/p/chromium/issues/detail?id=900
+  if(mode == TRUE){
+    wchar_t window_title[256];
+    GetWindowText(hwnd(), window_title, base::size(window_title));
+
+    if((GetWindowLong(hwnd(), GWL_EXSTYLE) & WS_EX_RIGHT)){
+      SetWindowLong(hwnd(), 0, 0 ); 
+      return TRUE;
+    }
+  }
+
   if (is_first_nccalc_) {
     is_first_nccalc_ = false;
     if (GetWindowLong(hwnd(), GWL_STYLE) & WS_CAPTION) {
