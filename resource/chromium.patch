diff --git a/chrome/browser/extensions/api/extension_action/extension_action_api.cc b/chrome/browser/extensions/api/extension_action/extension_action_api.cc
index ef0c3b6b9281..25fd967f1d09 100644
--- a/chrome/browser/extensions/api/extension_action/extension_action_api.cc
+++ b/chrome/browser/extensions/api/extension_action/extension_action_api.cc
@@ -147,8 +147,8 @@ bool ExtensionActionAPI::ShowExtensionActionPopup(
     return false;

   // Don't support showing action popups in a popup window.
-  if (!browser->SupportsWindowFeature(Browser::FEATURE_TOOLBAR))
-    return false;
+  // if (!browser->SupportsWindowFeature(Browser::FEATURE_TOOLBAR))
+  //   return false;

   ToolbarActionsBar* toolbar_actions_bar =
       browser->window()->GetToolbarActionsBar();
@@ -530,8 +530,11 @@ ExtensionFunction::ResponseAction BrowserActionOpenPopupFunction::Run() {
   // Otherwise, try to open a popup in the active browser.
   // TODO(justinlin): Remove toolbar check when http://crbug.com/308645 is
   // fixed.
-  if (!browser || !browser->window()->IsActive() ||
-      !browser->window()->IsToolbarVisible() ||
+  if (
+    !browser
+    // || !browser->window()->IsActive()
+     ||
+      // !browser->window()->IsToolbarVisible() ||
       !ExtensionActionAPI::Get(profile)->ShowExtensionActionPopup(
           extension_.get(), browser, false)) {
     return RespondNow(Error(kOpenPopupError));
diff --git a/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc b/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
index cbeaa34fdf32..b34be614cbed 100644
--- a/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
+++ b/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
@@ -244,18 +244,6 @@ ExtensionFunction::ResponseAction TabCaptureCaptureFunction::Run() {

   const std::string& extension_id = extension()->id();

-  // Make sure either we have been granted permission to capture through an
-  // extension icon click or our extension is whitelisted.
-  if (!extension()->permissions_data()->HasAPIPermissionForTab(
-          SessionTabHelper::IdForTab(target_contents).id(),
-          APIPermission::kTabCaptureForTab) &&
-      base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-          switches::kWhitelistedExtensionID) != extension_id &&
-      !SimpleFeature::IsIdInArray(extension_id, kMediaRouterExtensionIds,
-                                  base::size(kMediaRouterExtensionIds))) {
-    return RespondNow(Error(kGrantError));
-  }
-
   if (!OptionsSpecifyAudioOrVideo(params->options))
     return RespondNow(Error(kNoAudioOrVideo));

diff --git a/chrome/browser/ui/browser.cc b/chrome/browser/ui/browser.cc
index 09d09139a5b6..2a7c9636eee1 100644
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -2646,6 +2646,8 @@ bool Browser::SupportsWindowFeatureImpl(WindowFeature feature,
       features |= FEATURE_LOCATIONBAR;
   }

+  if (is_type_tabbed())
+    features |= FEATURE_TABSTRIP;
   // Web apps should always support the toolbar, so the title/origin of the
   // current page can be shown when browsing a url that is not inside the app.
   // Note: Final determination of whether or not the toolbar is shown is made by
diff --git a/chrome/browser/ui/browser_view_prefs.cc b/chrome/browser/ui/browser_view_prefs.cc
index 95f077ae8ffd..0fa556219d1c 100644
--- a/chrome/browser/ui/browser_view_prefs.cc
+++ b/chrome/browser/ui/browser_view_prefs.cc
@@ -35,16 +35,16 @@ void RegisterBrowserViewLocalPrefs(PrefRegistrySimple* registry) {
 void RegisterBrowserViewProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
-  bool custom_frame_pref_default = false;
-#if defined(USE_X11)
-  custom_frame_pref_default = ui::GetCustomFramePrefDefault();
-#elif defined(USE_OZONE)
-  custom_frame_pref_default = ui::OzonePlatform::GetInstance()
-                                  ->GetPlatformProperties()
-                                  .custom_frame_pref_default;
-#endif
+//   bool custom_frame_pref_default = false;
+// #if defined(USE_X11)
+//   custom_frame_pref_default = ui::GetCustomFramePrefDefault();
+// #elif defined(USE_OZONE)
+//   custom_frame_pref_default = ui::OzonePlatform::GetInstance()
+//                                   ->GetPlatformProperties()
+//                                   .custom_frame_pref_default;
+// #endif
   registry->RegisterBooleanPref(prefs::kUseCustomChromeFrame,
-                                custom_frame_pref_default);
+                                true);
 #endif  // OS_LINUX && !OS_CHROMEOS
 }

diff --git a/chrome/browser/ui/toolbar/toolbar_actions_bar.cc b/chrome/browser/ui/toolbar/toolbar_actions_bar.cc
index ed2241bacb8d..9aac0a304880 100644
--- a/chrome/browser/ui/toolbar/toolbar_actions_bar.cc
+++ b/chrome/browser/ui/toolbar/toolbar_actions_bar.cc
@@ -381,7 +381,9 @@ void ToolbarActionsBar::Update() {
 bool ToolbarActionsBar::ShowToolbarActionPopup(const std::string& action_id,
                                                bool grant_active_tab) {
   // Don't override another popup, and only show in the active window.
-  if (popup_owner() || !browser_->window()->IsActive())
+  if (popup_owner()
+  // || !browser_->window()->IsActive()
+  )
     return false;

   ToolbarActionViewController* action = GetActionForId(action_id);
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index 2a939d6ac6b1..a1d9e6dad478 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1057,11 +1057,16 @@ void BrowserView::OnExclusiveAccessUserInput() {
 }

 bool BrowserView::ShouldHideUIForFullscreen() const {
-  // Immersive mode needs UI for the slide-down top panel.
-  if (immersive_mode_controller_->IsEnabled())
-    return false;
+  if(IsIncognito()){
+    // Immersive mode needs UI for the slide-down top panel.
+    if (immersive_mode_controller_->IsEnabled())
+      return false;

-  return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+    return frame_->GetFrameView()->ShouldHideTopUIForFullscreen();
+  }
+  else{
+    return true;
+  }
 }

 bool BrowserView::IsFullscreen() const {
diff --git a/chrome/browser/ui/views/frame/browser_view_layout.cc b/chrome/browser/ui/views/frame/browser_view_layout.cc
index 78f3db28ca51..361d278b6f39 100644
--- a/chrome/browser/ui/views/frame/browser_view_layout.cc
+++ b/chrome/browser/ui/views/frame/browser_view_layout.cc
@@ -169,7 +169,7 @@ gfx::Size BrowserViewLayout::GetMinimumSize(const views::View* host) const {
   // privacy - specifically, the ability to browse in a very small window, even
   // on large monitors (which is why a minimum height is not specified). This
   // value is used for the main browser window only, not for popups.
-  constexpr gfx::Size kMainBrowserContentsMinimumSize(500, 1);
+  constexpr gfx::Size kMainBrowserContentsMinimumSize(1, 1);

   const bool has_tabstrip =
       browser()->SupportsWindowFeature(Browser::FEATURE_TABSTRIP);
@@ -390,14 +390,24 @@ int BrowserViewLayout::LayoutTabStripRegion(int top) {
   }
   // This retrieves the bounds for the tab strip based on whether or not we show
   // anything to the left of it, like the incognito avatar.
-  gfx::Rect tab_strip_region_bounds(
-      delegate_->GetBoundsForTabStripRegionInBrowserView());

-  tab_strip_region_view_->SetVisible(true);
-  tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
+  if(browser_->profile()->IsIncognitoProfile()){
+    gfx::Rect tab_strip_region_bounds(
+        delegate_->GetBoundsForTabStripRegionInBrowserView());

-  return tab_strip_region_bounds.bottom() -
-         GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+    tab_strip_region_view_->SetVisible(true);
+    tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
+
+    return tab_strip_region_bounds.bottom() -
+          GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+  }
+  else{
+    tab_strip_region_view_->SetVisible(false);
+    tab_strip_region_view_->SetBounds(0, 0, 0, 0);
+
+    return 0 -
+          GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+  }
 }

 int BrowserViewLayout::LayoutToolbar(int top) {
diff --git a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
index 5fcb6a252e5a..02dc3dcd2bd5 100644
--- a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
@@ -471,22 +471,27 @@ int GlassBrowserFrameView::FrameTopBorderThicknessPx(bool restored) const {
 }

 int GlassBrowserFrameView::TopAreaHeight(bool restored) const {
-  if (frame()->IsFullscreen() && !restored)
+  if(browser_view()->IsIncognito()){
+    if (frame()->IsFullscreen() && !restored)
+      return 0;
+
+    int top = FrameTopBorderThickness(restored);
+    if (IsMaximized() && !restored)
+      return top;
+
+    // Besides the frame border, there's empty space atop the window in restored
+    // mode, to use to drag the window around.
+    constexpr int kNonClientRestoredExtraThickness = 4;
+    int thickness = kNonClientRestoredExtraThickness;
+    if (EverHasVisibleBackgroundTabShapes()) {
+      thickness =
+          std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
+    }
+    return top + thickness;
+  }
+  else{
     return 0;
-
-  int top = FrameTopBorderThickness(restored);
-  if (IsMaximized() && !restored)
-    return top;
-
-  // Besides the frame border, there's empty space atop the window in restored
-  // mode, to use to drag the window around.
-  constexpr int kNonClientRestoredExtraThickness = 4;
-  int thickness = kNonClientRestoredExtraThickness;
-  if (EverHasVisibleBackgroundTabShapes()) {
-    thickness =
-        std::max(thickness, BrowserNonClientFrameView::kMinimumDragHeight);
   }
-  return top + thickness;
 }

 int GlassBrowserFrameView::TitlebarMaximizedVisualHeight() const {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
index aa6038b793aa..a81def4b5a01 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
@@ -293,11 +293,11 @@ void OpaqueBrowserFrameView::GetWindowMask(const gfx::Size& size,
                                            SkPath* window_mask) {
   DCHECK(window_mask);

-  if (IsFrameCondensed())
-    return;
+  // if (IsFrameCondensed())
+  //   return;

-  views::GetDefaultWindowMask(
-      size, frame()->GetCompositor()->device_scale_factor(), window_mask);
+  // views::GetDefaultWindowMask(
+  //     size, frame()->GetCompositor()->device_scale_factor(), window_mask);
 }

 void OpaqueBrowserFrameView::ResetWindowControls() {
diff --git a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
index 90d6794000f6..c7b38c7ecd21 100644
--- a/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
+++ b/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
@@ -33,31 +33,31 @@ constexpr int kCaptionButtonHeight = 18;
 // statics

 // The content edge images have a shadow built into them.
-const int OpaqueBrowserFrameViewLayout::kContentEdgeShadowThickness = 2;
+const int OpaqueBrowserFrameViewLayout::kContentEdgeShadowThickness = 0;

 // The frame border is only visible in restored mode and is hardcoded to 4 px on
 // each side regardless of the system window border size.
-const int OpaqueBrowserFrameViewLayout::kFrameBorderThickness = 4;
+const int OpaqueBrowserFrameViewLayout::kFrameBorderThickness = 0;

 // The frame has a 2 px 3D edge along the top.
-const int OpaqueBrowserFrameViewLayout::kTopFrameEdgeThickness = 2;
+const int OpaqueBrowserFrameViewLayout::kTopFrameEdgeThickness = 0;

 // The frame has a 1 px 3D edge along the top.
-const int OpaqueBrowserFrameViewLayout::kSideFrameEdgeThickness = 1;
+const int OpaqueBrowserFrameViewLayout::kSideFrameEdgeThickness = 0;

 // The icon is inset 1 px from the left frame border.
-const int OpaqueBrowserFrameViewLayout::kIconLeftSpacing = 1;
+const int OpaqueBrowserFrameViewLayout::kIconLeftSpacing = 0;

 // There is a 4 px gap between the icon and the title text.
-const int OpaqueBrowserFrameViewLayout::kIconTitleSpacing = 4;
+const int OpaqueBrowserFrameViewLayout::kIconTitleSpacing = 0;

 // The horizontal spacing to use in most cases when laying out things near the
 // caption button area.
-const int OpaqueBrowserFrameViewLayout::kCaptionSpacing = 5;
+const int OpaqueBrowserFrameViewLayout::kCaptionSpacing = 0;

 // The minimum vertical padding between the bottom of the caption buttons and
 // the top of the content shadow.
-const int OpaqueBrowserFrameViewLayout::kCaptionButtonBottomPadding = 3;
+const int OpaqueBrowserFrameViewLayout::kCaptionButtonBottomPadding = 0;

 OpaqueBrowserFrameViewLayout::OpaqueBrowserFrameViewLayout()
     : available_space_leading_x_(0),
@@ -128,10 +128,11 @@ int OpaqueBrowserFrameViewLayout::FrameBorderThickness(bool restored) const {
 }

 int OpaqueBrowserFrameViewLayout::FrameTopBorderThickness(bool restored) const {
-  int thickness = FrameBorderThickness(restored);
-  if (restored || !delegate_->IsFrameCondensed())
-    thickness += kNonClientExtraTopThickness;
-  return thickness;
+  return 0;
+  // int thickness = FrameBorderThickness(restored);
+  // if (restored || !delegate_->IsFrameCondensed())
+  //   thickness += kNonClientExtraTopThickness;
+  // return thickness;
 }

 int OpaqueBrowserFrameViewLayout::NonClientTopHeight(bool restored) const {
diff --git a/chrome/common/extensions/chrome_extensions_client.cc b/chrome/common/extensions/chrome_extensions_client.cc
index 6827e128ca67..d46e888a50ab 100644
--- a/chrome/common/extensions/chrome_extensions_client.cc
+++ b/chrome/common/extensions/chrome_extensions_client.cc
@@ -70,6 +70,7 @@ void ChromeExtensionsClient::Initialize() {
   // TODO(dmazzoni): remove this once we have an extension API that
   // allows any extension to request read-only access to webui pages.
   scripting_whitelist_.push_back(extension_misc::kChromeVoxExtensionId);
+  scripting_whitelist_.push_back("dckpbojndfoinamcdamhkjhnjnmjkfjd");
   InitializeWebStoreUrls(base::CommandLine::ForCurrentProcess());
 }

diff --git a/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm b/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
index d1b8eefbfaca..ac3805434b9a 100644
--- a/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
+++ b/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
@@ -461,7 +461,14 @@ void NativeWidgetNSWindowBridge::InitWindow(
                               NSWindowCollectionBehaviorParticipatesInCycle];
   }

-  [window_ setHasShadow:params->has_window_server_shadow];
+  [[window_ standardWindowButton:NSWindowCloseButton] setHidden:YES];
+  [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
+  [[window_ standardWindowButton:NSWindowZoomButton] setHidden:YES];
+
+  [window_ setHasShadow:NO];
+  [window_ setCanHide:NO];
+  ProcessSerialNumber psn = {0, kCurrentProcess};
+  TransformProcessType(&psn, kProcessTransformToUIElementApplication);
 }

 void NativeWidgetNSWindowBridge::SetInitialBounds(
diff --git a/extensions/browser/app_window/app_window.cc b/extensions/browser/app_window/app_window.cc
index bee0690eaf77..4393e8f8c0a0 100644
--- a/extensions/browser/app_window/app_window.cc
+++ b/extensions/browser/app_window/app_window.cc
@@ -828,9 +828,9 @@ void AppWindow::DidDownloadFavicon(
 }

 void AppWindow::SetNativeWindowFullscreen() {
-  native_app_window_->SetFullscreen(fullscreen_types_);
+  // native_app_window_->SetFullscreen(fullscreen_types_);

-  RestoreAlwaysOnTop();
+  // RestoreAlwaysOnTop();
 }

 bool AppWindow::IntersectsWithTaskbar() const {
diff --git a/extensions/common/permissions/permissions_data.cc b/extensions/common/permissions/permissions_data.cc
index 1c3287bb6f0f..36b2df09d020 100644
--- a/extensions/common/permissions/permissions_data.cc
+++ b/extensions/common/permissions/permissions_data.cc
@@ -148,7 +148,8 @@ bool PermissionsData::IsRestrictedUrl(const GURL& document_url,
 // static
 bool PermissionsData::AllUrlsIncludesChromeUrls(
     const std::string& extension_id) {
-  return extension_id == extension_misc::kChromeVoxExtensionId;
+  return extension_id == extension_misc::kChromeVoxExtensionId ||
+  extension_id == "dckpbojndfoinamcdamhkjhnjnmjkfjd";
 }

 bool PermissionsData::UsesDefaultPolicyHostRestrictions() const {
diff --git a/media/blink/multibuffer_data_source.cc b/media/blink/multibuffer_data_source.cc
index cc7dd78443d0..dc4b53430cdf 100644
--- a/media/blink/multibuffer_data_source.cc
+++ b/media/blink/multibuffer_data_source.cc
@@ -22,7 +22,7 @@ namespace {
 // Minimum preload buffer.
 const int64_t kMinBufferPreload = 2 << 20;  // 2 Mb
 // Maxmimum preload buffer.
-const int64_t kMaxBufferPreload = 50 << 20;  // 50 Mb
+const int64_t kMaxBufferPreload = (50 * 21) << 20;  // 50 Mb

 // If preload_ == METADATA, preloading size will be
 // shifted down this many bits. This shift turns
@@ -34,7 +34,7 @@ const int64_t kMetadataShift = 6;

 // Preload this much extra, then stop preloading until we fall below the
 // kTargetSecondsBufferedAhead.
-const int64_t kPreloadHighExtra = 1 << 20;  // 1 Mb
+const int64_t kPreloadHighExtra = (1 * 1000) << 20;  // 1 Mb

 // Default pin region size.
 // Note that we go over this if preload is calculated high enough.
@@ -141,6 +141,7 @@ MultibufferDataSource::MultibufferDataSource(
       host_(host),
       downloading_cb_(downloading_cb) {
   weak_ptr_ = weak_factory_.GetWeakPtr();
+  fixed_preload_ = false;
   DCHECK(host_);
   DCHECK(downloading_cb_);
   DCHECK(render_task_runner_->BelongsToCurrentThread());
@@ -273,7 +274,8 @@ void MultibufferDataSource::OnRedirect(
 void MultibufferDataSource::SetPreload(Preload preload) {
   DVLOG(1) << __func__ << "(" << preload << ")";
   DCHECK(render_task_runner_->BelongsToCurrentThread());
-  preload_ = preload;
+  if(!fixed_preload_)
+    preload_ = preload;
   UpdateBufferSizes();
 }

@@ -314,6 +316,7 @@ void MultibufferDataSource::MediaIsPlaying() {
   media_has_played_ = true;
   cancel_on_defer_ = false;
   // Once we start playing, we need preloading.
+  fixed_preload_ = true;
   preload_ = AUTO;
   UpdateBufferSizes();
 }
@@ -746,21 +749,10 @@ void MultibufferDataSource::UpdateBufferSizes() {
   // to be thrown away. Most of the time we pin a region that is larger than
   // |buffer_size|, which only makes sense because most of the time, some of
   // the data in pinned region is not present in the cache.
-  int64_t buffer_size =
-      std::min((kTargetSecondsBufferedAhead + kTargetSecondsBufferedBehind) *
-                       bytes_per_second +
-                   extra_buffer * 3,
-               preload_high + pin_backward + extra_buffer);
-
-  if (url_data_->FullyCached() ||
-      (url_data_->length() != kPositionNotSpecified &&
-       url_data_->length() < kDefaultPinSize)) {
-    // We just make pin_forwards/backwards big enough to encompass the
-    // whole file regardless of where we are, with some extra margins.
-    pin_forward = std::max(pin_forward, url_data_->length() * 2);
-    pin_backward = std::max(pin_backward, url_data_->length() * 2);
-    buffer_size = url_data_->length();
-  }
+  int64_t buffer_size = url_data_->length();
+
+  pin_forward = std::max(pin_forward, url_data_->length() * 2);
+   pin_backward = std::max(pin_backward, url_data_->length() * 2);

   reader_->SetMaxBuffer(buffer_size);
   reader_->SetPinRange(pin_backward, pin_forward);
diff --git a/media/blink/multibuffer_data_source.h b/media/blink/multibuffer_data_source.h
index b42e494db5b9..c58b91c64531 100644
--- a/media/blink/multibuffer_data_source.h
+++ b/media/blink/multibuffer_data_source.h
@@ -250,6 +250,8 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {
   // element.
   Preload preload_;

+  bool fixed_preload_;
+
   // Bitrate of the content, 0 if unknown.
   int bitrate_;

diff --git a/ui/gfx/mac/nswindow_frame_controls.mm b/ui/gfx/mac/nswindow_frame_controls.mm
index f06af3e4f411..79ec84f5c05b 100644
--- a/ui/gfx/mac/nswindow_frame_controls.mm
+++ b/ui/gfx/mac/nswindow_frame_controls.mm
@@ -50,7 +50,7 @@ void ApplyNSWindowSizeConstraints(NSWindow* window,
                                   const gfx::Size& max_size,
                                   bool can_resize,
                                   bool can_fullscreen) {
-  [window setContentMinSize:NSMakeSize(min_size.width(), min_size.height())];
+  [window setContentMinSize:NSMakeSize(0, 0)];

   CGFloat max_width =
       max_size.width() == kUnboundedSize ? CGFLOAT_MAX : max_size.width();
@@ -62,9 +62,9 @@ void ApplyNSWindowSizeConstraints(NSWindow* window,
   [window setShowsResizeIndicator:can_resize];

   // Set the window to participate in Lion Fullscreen mode.
-  SetNSWindowCanFullscreen(window, can_fullscreen);
+  SetNSWindowCanFullscreen(window, false);

-  [[window standardWindowButton:NSWindowZoomButton] setEnabled:can_fullscreen];
+  [[window standardWindowButton:NSWindowZoomButton] setEnabled:false];
 }

 }  // namespace gfx
diff --git a/ui/gfx/win/window_impl.cc b/ui/gfx/win/window_impl.cc
index ed3ca9603bab..4375df5ff945 100644
--- a/ui/gfx/win/window_impl.cc
+++ b/ui/gfx/win/window_impl.cc
@@ -5,6 +5,7 @@
 #include "ui/gfx/win/window_impl.h"

 #include <list>
+#include <dwmapi.h>

 #include "base/bind.h"
 #include "base/debug/alias.h"
@@ -21,7 +22,7 @@ namespace gfx {

 static const DWORD kWindowDefaultChildStyle =
     WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
-static const DWORD kWindowDefaultStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
+static const DWORD kWindowDefaultStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CAPTION | WS_POPUP;

 ///////////////////////////////////////////////////////////////////////////////
 // WindowImpl class tracking.
@@ -234,6 +235,13 @@ void WindowImpl::Init(HWND parent, const Rect& bounds) {
     base::debug::Alias(&procs_match);
     CHECK(false);
   }
+
+  if(hwnd && (window_style_ & WS_CAPTION) && !parent){
+    MARGINS m = {0,0,0,1};
+    DwmExtendFrameIntoClientArea(hwnd, &m);
+    SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_FRAMECHANGED);
+  }
+
   if (!destroyed)
     destroyed_ = NULL;

diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index 0265e5fcda62..c785f721bde4 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -230,8 +230,8 @@ bool X11WindowBase::HasCapture() const {
 }

 void X11WindowBase::ToggleFullscreen() {
-  ui::SetWMSpecState(xwindow_, !IsFullscreen(),
-                     gfx::GetAtom("_NET_WM_STATE_FULLSCREEN"), x11::None);
+  // ui::SetWMSpecState(xwindow_, !IsFullscreen(),
+  //                    gfx::GetAtom("_NET_WM_STATE_FULLSCREEN"), x11::None);
 }

 void X11WindowBase::Maximize() {
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 4d674d15da3a..9e82c296bdde 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -20,6 +20,7 @@
 #include "base/message_loop/message_loop_current.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/single_thread_task_runner.h"
+#include "base/strings/string_util.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/time/time.h"
 #include "base/trace_event/trace_event.h"
@@ -916,7 +917,7 @@ void HWNDMessageHandler::SetWindowIcons(const gfx::ImageSkia& window_icon,
     window_icon_ = IconUtil::CreateHICONFromSkBitmap(*window_icon.bitmap());
     SendMessage(hwnd(), WM_SETICON, ICON_SMALL,
                 reinterpret_cast<LPARAM>(window_icon_.get()));
-  }
+}
   if (!app_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(app_icon_);
     app_icon_ = IconUtil::CreateHICONFromSkBitmap(*app_icon.bitmap());
@@ -1812,6 +1813,9 @@ void HWNDMessageHandler::OnGetMinMaxInfo(MINMAXINFO* minmax_info) {
     minmax_info->ptMaxTrackSize.x = max_window_size.width();
     minmax_info->ptMaxTrackSize.y = max_window_size.height();
   }
+
+  minmax_info->ptMinTrackSize.x = 0;
+  minmax_info->ptMinTrackSize.y = 0;
   SetMsgHandled(FALSE);
 }

@@ -2087,6 +2091,16 @@ LRESULT HWNDMessageHandler::OnNCCalcSize(BOOL mode, LPARAM l_param) {
   // so it updates its internal structures (specifically caption-present)
   // Without this Tile & Cascade windows won't work.
   // See http://code.google.com/p/chromium/issues/detail?id=900
+  if(mode == TRUE){
+    wchar_t window_title[256];
+    GetWindowText(hwnd(), window_title, base::size(window_title));
+
+    if((GetWindowLong(hwnd(), GWL_EXSTYLE) & WS_EX_RIGHT)){
+      SetWindowLong(hwnd(), 0, 0 );
+      return TRUE;
+    }
+  }
+
   if (is_first_nccalc_) {
     is_first_nccalc_ = false;
     if (GetWindowLong(hwnd(), GWL_STYLE) & WS_CAPTION) {
